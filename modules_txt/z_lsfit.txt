''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2006-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Polynomial fitting report:
'    TaskRCond       reciprocal of task's condition number
'    RMSError        RMS error
'    AvgError        average error
'    AvgRelError     average relative error (for non-zero Y[I])
'    MaxError        maximum error
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type PolynomialFitReport
    TaskRCond As Double
    RMSError As Double
    AvgError As Double
    AvgRelError As Double
    MaxError As Double
End Type
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Barycentric interpolant.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type BarycentricInterpolant
    N As Long
    SY As Double
    X() As Double
    Y() As Double
    w() As Double
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Barycentric fitting report:
'    TaskRCond       reciprocal of task's condition number
'    RMSError        RMS error
'    AvgError        average error
'    AvgRelError     average relative error (for non-zero Y[I])
'    MaxError        maximum error
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type BarycentricFitReport
    TaskRCond As Double
    DBest As Long
    RMSError As Double
    AvgError As Double
    AvgRelError As Double
    MaxError As Double
End Type
'Global constants
Private Const BRCVNum As Long = 10#
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Least squares fitting report:
'    TaskRCond       reciprocal of task's condition number
'    RMSError        RMS error
'    AvgError        average error
'    AvgRelError     average relative error (for non-zero Y[I])
'    MaxError        maximum error
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type LSFitReport
    TaskRCond As Double
    RMSError As Double
    AvgError As Double
    AvgRelError As Double
    MaxError As Double
End Type
Public Type LSFitState
    N As Long
    M As Long
    K As Long
    EpsF As Double
    EpsX As Double
    MaxIts As Long
    StpMax As Double
    TaskX() As Double
    TaskY() As Double
    w() As Double
    CheapFG As Boolean
    HaveHess As Boolean
    NeedF As Boolean
    NeedFG As Boolean
    NeedFGH As Boolean
    PointIndex As Long
    X() As Double
    c() As Double
    F As Double
    G() As Double
    H() As Double
    RepTerminationType As Long
    RepRMSError As Double
    RepAvgError As Double
    RepAvgRelError As Double
    RepMaxError As Double
    OptState As MinLMState
    OptRep As MinLMReport
    RState As RCommState
End Type
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted linear least squares fitting.
'
'QR decomposition is used to reduce task to MxM, then triangular solver  or
'SVD-based solver is used depending on condition number of the  system.  It
'allows to maximize speed and retain decent accuracy.
'
'INPUT PARAMETERS:
'    Y       -   array[0..N-1] Function values in  N  points.
'    W       -   array[0..N-1]  Weights  corresponding to function  values.
'                Each summand in square  sum  of  approximation  deviations
'                from  given  values  is  multiplied  by  the   square   of
'                corresponding weight.
'    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                FMatrix[I, J] - value of J-th basis function in I-th point.
'    N       -   number of points used. N>=1.
'    M       -   number of basis functions, M>=1.
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -4    internal SVD decomposition subroutine failed (very
'                        rare and for degenerate systems only)
'                * -1    incorrect N/M were specified
'                *  1    task is solved
'    C       -   decomposition coefficients, array[0..M-1]
'    Rep     -   fitting report. Following fields are set:
'                * Rep.TaskRCond     reciprocal of condition number
'                * RMSError          rms error on the (X,Y).
'                * AvgError          average error on the (X,Y).
'                * AvgRelError       average relative error on the non-zero Y
'                * MaxError          maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'SEE ALSO
'    LSFitLinear
'    LSFitLinearC
'    LSFitLinearWC
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinearW(ByRef Y() As Double, _
         ByRef w() As Double, _
         ByRef FMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef c() As Double, _
         ByRef Rep As LSFitReport)
    Call LSFitLinearInternal(Y, w, FMatrix, N, M, Info, c, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted constained linear least squares fitting.
'
'This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
'that  K  additional  constaints  C*x=bc are satisfied. It reduces original
'task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
'is called.
'
'INPUT PARAMETERS:
'    Y       -   array[0..N-1] Function values in  N  points.
'    W       -   array[0..N-1]  Weights  corresponding to function  values.
'                Each summand in square  sum  of  approximation  deviations
'                from  given  values  is  multiplied  by  the   square   of
'                corresponding weight.
'    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                FMatrix[I,J] - value of J-th basis function in I-th point.
'    CMatrix -   a table of constaints, array[0..K-1,0..M].
'                I-th row of CMatrix corresponds to I-th linear constraint:
'                CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
'    N       -   number of points used. N>=1.
'    M       -   number of basis functions, M>=1.
'    K       -   number of constraints, 0 <= K < M
'                K=0 corresponds to absence of constraints.
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -4    internal SVD decomposition subroutine failed (very
'                        rare and for degenerate systems only)
'                * -3    either   too   many  constraints  (M   or   more),
'                        degenerate  constraints   (some   constraints  are
'                        repetead twice) or inconsistent  constraints  were
'                        specified.
'                * -1    incorrect N/M/K were specified
'                *  1    task is solved
'    C       -   decomposition coefficients, array[0..M-1]
'    Rep     -   fitting report. Following fields are set:
'                * RMSError          rms error on the (X,Y).
'                * AvgError          average error on the (X,Y).
'                * AvgRelError       average relative error on the non-zero Y
'                * MaxError          maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'SEE ALSO
'    LSFitLinear
'    LSFitLinearC
'    LSFitLinearWC
'
'  -- ALGLIB --
'     Copyright 07.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinearWC(ByRef y_() As Double, _
         ByRef w() As Double, _
         ByRef FMatrix() As Double, _
         ByRef CMatrix_() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef Info As Long, _
         ByRef c() As Double, _
         ByRef Rep As LSFitReport)
    Dim Y() As Double
    Dim CMatrix() As Double
    Dim i As Long
    Dim j As Long
    Dim Tau() As Double
    Dim q() As Double
    Dim F2() As Double
    Dim Tmp() As Double
    Dim C0() As Double
    Dim V As Double
    Dim i_ As Long
    Y = y_
    CMatrix = CMatrix_
    If N < 1# Or M < 1# Or K < 0# Then
        Info = -1#
        Exit Sub
    End If
    If K >= M Then
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Solve
    '
    If K = 0# Then
        
        '
        ' no constraints
        '
        Call LSFitLinearInternal(Y, w, FMatrix, N, M, Info, c, Rep)
    Else
        
        '
        ' First, find general form solution of constraints system:
        ' * factorize C = L*Q
        ' * unpack Q
        ' * fill upper part of C with zeros (for RCond)
        '
        ' We got C=C0+Q2'*y where Q2 is lower M-K rows of Q.
        '
        Call RMatrixLQ(CMatrix, K, M, Tau)
        Call RMatrixLQUnpackQ(CMatrix, K, M, Tau, M, q)
        For i = 0# To K - 1# Step 1
            For j = i + 1# To M - 1# Step 1
                CMatrix(i, j) = 0#
            Next j
        Next i
        If RMatrixLURCondInf(CMatrix, K) < 1000# * MachineEpsilon Then
            Info = -3#
            Exit Sub
        End If
        ReDim Tmp(0 To K - 1)
        For i = 0# To K - 1# Step 1
            If i > 0# Then
                V = 0#
                For i_ = 0# To i - 1# Step 1
                    V = V + CMatrix(i, i_) * Tmp(i_)
                Next i_
            Else
                V = 0#
            End If
            Tmp(i) = (CMatrix(i, M) - V) / CMatrix(i, i)
        Next i
        ReDim C0(0 To M - 1)
        For i = 0# To M - 1# Step 1
            C0(i) = 0#
        Next i
        For i = 0# To K - 1# Step 1
            V = Tmp(i)
            For i_ = 0# To M - 1# Step 1
                C0(i_) = C0(i_) + V * q(i, i_)
            Next i_
        Next i
        
        '
        ' Second, prepare modified matrix F2 = F*Q2' and solve modified task
        '
        ReDim Tmp(0 To MaxInt(N, M) + 1# - 1)
        ReDim F2(0 To N - 1, 0 To M - K - 1)
        Call MatrixVectorMultiply(FMatrix, 0#, N - 1#, 0#, M - 1#, False, C0, 0#, M - 1#, -1#, Y, 0#, N - 1#, 1#)
        Call MatrixMatrixMultiply(FMatrix, 0#, N - 1#, 0#, M - 1#, False, q, K, M - 1#, 0#, M - 1#, True, 1#, F2, 0#, N - 1#, 0#, M - K - 1#, 0#, Tmp)
        Call LSFitLinearInternal(Y, w, F2, N, M - K, Info, Tmp, Rep)
        Rep.TaskRCond = -1#
        If Info <= 0# Then
            Exit Sub
        End If
        
        '
        ' then, convert back to original answer: C = C0 + Q2'*Y0
        '
        ReDim c(0 To M - 1)
        For i_ = 0# To M - 1# Step 1
            c(i_) = C0(i_)
        Next i_
        Call MatrixVectorMultiply(q, K, M - 1#, 0#, M - 1#, True, Tmp, 0#, M - K - 1#, 1#, c, 0#, M - 1#, 1#)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Linear least squares fitting, without weights.
'
'See LSFitLinearW for more information.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinear(ByRef Y() As Double, _
         ByRef FMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef c() As Double, _
         ByRef Rep As LSFitReport)
    Dim w() As Double
    Dim i As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim w(0 To N - 1)
    For i = 0# To N - 1# Step 1
        w(i) = 1#
    Next i
    Call LSFitLinearInternal(Y, w, FMatrix, N, M, Info, c, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Constained linear least squares fitting, without weights.
'
'See LSFitLinearWC() for more information.
'
'  -- ALGLIB --
'     Copyright 07.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinearC(ByRef y_() As Double, _
         ByRef FMatrix() As Double, _
         ByRef CMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef Info As Long, _
         ByRef c() As Double, _
         ByRef Rep As LSFitReport)
    Dim Y() As Double
    Dim w() As Double
    Dim i As Long
    Y = y_
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim w(0 To N - 1)
    For i = 0# To N - 1# Step 1
        w(i) = 1#
    Next i
    Call LSFitLinearWC(Y, w, FMatrix, CMatrix, N, M, K, Info, c, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted nonlinear least squares fitting using gradient and Hessian.
'
'Nonlinear task min(F(c)) is solved, where
'
'    F(c) = (w[0]*(f(x[0],c)-y[0]))^2 + ... + (w[n-1]*(f(x[n-1],c)-y[n-1]))^2,
'
'    * N is a number of points,
'    * M is a dimension of a space points belong to,
'    * K is a dimension of a space of parameters being fitted,
'    * w is an N-dimensional vector of weight coefficients,
'    * x is a set of N points, each of them is an M-dimensional vector,
'    * c is a K-dimensional vector of parameters being fitted
'
'This subroutine uses only f(x[i],c) and its gradient.
'
'INPUT PARAMETERS:
'    X       -   array[0..N-1,0..M-1], points (one row = one point)
'    Y       -   array[0..N-1], function values.
'    W       -   weights, array[0..N-1]
'    C       -   array[0..K-1], initial approximation to the solution,
'    N       -   number of points, N>1
'    M       -   dimension of space
'    K       -   number of parameters being fitted
'    CheapFG -   boolean flag, which is:
'                * True  if both function and gradient calculation complexity
'                        are less than O(M^2).  An improved  algorithm  can
'                        be  used  which corresponds  to  FGJ  scheme  from
'                        MINLM unit.
'                * False otherwise.
'                        Standard Jacibian-bases  Levenberg-Marquardt  algo
'                        will be used (FJ scheme).
'
'OUTPUT PARAMETERS:
'    State   -   structure which stores algorithm state between subsequent
'                calls  of   LSFitNonlinearIteration.   Used  for  reverse
'                communication.  This  structure   should   be  passed  to
'                LSFitNonlinearIteration subroutine.
'
'See also:
'    LSFitNonlinearIteration
'    LSFitNonlinearResults
'    LSFitNonlinearFG (fitting without weights)
'    LSFitNonlinearWFGH (fitting using Hessian)
'    LSFitNonlinearFGH (fitting using Hessian, without weights)
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearWFG(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef w() As Double, _
         ByRef c() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByVal CheapFG As Boolean, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = CheapFG
    State.HaveHess = False
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.w(0 To N - 1)
        ReDim State.c(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.c(i_) = c(i_)
        Next i_
        For i_ = 0# To N - 1# Step 1
            State.w(i_) = w(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = X(i, i_)
            Next i_
            State.TaskY(i) = Y(i)
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting, no individual weights.
'See LSFitNonlinearWFG for more information.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearFG(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef c() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByVal CheapFG As Boolean, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = CheapFG
    State.HaveHess = False
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.w(0 To N - 1)
        ReDim State.c(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.c(i_) = c(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = X(i, i_)
            Next i_
            State.TaskY(i) = Y(i)
            State.w(i) = 1#
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted nonlinear least squares fitting using gradient/Hessian.
'
'Nonlinear task min(F(c)) is solved, where
'
'    F(c) = (w[0]*(f(x[0],c)-y[0]))^2 + ... + (w[n-1]*(f(x[n-1],c)-y[n-1]))^2,
'
'    * N is a number of points,
'    * M is a dimension of a space points belong to,
'    * K is a dimension of a space of parameters being fitted,
'    * w is an N-dimensional vector of weight coefficients,
'    * x is a set of N points, each of them is an M-dimensional vector,
'    * c is a K-dimensional vector of parameters being fitted
'
'This subroutine uses f(x[i],c), its gradient and its Hessian.
'
'See LSFitNonlinearWFG() subroutine for information about function
'parameters.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearWFGH(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef w() As Double, _
         ByRef c() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = True
    State.HaveHess = True
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.w(0 To N - 1)
        ReDim State.c(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.c(i_) = c(i_)
        Next i_
        For i_ = 0# To N - 1# Step 1
            State.w(i_) = w(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = X(i, i_)
            Next i_
            State.TaskY(i) = Y(i)
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting using gradient/Hessian without  individual
'weights. See LSFitNonlinearWFGH() for more information.
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearFGH(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef c() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = True
    State.HaveHess = True
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.w(0 To N - 1)
        ReDim State.c(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.c(i_) = c(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = X(i, i_)
            Next i_
            State.TaskY(i) = Y(i)
            State.w(i) = 1#
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Stopping conditions for nonlinear least squares fitting.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with LSFitNonLinearCreate???()
'    EpsF    -   stopping criterion. Algorithm stops if
'                |F(k+1)-F(k)| <= EpsF*max{|F(k)|, |F(k+1)|, 1}
'    EpsX    -   stopping criterion. Algorithm stops if
'                |X(k+1)-X(k)| <= EpsX*(1+|X(k)|)
'    MaxIts  -   stopping criterion. Algorithm stops after MaxIts iterations.
'                MaxIts=0 means no stopping criterion.
'
'NOTE
'
'Passing EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to automatic
'stopping criterion selection (according to the scheme used by MINLM unit).
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearSetCond(ByRef State As LSFitState, _
         ByVal EpsF As Double, _
         ByVal EpsX As Double, _
         ByVal MaxIts As Long)
    State.EpsF = EpsF
    State.EpsX = EpsX
    State.MaxIts = MaxIts
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets maximum step length
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with LSFitNonLinearCreate???()
'    StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
'                want to limit step length.
'
'Use this subroutine when you optimize target function which contains exp()
'or  other  fast  growing  functions,  and optimization algorithm makes too
'large  steps  which  leads  to overflow. This function allows us to reject
'steps  that  are  too  large  (and  therefore  expose  us  to the possible
'overflow) without actually calculating function value at the x+stp*d.
'
'NOTE: non-zero StpMax leads to moderate  performance  degradation  because
'intermediate  step  of  preconditioned L-BFGS optimization is incompatible
'with limits on step size.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearSetStpMax(ByRef State As LSFitState, _
         ByVal StpMax As Double)
    State.StpMax = StpMax
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting. Algorithm iteration.
'
'Called after inialization of the State structure with  LSFitNonlinearXXX()
'subroutine. See HTML docs for examples.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between  subsequent
'                calls and which is used for reverse communication. Must be
'                initialized with LSFitNonlinearXXX() call first.
'
'RESULT
'1. If subroutine returned False, iterative algorithm has converged.
'2. If subroutine returned True, then if:
'* if State.NeedF=True,      function value F(X,C) is required
'* if State.NeedFG=True,     function value F(X,C) and gradient  dF/dC(X,C)
'                            are required
'* if State.NeedFGH=True     function value F(X,C), gradient dF/dC(X,C) and
'                            Hessian are required
'
'One and only one of this fields can be set at time.
'
'Function, its gradient and Hessian are calculated at  (X,C),  where  X  is
'stored in State.X[0..M-1] and C is stored in State.C[0..K-1].
'
'Results are stored:
'* function value            -   in State.F
'* gradient                  -   in State.G[0..K-1]
'* Hessian                   -   in State.H[0..K-1,0..K-1]
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function LSFitNonlinearIteration(ByRef State As LSFitState) As Boolean
    Dim Result As Boolean
    Dim N As Long
    Dim M As Long
    Dim K As Long
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim RelCnt As Double
    Dim i_ As Long
    
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        N = State.RState.IA(0#)
        M = State.RState.IA(1#)
        K = State.RState.IA(2#)
        i = State.RState.IA(3#)
        j = State.RState.IA(4#)
        V = State.RState.RA(0#)
        RelCnt = State.RState.RA(1#)
    Else
        N = -983#
        M = -989#
        K = -834#
        i = 900#
        j = -287#
        V = 364#
        RelCnt = 214#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    If State.RState.Stage = 3# Then
        GoTo lbl_3
    End If
    If State.RState.Stage = 4# Then
        GoTo lbl_4
    End If
    
    '
    ' Routine body
    '
    
    '
    ' check params
    '
    If State.N < 1# Or State.M < 1# Or State.K < 1# Or State.EpsF < 0# Or State.EpsX < 0# Or State.MaxIts < 0# Then
        State.RepTerminationType = -1#
        Result = False
        LSFitNonlinearIteration = Result
        Exit Function
    End If
    
    '
    ' init
    '
    N = State.N
    M = State.M
    K = State.K
    ReDim State.X(0 To M - 1)
    ReDim State.G(0 To K - 1)
    If State.HaveHess Then
        ReDim State.H(0 To K - 1, 0 To K - 1)
    End If
    
    '
    ' initialize LM optimizer
    '
    If State.HaveHess Then
        
        '
        ' use Hessian.
        ' transform stopping conditions.
        '
        Call MinLMCreateFGH(K, State.c, State.OptState)
    Else
        
        '
        ' use one of gradient-based schemes (depending on gradient cost).
        ' transform stopping conditions.
        '
        If State.CheapFG Then
            Call MinLMCreateFGJ(K, N, State.c, State.OptState)
        Else
            Call MinLMCreateFJ(K, N, State.c, State.OptState)
        End If
    End If
    Call MinLMSetCond(State.OptState, 0#, State.EpsF, State.EpsX, State.MaxIts)
    Call MinLMSetStpMax(State.OptState, State.StpMax)
    
    '
    ' Optimize
    '
lbl_5:
    If Not MinLMIteration(State.OptState) Then
        GoTo lbl_6
    End If
    If Not State.OptState.NeedF Then
        GoTo lbl_7
    End If
    
    '
    ' calculate F = sum (wi*(f(xi,c)-yi))^2
    '
    State.OptState.F = 0#
    i = 0#
lbl_9:
    If i > N - 1# Then
        GoTo lbl_11
    End If
    For i_ = 0# To K - 1# Step 1
        State.c(i_) = State.OptState.X(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.X(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    State.OptState.F = State.OptState.F + Square(State.w(i) * (State.F - State.TaskY(i)))
    i = i + 1#
    GoTo lbl_9
lbl_11:
    GoTo lbl_5
lbl_7:
    If Not State.OptState.NeedFG Then
        GoTo lbl_12
    End If
    
    '
    ' calculate F/gradF
    '
    State.OptState.F = 0#
    For i = 0# To K - 1# Step 1
        State.OptState.G(i) = 0#
    Next i
    i = 0#
lbl_14:
    If i > N - 1# Then
        GoTo lbl_16
    End If
    For i_ = 0# To K - 1# Step 1
        State.c(i_) = State.OptState.X(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.X(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
    State.OptState.F = State.OptState.F + Square(State.w(i) * (State.F - State.TaskY(i)))
    V = Square(State.w(i)) * 2# * (State.F - State.TaskY(i))
    For i_ = 0# To K - 1# Step 1
        State.OptState.G(i_) = State.OptState.G(i_) + V * State.G(i_)
    Next i_
    i = i + 1#
    GoTo lbl_14
lbl_16:
    GoTo lbl_5
lbl_12:
    If Not State.OptState.NeedFiJ Then
        GoTo lbl_17
    End If
    
    '
    ' calculate Fi/jac(Fi)
    '
    i = 0#
lbl_19:
    If i > N - 1# Then
        GoTo lbl_21
    End If
    For i_ = 0# To K - 1# Step 1
        State.c(i_) = State.OptState.X(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.X(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    State.OptState.FI(i) = State.w(i) * (State.F - State.TaskY(i))
    V = State.w(i)
    For i_ = 0# To K - 1# Step 1
        State.OptState.j(i, i_) = V * State.G(i_)
    Next i_
    i = i + 1#
    GoTo lbl_19
lbl_21:
    GoTo lbl_5
lbl_17:
    If Not State.OptState.NeedFGH Then
        GoTo lbl_22
    End If
    
    '
    ' calculate F/grad(F)/hess(F)
    '
    State.OptState.F = 0#
    For i = 0# To K - 1# Step 1
        State.OptState.G(i) = 0#
    Next i
    For i = 0# To K - 1# Step 1
        For j = 0# To K - 1# Step 1
            State.OptState.H(i, j) = 0#
        Next j
    Next i
    i = 0#
lbl_24:
    If i > N - 1# Then
        GoTo lbl_26
    End If
    For i_ = 0# To K - 1# Step 1
        State.c(i_) = State.OptState.X(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.X(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedFGH = True
    State.RState.Stage = 3#
    GoTo lbl_rcomm
lbl_3:
    State.OptState.F = State.OptState.F + Square(State.w(i) * (State.F - State.TaskY(i)))
    V = Square(State.w(i)) * 2# * (State.F - State.TaskY(i))
    For i_ = 0# To K - 1# Step 1
        State.OptState.G(i_) = State.OptState.G(i_) + V * State.G(i_)
    Next i_
    For j = 0# To K - 1# Step 1
        V = 2# * Square(State.w(i)) * State.G(j)
        For i_ = 0# To K - 1# Step 1
            State.OptState.H(j, i_) = State.OptState.H(j, i_) + V * State.G(i_)
        Next i_
        V = 2# * Square(State.w(i)) * (State.F - State.TaskY(i))
        For i_ = 0# To K - 1# Step 1
            State.OptState.H(j, i_) = State.OptState.H(j, i_) + V * State.H(j, i_)
        Next i_
    Next j
    i = i + 1#
    GoTo lbl_24
lbl_26:
    GoTo lbl_5
lbl_22:
    GoTo lbl_5
lbl_6:
    Call MinLMResults(State.OptState, State.c, State.OptRep)
    State.RepTerminationType = State.OptRep.TerminationType
    
    '
    ' calculate errors
    '
    If State.RepTerminationType <= 0# Then
        GoTo lbl_27
    End If
    State.RepRMSError = 0#
    State.RepAvgError = 0#
    State.RepAvgRelError = 0#
    State.RepMaxError = 0#
    RelCnt = 0#
    i = 0#
lbl_29:
    If i > N - 1# Then
        GoTo lbl_31
    End If
    For i_ = 0# To K - 1# Step 1
        State.c(i_) = State.c(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.X(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 4#
    GoTo lbl_rcomm
lbl_4:
    V = State.F
    State.RepRMSError = State.RepRMSError + Square(V - State.TaskY(i))
    State.RepAvgError = State.RepAvgError + Abs(V - State.TaskY(i))
    If State.TaskY(i) <> 0# Then
        State.RepAvgRelError = State.RepAvgRelError + Abs(V - State.TaskY(i)) / Abs(State.TaskY(i))
        RelCnt = RelCnt + 1#
    End If
    State.RepMaxError = MaxReal(State.RepMaxError, Abs(V - State.TaskY(i)))
    i = i + 1#
    GoTo lbl_29
lbl_31:
    State.RepRMSError = Sqr(State.RepRMSError / N)
    State.RepAvgError = State.RepAvgError / N
    If RelCnt <> 0# Then
        State.RepAvgRelError = State.RepAvgRelError / RelCnt
    End If
lbl_27:
    Result = False
    LSFitNonlinearIteration = Result
    Exit Function
    
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = N
    State.RState.IA(1#) = M
    State.RState.IA(2#) = K
    State.RState.IA(3#) = i
    State.RState.IA(4#) = j
    State.RState.RA(0#) = V
    State.RState.RA(1#) = RelCnt
    LSFitNonlinearIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting results.
'
'Called after LSFitNonlinearIteration() returned False.
'
'INPUT PARAMETERS:
'    State   -   algorithm state (used by LSFitNonlinearIteration).
'
'OUTPUT PARAMETERS:
'    Info    -   completetion code:
'                    * -1    incorrect parameters were specified
'                    *  1    relative function improvement is no more than
'                            EpsF.
'                    *  2    relative step is no more than EpsX.
'                    *  4    gradient norm is no more than EpsG
'                    *  5    MaxIts steps was taken
'    C       -   array[0..K-1], solution
'    Rep     -   optimization report. Following fields are set:
'                * Rep.TerminationType completetion code:
'                * RMSError          rms error on the (X,Y).
'                * AvgError          average error on the (X,Y).
'                * AvgRelError       average relative error on the non-zero Y
'                * MaxError          maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearResults(ByRef State As LSFitState, _
         ByRef Info As Long, _
         ByRef c() As Double, _
         ByRef Rep As LSFitReport)
    Dim i_ As Long
    Info = State.RepTerminationType
    If Info > 0# Then
        ReDim c(0 To State.K - 1)
        For i_ = 0# To State.K - 1# Step 1
            c(i_) = State.c(i_)
        Next i_
        Rep.RMSError = State.RepRMSError
        Rep.AvgError = State.RepAvgError
        Rep.AvgRelError = State.RepAvgRelError
        Rep.MaxError = State.RepMaxError
    End If
End Sub
Public Sub LSFitScaleXY(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByRef XC() As Double, _
         ByRef YC() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByRef XA As Double, _
         ByRef XB As Double, _
         ByRef SA As Double, _
         ByRef SB As Double, _
         ByRef XOriginal() As Double, _
         ByRef YOriginal() As Double)
    Dim XMin As Double
    Dim XMAX As Double
    Dim i As Long
    Dim i_ As Long
    
    '
    ' Calculate xmin/xmax.
    ' Force xmin<>xmax.
    '
    XMin = X(0#)
    XMAX = X(0#)
    For i = 1# To N - 1# Step 1
        XMin = MinReal(XMin, X(i))
        XMAX = MaxReal(XMAX, X(i))
    Next i
    For i = 0# To K - 1# Step 1
        XMin = MinReal(XMin, XC(i))
        XMAX = MaxReal(XMAX, XC(i))
    Next i
    If XMin = XMAX Then
        If XMin = 0# Then
            XMin = -1#
            XMAX = 1#
        Else
            XMin = 0.5 * XMin
        End If
    End If
    
    '
    ' Transform abscissas: map [XA,XB] to [0,1]
    '
    ' Store old X[] in XOriginal[] (it will be used
    ' to calculate relative error).
    '
    ReDim XOriginal(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        XOriginal(i_) = X(i_)
    Next i_
    XA = XMin
    XB = XMAX
    For i = 0# To N - 1# Step 1
        X(i) = 2# * (X(i) - 0.5 * (XA + XB)) / (XB - XA)
    Next i
    For i = 0# To K - 1# Step 1
        XC(i) = 2# * (XC(i) - 0.5 * (XA + XB)) / (XB - XA)
        YC(i) = YC(i) * Power(0.5 * (XB - XA), DC(i))
    Next i
    
    '
    ' Transform function values: map [SA,SB] to [0,1]
    ' SA = mean(Y),
    ' SB = SA+stddev(Y).
    '
    ' Store old Y[] in YOriginal[] (it will be used
    ' to calculate relative error).
    '
    ReDim YOriginal(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        YOriginal(i_) = Y(i_)
    Next i_
    SA = 0#
    For i = 0# To N - 1# Step 1
        SA = SA + Y(i)
    Next i
    SA = SA / N
    SB = 0#
    For i = 0# To N - 1# Step 1
        SB = SB + Square(Y(i) - SA)
    Next i
    SB = Sqr(SB / N) + SA
    If SB = SA Then
        SB = 2# * SA
    End If
    If SB = SA Then
        SB = SA + 1#
    End If
    For i = 0# To N - 1# Step 1
        Y(i) = (Y(i) - SA) / (SB - SA)
    Next i
    For i = 0# To K - 1# Step 1
        If DC(i) = 0# Then
            YC(i) = (YC(i) - SA) / (SB - SA)
        Else
            YC(i) = YC(i) / (SB - SA)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal fitting subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub LSFitLinearInternal(ByRef Y() As Double, _
         ByRef w() As Double, _
         ByRef FMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef c() As Double, _
         ByRef Rep As LSFitReport)
    Dim Threshold As Double
    Dim FT() As Double
    Dim q() As Double
    Dim L() As Double
    Dim R() As Double
    Dim B() As Double
    Dim WMod() As Double
    Dim Tau() As Double
    Dim i As Long
    Dim j As Long
    Dim V As Double
    Dim SV() As Double
    Dim U() As Double
    Dim VT() As Double
    Dim Tmp() As Double
    Dim UTB() As Double
    Dim SUTB() As Double
    Dim RelCnt As Long
    Dim i_ As Long
    If N < 1# Or M < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    Threshold = Sqr(MachineEpsilon)
    
    '
    ' Degenerate case, needs special handling
    '
    If N < M Then
        
        '
        ' Create design matrix.
        '
        ReDim FT(0 To N - 1, 0 To M - 1)
        ReDim B(0 To N - 1)
        ReDim WMod(0 To N - 1)
        For j = 0# To N - 1# Step 1
            V = w(j)
            For i_ = 0# To M - 1# Step 1
                FT(j, i_) = V * FMatrix(j, i_)
            Next i_
            B(j) = w(j) * Y(j)
            WMod(j) = 1#
        Next j
        
        '
        ' LQ decomposition and reduction to M=N
        '
        ReDim c(0 To M - 1)
        For i = 0# To M - 1# Step 1
            c(i) = 0#
        Next i
        Rep.TaskRCond = 0#
        Call RMatrixLQ(FT, N, M, Tau)
        Call RMatrixLQUnpackQ(FT, N, M, Tau, N, q)
        Call RMatrixLQUnpackL(FT, N, M, L)
        Call LSFitLinearInternal(B, WMod, L, N, N, Info, Tmp, Rep)
        If Info <= 0# Then
            Exit Sub
        End If
        For i = 0# To N - 1# Step 1
            V = Tmp(i)
            For i_ = 0# To M - 1# Step 1
                c(i_) = c(i_) + V * q(i, i_)
            Next i_
        Next i
        Exit Sub
    End If
    
    '
    ' N>=M. Generate design matrix and reduce to N=M using
    ' QR decomposition.
    '
    ReDim FT(0 To N - 1, 0 To M - 1)
    ReDim B(0 To N - 1)
    For j = 0# To N - 1# Step 1
        V = w(j)
        For i_ = 0# To M - 1# Step 1
            FT(j, i_) = V * FMatrix(j, i_)
        Next i_
        B(j) = w(j) * Y(j)
    Next j
    Call RMatrixQR(FT, N, M, Tau)
    Call RMatrixQRUnpackQ(FT, N, M, Tau, M, q)
    Call RMatrixQRUnpackR(FT, N, M, R)
    ReDim Tmp(0 To M - 1)
    For i = 0# To M - 1# Step 1
        Tmp(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        V = B(i)
        For i_ = 0# To M - 1# Step 1
            Tmp(i_) = Tmp(i_) + V * q(i, i_)
        Next i_
    Next i
    ReDim B(0 To M - 1)
    For i_ = 0# To M - 1# Step 1
        B(i_) = Tmp(i_)
    Next i_
    
    '
    ' R contains reduced MxM design upper triangular matrix,
    ' B contains reduced Mx1 right part.
    '
    ' Determine system condition number and decide
    ' should we use triangular solver (faster) or
    ' SVD-based solver (more stable).
    '
    ' We can use LU-based RCond estimator for this task.
    '
    Rep.TaskRCond = RMatrixLURCondInf(R, M)
    If Rep.TaskRCond > Threshold Then
        
        '
        ' use QR-based solver
        '
        ReDim c(0 To M - 1)
        c(M - 1#) = B(M - 1#) / R(M - 1#, M - 1#)
        For i = M - 2# To 0# Step -1
            V = 0#
            For i_ = i + 1# To M - 1# Step 1
                V = V + R(i, i_) * c(i_)
            Next i_
            c(i) = (B(i) - V) / R(i, i)
        Next i
    Else
        
        '
        ' use SVD-based solver
        '
        If Not RMatrixSVD(R, M, M, 1#, 1#, 2#, SV, U, VT) Then
            Info = -4#
            Exit Sub
        End If
        ReDim UTB(0 To M - 1)
        ReDim SUTB(0 To M - 1)
        For i = 0# To M - 1# Step 1
            UTB(i) = 0#
        Next i
        For i = 0# To M - 1# Step 1
            V = B(i)
            For i_ = 0# To M - 1# Step 1
                UTB(i_) = UTB(i_) + V * U(i, i_)
            Next i_
        Next i
        If SV(0#) > 0# Then
            Rep.TaskRCond = SV(M - 1#) / SV(0#)
            For i = 0# To M - 1# Step 1
                If SV(i) > Threshold * SV(0#) Then
                    SUTB(i) = UTB(i) / SV(i)
                Else
                    SUTB(i) = 0#
                End If
            Next i
        Else
            Rep.TaskRCond = 0#
            For i = 0# To M - 1# Step 1
                SUTB(i) = 0#
            Next i
        End If
        ReDim c(0 To M - 1)
        For i = 0# To M - 1# Step 1
            c(i) = 0#
        Next i
        For i = 0# To M - 1# Step 1
            V = SUTB(i)
            For i_ = 0# To M - 1# Step 1
                c(i_) = c(i_) + V * VT(i, i_)
            Next i_
        Next i
    End If
    
    '
    ' calculate errors
    '
    Rep.RMSError = 0#
    Rep.AvgError = 0#
    Rep.AvgRelError = 0#
    Rep.MaxError = 0#
    RelCnt = 0#
    For i = 0# To N - 1# Step 1
        V = 0#
        For i_ = 0# To M - 1# Step 1
            V = V + FMatrix(i, i_) * c(i_)
        Next i_
        Rep.RMSError = Rep.RMSError + Square(V - Y(i))
        Rep.AvgError = Rep.AvgError + Abs(V - Y(i))
        If Y(i) <> 0# Then
            Rep.AvgRelError = Rep.AvgRelError + Abs(V - Y(i)) / Abs(Y(i))
            RelCnt = RelCnt + 1#
        End If
        Rep.MaxError = MaxReal(Rep.MaxError, Abs(V - Y(i)))
    Next i
    Rep.RMSError = Sqr(Rep.RMSError / N)
    Rep.AvgError = Rep.AvgError / N
    If RelCnt <> 0# Then
        Rep.AvgRelError = Rep.AvgRelError / RelCnt
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub LSFitClearRequestFields(ByRef State As LSFitState)
    State.NeedF = False
    State.NeedFG = False
    State.NeedFGH = False
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2006-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Lagrange intepolant: generation of the model on the general grid.
'This function has O(N^2) complexity.
'
'INPUT PARAMETERS:
'    X   -   abscissas, array[0..N-1]
'    Y   -   function values, array[0..N-1]
'    N   -   number of points, N>=1
'
'OIYTPUT PARAMETERS
'    P   -   barycentric model which represents Lagrange interpolant
'            (see ratint unit info and BarycentricCalc() description for
'            more information).
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialBuild(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByRef p As BarycentricInterpolant)
    Dim j As Long
    Dim K As Long
    Dim w() As Double
    Dim B As Double
    Dim A As Double
    Dim V As Double
    Dim MX As Double
    Dim i_ As Long
    
    '
    ' calculate W[j]
    ' multi-pass algorithm is used to avoid overflow
    '
    ReDim w(0 To N - 1)
    A = X(0#)
    B = X(0#)
    For j = 0# To N - 1# Step 1
        w(j) = 1#
        A = MinReal(A, X(j))
        B = MaxReal(B, X(j))
    Next j
    For K = 0# To N - 1# Step 1
        
        '
        ' W[K] is used instead of 0.0 because
        ' cycle on J does not touch K-th element
        ' and we MUST get maximum from ALL elements
        '
        MX = Abs(w(K))
        For j = 0# To N - 1# Step 1
            If j <> K Then
                V = (B - A) / (X(j) - X(K))
                w(j) = w(j) * V
                MX = MaxReal(MX, Abs(w(j)))
            End If
        Next j
        If K Mod 5# = 0# Then
            
            '
            ' every 5-th run we renormalize W[]
            '
            V = 1# / MX
            For i_ = 0# To N - 1# Step 1
                w(i_) = V * w(i_)
            Next i_
        End If
    Next K
    Call BarycentricBuildXYW(X, Y, w, N, p)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Lagrange intepolant: generation of the model on equidistant grid.
'This function has O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    Y   -   function values at the nodes, array[0..N-1]
'    N   -   number of points, N>=1
'            for N=1 a constant model is constructed.
'
'OIYTPUT PARAMETERS
'    P   -   barycentric model which represents Lagrange interpolant
'            (see ratint unit info and BarycentricCalc() description for
'            more information).
'
'  -- ALGLIB --
'     Copyright 03.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialBuildEqDist(ByVal A As Double, _
         ByVal B As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByRef p As BarycentricInterpolant)
    Dim i As Long
    Dim w() As Double
    Dim X() As Double
    Dim V As Double
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        ReDim X(0 To 1# - 1)
        ReDim w(0 To 1# - 1)
        X(0#) = 0.5 * (B + A)
        w(0#) = 1#
        Call BarycentricBuildXYW(X, Y, w, 1#, p)
        Exit Sub
    End If
    
    '
    ' general case
    '
    ReDim X(0 To N - 1)
    ReDim w(0 To N - 1)
    V = 1#
    For i = 0# To N - 1# Step 1
        w(i) = V
        X(i) = A + (B - A) * i / (N - 1#)
        V = -(V * (N - 1# - i))
        V = V / (i + 1#)
    Next i
    Call BarycentricBuildXYW(X, Y, w, N, p)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Lagrange intepolant on Chebyshev grid (first kind).
'This function has O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    Y   -   function values at the nodes, array[0..N-1],
'            Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
'    N   -   number of points, N>=1
'            for N=1 a constant model is constructed.
'
'OIYTPUT PARAMETERS
'    P   -   barycentric model which represents Lagrange interpolant
'            (see ratint unit info and BarycentricCalc() description for
'            more information).
'
'  -- ALGLIB --
'     Copyright 03.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialBuildCheb1(ByVal A As Double, _
         ByVal B As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByRef p As BarycentricInterpolant)
    Dim i As Long
    Dim w() As Double
    Dim X() As Double
    Dim V As Double
    Dim T As Double
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        ReDim X(0 To 1# - 1)
        ReDim w(0 To 1# - 1)
        X(0#) = 0.5 * (B + A)
        w(0#) = 1#
        Call BarycentricBuildXYW(X, Y, w, 1#, p)
        Exit Sub
    End If
    
    '
    ' general case
    '
    ReDim X(0 To N - 1)
    ReDim w(0 To N - 1)
    V = 1#
    For i = 0# To N - 1# Step 1
        T = Tan(0.5 * Pi() * (2# * i + 1#) / (2# * N))
        w(i) = 2# * V * T / (1# + Square(T))
        X(i) = 0.5 * (B + A) + 0.5 * (B - A) * (1# - Square(T)) / (1# + Square(T))
        V = -V
    Next i
    Call BarycentricBuildXYW(X, Y, w, N, p)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Lagrange intepolant on Chebyshev grid (second kind).
'This function has O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    Y   -   function values at the nodes, array[0..N-1],
'            Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
'    N   -   number of points, N>=1
'            for N=1 a constant model is constructed.
'
'OIYTPUT PARAMETERS
'    P   -   barycentric model which represents Lagrange interpolant
'            (see ratint unit info and BarycentricCalc() description for
'            more information).
'
'  -- ALGLIB --
'     Copyright 03.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialBuildCheb2(ByVal A As Double, _
         ByVal B As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByRef p As BarycentricInterpolant)
    Dim i As Long
    Dim w() As Double
    Dim X() As Double
    Dim V As Double
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        ReDim X(0 To 1# - 1)
        ReDim w(0 To 1# - 1)
        X(0#) = 0.5 * (B + A)
        w(0#) = 1#
        Call BarycentricBuildXYW(X, Y, w, 1#, p)
        Exit Sub
    End If
    
    '
    ' general case
    '
    ReDim X(0 To N - 1)
    ReDim w(0 To N - 1)
    V = 1#
    For i = 0# To N - 1# Step 1
        If i = 0# Or i = N - 1# Then
            w(i) = V * 0.5
        Else
            w(i) = V
        End If
        X(i) = 0.5 * (B + A) + 0.5 * (B - A) * Cos(Pi() * i / (N - 1#))
        V = -V
    Next i
    Call BarycentricBuildXYW(X, Y, w, N, p)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast equidistant polynomial interpolation function with O(N) complexity
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    F   -   function values, array[0..N-1]
'    N   -   number of points on equidistant grid, N>=1
'            for N=1 a constant model is constructed.
'    T   -   position where P(x) is calculated
'
'RESULT
'    value of the Lagrange interpolant at T
'
'IMPORTANT
'    this function provides fast interface which is not overflow-safe
'    nor it is very precise.
'    the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
'    subroutines unless you are pretty sure that your data will not result
'    in overflow.
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PolynomialCalcEqDist(ByVal A As Double, _
         ByVal B As Double, _
         ByRef F() As Double, _
         ByVal N As Long, _
         ByVal T As Double) As Double
    Dim Result As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim V As Double
    Dim Threshold As Double
    Dim S As Double
    Dim H As Double
    Dim i As Long
    Dim j As Long
    Dim w As Double
    Dim X As Double
    Threshold = Sqr(MinRealNumber)
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        Result = F(0#)
        PolynomialCalcEqDist = Result
        Exit Function
    End If
    
    '
    ' First, decide: should we use "safe" formula (guarded
    ' against overflow) or fast one?
    '
    j = 0#
    S = T - A
    For i = 1# To N - 1# Step 1
        X = A + i / (N - 1#) * (B - A)
        If Abs(T - X) < Abs(S) Then
            S = T - X
            j = i
        End If
    Next i
    If S = 0# Then
        Result = F(j)
        PolynomialCalcEqDist = Result
        Exit Function
    End If
    If Abs(S) > Threshold Then
        
        '
        ' use fast formula
        '
        j = -1#
        S = 1#
    End If
    
    '
    ' Calculate using safe or fast barycentric formula
    '
    S1 = 0#
    S2 = 0#
    w = 1#
    H = (B - A) / (N - 1#)
    For i = 0# To N - 1# Step 1
        If i <> j Then
            V = S * w / (T - (A + i * H))
            S1 = S1 + V * F(i)
            S2 = S2 + V
        Else
            V = w
            S1 = S1 + V * F(i)
            S2 = S2 + V
        End If
        w = -(w * (N - 1# - i))
        w = w / (i + 1#)
    Next i
    Result = S1 / S2
    PolynomialCalcEqDist = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast polynomial interpolation function on Chebyshev points (first kind)
'with O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    F   -   function values, array[0..N-1]
'    N   -   number of points on Chebyshev grid (first kind),
'            X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
'            for N=1 a constant model is constructed.
'    T   -   position where P(x) is calculated
'
'RESULT
'    value of the Lagrange interpolant at T
'
'IMPORTANT
'    this function provides fast interface which is not overflow-safe
'    nor it is very precise.
'    the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
'    subroutines unless you are pretty sure that your data will not result
'    in overflow.
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PolynomialCalcCheb1(ByVal A As Double, _
         ByVal B As Double, _
         ByRef F() As Double, _
         ByVal N As Long, _
         ByVal T As Double) As Double
    Dim Result As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim V As Double
    Dim Threshold As Double
    Dim S As Double
    Dim i As Long
    Dim j As Long
    Dim a0 As Double
    Dim Delta As Double
    Dim alpha As Double
    Dim beta As Double
    Dim CA As Double
    Dim SA As Double
    Dim TempC As Double
    Dim TempS As Double
    Dim X As Double
    Dim w As Double
    Dim P1 As Double
    Threshold = Sqr(MinRealNumber)
    T = (T - 0.5 * (A + B)) / (0.5 * (B - A))
    
    '
    ' Fast exit
    '
    If N = 1# Then
        Result = F(0#)
        PolynomialCalcCheb1 = Result
        Exit Function
    End If
    
    '
    ' Prepare information for the recurrence formula
    ' used to calculate sin(pi*(2j+1)/(2n+2)) and
    ' cos(pi*(2j+1)/(2n+2)):
    '
    ' A0    = pi/(2n+2)
    ' Delta = pi/(n+1)
    ' Alpha = 2 sin^2 (Delta/2)
    ' Beta  = sin(Delta)
    '
    ' so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
    ' Then we use
    '
    ' sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
    ' cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
    '
    ' to repeatedly calculate sin(..) and cos(..).
    '
    a0 = Pi() / (2# * (N - 1#) + 2#)
    Delta = 2# * Pi() / (2# * (N - 1#) + 2#)
    alpha = 2# * Square(Sin(Delta / 2#))
    beta = Sin(Delta)
    
    '
    ' First, decide: should we use "safe" formula (guarded
    ' against overflow) or fast one?
    '
    CA = Cos(a0)
    SA = Sin(a0)
    j = 0#
    X = CA
    S = T - X
    For i = 1# To N - 1# Step 1
        
        '
        ' Next X[i]
        '
        TempS = SA - (alpha * SA - beta * CA)
        TempC = CA - (alpha * CA + beta * SA)
        SA = TempS
        CA = TempC
        X = CA
        
        '
        ' Use X[i]
        '
        If Abs(T - X) < Abs(S) Then
            S = T - X
            j = i
        End If
    Next i
    If S = 0# Then
        Result = F(j)
        PolynomialCalcCheb1 = Result
        Exit Function
    End If
    If Abs(S) > Threshold Then
        
        '
        ' use fast formula
        '
        j = -1#
        S = 1#
    End If
    
    '
    ' Calculate using safe or fast barycentric formula
    '
    S1 = 0#
    S2 = 0#
    CA = Cos(a0)
    SA = Sin(a0)
    P1 = 1#
    For i = 0# To N - 1# Step 1
        
        '
        ' Calculate X[i], W[i]
        '
        X = CA
        w = P1 * SA
        
        '
        ' Proceed
        '
        If i <> j Then
            V = S * w / (T - X)
            S1 = S1 + V * F(i)
            S2 = S2 + V
        Else
            V = w
            S1 = S1 + V * F(i)
            S2 = S2 + V
        End If
        
        '
        ' Next CA, SA, P1
        '
        TempS = SA - (alpha * SA - beta * CA)
        TempC = CA - (alpha * CA + beta * SA)
        SA = TempS
        CA = TempC
        P1 = -P1
    Next i
    Result = S1 / S2
    PolynomialCalcCheb1 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Fast polynomial interpolation function on Chebyshev points (second kind)
'with O(N) complexity.
'
'INPUT PARAMETERS:
'    A   -   left boundary of [A,B]
'    B   -   right boundary of [A,B]
'    F   -   function values, array[0..N-1]
'    N   -   number of points on Chebyshev grid (second kind),
'            X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
'            for N=1 a constant model is constructed.
'    T   -   position where P(x) is calculated
'
'RESULT
'    value of the Lagrange interpolant at T
'
'IMPORTANT
'    this function provides fast interface which is not overflow-safe
'    nor it is very precise.
'    the best option is to use PolIntBuildCheb2()/BarycentricCalc()
'    subroutines unless you are pretty sure that your data will not result
'    in overflow.
'
'  -- ALGLIB --
'     Copyright 02.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PolynomialCalcCheb2(ByVal A As Double, _
         ByVal B As Double, _
         ByRef F() As Double, _
         ByVal N As Long, _
         ByVal T As Double) As Double
    Dim Result As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim V As Double
    Dim Threshold As Double
    Dim S As Double
    Dim i As Long
    Dim j As Long
    Dim a0 As Double
    Dim Delta As Double
    Dim alpha As Double
    Dim beta As Double
    Dim CA As Double
    Dim SA As Double
    Dim TempC As Double
    Dim TempS As Double
    Dim X As Double
    Dim w As Double
    Dim P1 As Double
    Threshold = Sqr(MinRealNumber)
    T = (T - 0.5 * (A + B)) / (0.5 * (B - A))
    
    '
    ' Fast exit
    '
    If N = 1# Then
        Result = F(0#)
        PolynomialCalcCheb2 = Result
        Exit Function
    End If
    
    '
    ' Prepare information for the recurrence formula
    ' used to calculate sin(pi*i/n) and
    ' cos(pi*i/n):
    '
    ' A0    = 0
    ' Delta = pi/n
    ' Alpha = 2 sin^2 (Delta/2)
    ' Beta  = sin(Delta)
    '
    ' so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
    ' Then we use
    '
    ' sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
    ' cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
    '
    ' to repeatedly calculate sin(..) and cos(..).
    '
    a0 = 0#
    Delta = Pi() / (N - 1#)
    alpha = 2# * Square(Sin(Delta / 2#))
    beta = Sin(Delta)
    
    '
    ' First, decide: should we use "safe" formula (guarded
    ' against overflow) or fast one?
    '
    CA = Cos(a0)
    SA = Sin(a0)
    j = 0#
    X = CA
    S = T - X
    For i = 1# To N - 1# Step 1
        
        '
        ' Next X[i]
        '
        TempS = SA - (alpha * SA - beta * CA)
        TempC = CA - (alpha * CA + beta * SA)
        SA = TempS
        CA = TempC
        X = CA
        
        '
        ' Use X[i]
        '
        If Abs(T - X) < Abs(S) Then
            S = T - X
            j = i
        End If
    Next i
    If S = 0# Then
        Result = F(j)
        PolynomialCalcCheb2 = Result
        Exit Function
    End If
    If Abs(S) > Threshold Then
        
        '
        ' use fast formula
        '
        j = -1#
        S = 1#
    End If
    
    '
    ' Calculate using safe or fast barycentric formula
    '
    S1 = 0#
    S2 = 0#
    CA = Cos(a0)
    SA = Sin(a0)
    P1 = 1#
    For i = 0# To N - 1# Step 1
        
        '
        ' Calculate X[i], W[i]
        '
        X = CA
        If i = 0# Or i = N - 1# Then
            w = 0.5 * P1
        Else
            w = 1# * P1
        End If
        
        '
        ' Proceed
        '
        If i <> j Then
            V = S * w / (T - X)
            S1 = S1 + V * F(i)
            S2 = S2 + V
        Else
            V = w
            S1 = S1 + V * F(i)
            S2 = S2 + V
        End If
        
        '
        ' Next CA, SA, P1
        '
        TempS = SA - (alpha * SA - beta * CA)
        TempC = CA - (alpha * CA + beta * SA)
        SA = TempS
        CA = TempC
        P1 = -P1
    Next i
    Result = S1 / S2
    PolynomialCalcCheb2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Least squares fitting by polynomial.
'
'This subroutine is "lightweight" alternative for more complex and feature-
'rich PolynomialFitWC().  See  PolynomialFitWC() for more information about
'subroutine parameters (we don't duplicate it here because of length)
'
'  -- ALGLIB PROJECT --
'     Copyright 12.10.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialFit(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef p As BarycentricInterpolant, _
         ByRef Rep As PolynomialFitReport)
    Dim i As Long
    Dim w() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim DC() As Long
    If N > 0# Then
        ReDim w(0 To N - 1)
        For i = 0# To N - 1# Step 1
            w(i) = 1#
        Next i
    End If
    Call PolynomialFitWC(X, Y, w, N, XC, YC, DC, 0#, M, Info, p, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted  fitting  by  Chebyshev  polynomial  in  barycentric  form,  with
'constraints on function values or first derivatives.
'
'Small regularizing term is used when solving constrained tasks (to improve
'stability).
'
'Task is linear, so linear least squares solver is used. Complexity of this
'computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'SEE ALSO:
'    PolynomialFit()
'
'INPUT PARAMETERS:
'    X   -   points, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    W   -   weights, array[0..N-1]
'            Each summand in square  sum  of  approximation deviations from
'            given  values  is  multiplied  by  the square of corresponding
'            weight. Fill it by 1's if you don't  want  to  solve  weighted
'            task.
'    N   -   number of points, N>0.
'    XC  -   points where polynomial values/derivatives are constrained,
'            array[0..K-1].
'    YC  -   values of constraints, array[0..K-1]
'    DC  -   array[0..K-1], types of constraints:
'            * DC[i]=0   means that P(XC[i])=YC[i]
'            * DC[i]=1   means that P'(XC[i])=YC[i]
'            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'    K   -   number of constraints, 0<=K<M.
'            K=0 means no constraints (XC/YC/DC are not used in such cases)
'    M   -   number of basis functions (= polynomial_degree + 1), M>=1
'
'OUTPUT PARAMETERS:
'    Info-   same format as in LSFitLinearW() subroutine:
'            * Info>0    task is solved
'            * Info<=0   an error occured:
'                        -4 means inconvergence of internal SVD
'                        -3 means inconsistent constraints
'                        -1 means another errors in parameters passed
'                           (N<=0, for example)
'    P   -   interpolant in barycentric form.
'    Rep -   report, same format as in LSFitLinearW() subroutine.
'            Following fields are set:
'            * RMSError      rms error on the (X,Y).
'            * AvgError      average error on the (X,Y).
'            * AvgRelError   average relative error on the non-zero Y
'            * MaxError      maximum error
'                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'Setting constraints can lead  to undesired  results,  like ill-conditioned
'behavior, or inconsistency being detected. From the other side,  it allows
'us to improve quality of the fit. Here we summarize  our  experience  with
'constrained regression splines:
'* even simple constraints can be inconsistent, see  Wikipedia  article  on
'  this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
'* the  greater  is  M (given  fixed  constraints),  the  more chances that
'  constraints will be consistent
'* in the general case, consistency of constraints is NOT GUARANTEED.
'* in the one special cases, however, we can  guarantee  consistency.  This
'  case  is:  M>1  and constraints on the function values (NOT DERIVATIVES)
'
'Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
'can't solve your task without them. Anything beyond  special  cases  given
'above is not guaranteed and may result in inconsistency.
'
'  -- ALGLIB PROJECT --
'     Copyright 10.12.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PolynomialFitWC(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC_() As Double, _
         ByRef YC_() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef p As BarycentricInterpolant, _
         ByRef Rep As PolynomialFitReport)
    Dim X() As Double
    Dim Y() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim XA As Double
    Dim XB As Double
    Dim SA As Double
    Dim SB As Double
    Dim XOriginal() As Double
    Dim YOriginal() As Double
    Dim Y2() As Double
    Dim W2() As Double
    Dim Tmp() As Double
    Dim Tmp2() As Double
    Dim TmpDiff() As Double
    Dim BX() As Double
    Dim BY() As Double
    Dim BW() As Double
    Dim FMatrix() As Double
    Dim CMatrix() As Double
    Dim i As Long
    Dim j As Long
    Dim MX As Double
    Dim Decay As Double
    Dim U As Double
    Dim V As Double
    Dim S As Double
    Dim RelCnt As Long
    Dim LRep As LSFitReport
    Dim i_ As Long
    X = X_
    Y = y_
    XC = XC_
    YC = YC_
    If M < 1# Or N < 1# Or K < 0# Or K >= M Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To K - 1# Step 1
        Info = 0#
        If DC(i) < 0# Then
            Info = -1#
        End If
        If DC(i) > 1# Then
            Info = -1#
        End If
        If Info < 0# Then
            Exit Sub
        End If
    Next i
    
    '
    ' weight decay for correct handling of task which becomes
    ' degenerate after constraints are applied
    '
    Decay = 10000# * MachineEpsilon
    
    '
    ' Scale X, Y, XC, YC
    '
    Call LSFitScaleXY(X, Y, N, XC, YC, DC, K, XA, XB, SA, SB, XOriginal, YOriginal)
    
    '
    ' allocate space, initialize/fill:
    ' * FMatrix-   values of basis functions at X[]
    ' * CMatrix-   values (derivatives) of basis functions at XC[]
    ' * fill constraints matrix
    ' * fill first N rows of design matrix with values
    ' * fill next M rows of design matrix with regularizing term
    ' * append M zeros to Y
    ' * append M elements, mean(abs(W)) each, to W
    '
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    ReDim Tmp(0 To M - 1)
    ReDim TmpDiff(0 To M - 1)
    ReDim FMatrix(0 To N + M - 1, 0 To M - 1)
    If K > 0# Then
        ReDim CMatrix(0 To K - 1, 0 To M + 1# - 1)
    End If
    
    '
    ' Fill design matrix, Y2, W2:
    ' * first N rows with basis functions for original points
    ' * next M rows with decay terms
    '
    For i = 0# To N - 1# Step 1
        
        '
        ' prepare Ith row
        ' use Tmp for calculations to avoid multidimensional arrays overhead
        '
        For j = 0# To M - 1# Step 1
            If j = 0# Then
                Tmp(j) = 1#
            Else
                If j = 1# Then
                    Tmp(j) = X(i)
                Else
                    Tmp(j) = 2# * X(i) * Tmp(j - 1#) - Tmp(j - 2#)
                End If
            End If
        Next j
        For i_ = 0# To M - 1# Step 1
            FMatrix(i, i_) = Tmp(i_)
        Next i_
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To M - 1# Step 1
            If i = j Then
                FMatrix(N + i, j) = Decay
            Else
                FMatrix(N + i, j) = 0#
            End If
        Next j
    Next i
    For i_ = 0# To N - 1# Step 1
        Y2(i_) = Y(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        W2(i_) = w(i_)
    Next i_
    MX = 0#
    For i = 0# To N - 1# Step 1
        MX = MX + Abs(w(i))
    Next i
    MX = MX / N
    For i = 0# To M - 1# Step 1
        Y2(N + i) = 0#
        W2(N + i) = MX
    Next i
    
    '
    ' fill constraints matrix
    '
    For i = 0# To K - 1# Step 1
        
        '
        ' prepare Ith row
        ' use Tmp for basis function values,
        ' TmpDiff for basos function derivatives
        '
        For j = 0# To M - 1# Step 1
            If j = 0# Then
                Tmp(j) = 1#
                TmpDiff(j) = 0#
            Else
                If j = 1# Then
                    Tmp(j) = XC(i)
                    TmpDiff(j) = 1#
                Else
                    Tmp(j) = 2# * XC(i) * Tmp(j - 1#) - Tmp(j - 2#)
                    TmpDiff(j) = 2# * (Tmp(j - 1#) + XC(i) * TmpDiff(j - 1#)) - TmpDiff(j - 2#)
                End If
            End If
        Next j
        If DC(i) = 0# Then
            For i_ = 0# To M - 1# Step 1
                CMatrix(i, i_) = Tmp(i_)
            Next i_
        End If
        If DC(i) = 1# Then
            For i_ = 0# To M - 1# Step 1
                CMatrix(i, i_) = TmpDiff(i_)
            Next i_
        End If
        CMatrix(i, M) = YC(i)
    Next i
    
    '
    ' Solve constrained task
    '
    If K > 0# Then
        
        '
        ' solve using regularization
        '
        Call LSFitLinearWC(Y2, W2, FMatrix, CMatrix, N + M, M, K, Info, Tmp, LRep)
    Else
        
        '
        ' no constraints, no regularization needed
        '
        Call LSFitLinearWC(Y, w, FMatrix, CMatrix, N, M, 0#, Info, Tmp, LRep)
    End If
    If Info < 0# Then
        Exit Sub
    End If
    
    '
    ' Generate barycentric model and scale it
    ' * BX, BY store barycentric model nodes
    ' * FMatrix is reused (remember - it is at least MxM, what we need)
    '
    ' Model intialization is done in O(M^2). In principle, it can be
    ' done in O(M*log(M)), but before it we solved task with O(N*M^2)
    ' complexity, so it is only a small amount of total time spent.
    '
    ReDim BX(0 To M - 1)
    ReDim BY(0 To M - 1)
    ReDim BW(0 To M - 1)
    ReDim Tmp2(0 To M - 1)
    S = 1#
    For i = 0# To M - 1# Step 1
        If M <> 1# Then
            U = Cos(Pi() * i / (M - 1#))
        Else
            U = 0#
        End If
        V = 0#
        For j = 0# To M - 1# Step 1
            If j = 0# Then
                Tmp2(j) = 1#
            Else
                If j = 1# Then
                    Tmp2(j) = U
                Else
                    Tmp2(j) = 2# * U * Tmp2(j - 1#) - Tmp2(j - 2#)
                End If
            End If
            V = V + Tmp(j) * Tmp2(j)
        Next j
        BX(i) = U
        BY(i) = V
        BW(i) = S
        If i = 0# Or i = M - 1# Then
            BW(i) = 0.5 * BW(i)
        End If
        S = -S
    Next i
    Call BarycentricBuildXYW(BX, BY, BW, M, p)
    Call BarycentricLinTransX(p, 2# / (XB - XA), -((XA + XB) / (XB - XA)))
    Call BarycentricLinTransY(p, SB - SA, SA)
    
    '
    ' Scale absolute errors obtained from LSFitLinearW.
    ' Relative error should be calculated separately
    ' (because of shifting/scaling of the task)
    '
    Rep.TaskRCond = LRep.TaskRCond
    Rep.RMSError = LRep.RMSError * (SB - SA)
    Rep.AvgError = LRep.AvgError * (SB - SA)
    Rep.MaxError = LRep.MaxError * (SB - SA)
    Rep.AvgRelError = 0#
    RelCnt = 0#
    For i = 0# To N - 1# Step 1
        If YOriginal(i) <> 0# Then
            Rep.AvgRelError = Rep.AvgRelError + Abs(BarycentricCalc(p, XOriginal(i)) - YOriginal(i)) / Abs(YOriginal(i))
            RelCnt = RelCnt + 1#
        End If
    Next i
    If RelCnt <> 0# Then
        Rep.AvgRelError = Rep.AvgRelError / RelCnt
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rational interpolation using barycentric formula
'
'F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
'
'Input parameters:
'    B   -   barycentric interpolant built with one of model building
'            subroutines.
'    T   -   interpolation point
'
'Result:
'    barycentric interpolant F(t)
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function BarycentricCalc(ByRef B As BarycentricInterpolant, _
         ByVal T As Double) As Double
    Dim Result As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim S As Double
    Dim V As Double
    Dim i As Long
    '
    ' special case: N=1
    '
    If B.N = 1# Then
        Result = B.SY * B.Y(0#)
        BarycentricCalc = Result
        Exit Function
    End If
    '
    ' Here we assume that task is normalized, i.e.:
    ' 1. abs(Y[i])<=1
    ' 2. abs(W[i])<=1
    ' 3. X[] is ordered
    '
    S = Abs(T - B.X(0#))
    For i = 0# To B.N - 1# Step 1
        V = B.X(i)
        If V = T Then
            Result = B.SY * B.Y(i)
            BarycentricCalc = Result
            Exit Function
        End If
        V = Abs(T - V)
        If V < S Then
            S = V
        End If
    Next i
    S1 = 0#
    S2 = 0#
    For i = 0# To B.N - 1# Step 1
        V = S / (T - B.X(i))
        V = V * B.w(i)
        S1 = S1 + V * B.Y(i)
        S2 = S2 + V
    Next i
    Result = B.SY * S1 / S2
    BarycentricCalc = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Differentiation of barycentric interpolant: first derivative.
'
'Algorithm used in this subroutine is very robust and should not fail until
'provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
'or greater will overflow).
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant built with one of model building
'            subroutines.
'    T   -   interpolation point
'
'OUTPUT PARAMETERS:
'    F   -   barycentric interpolant at T
'    DF  -   first derivative
'
'NOTE
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricDiff1(ByRef B As BarycentricInterpolant, _
         ByVal T As Double, _
         ByRef F As Double, _
         ByRef DF As Double)
    Dim V As Double
    Dim VV As Double
    Dim i As Long
    Dim K As Long
    Dim N0 As Double
    Dim N1 As Double
    Dim D0 As Double
    Dim d1 As Double
    Dim S0 As Double
    Dim S1 As Double
    Dim XK As Double
    Dim XI As Double
    Dim XMin As Double
    Dim XMAX As Double
    Dim XScale1 As Double
    Dim XOffs1 As Double
    Dim XScale2 As Double
    Dim XOffs2 As Double
    Dim XPrev As Double
    '
    ' special case: N=1
    '
    If B.N = 1# Then
        F = B.SY * B.Y(0#)
        DF = 0#
        Exit Sub
    End If
    If B.SY = 0# Then
        F = 0#
        DF = 0#
        Exit Sub
    End If
    '
    ' We assume than N>1 and B.SY>0. Find:
    ' 1. pivot point (X[i] closest to T)
    ' 2. width of interval containing X[i]
    '
    V = Abs(B.X(0#) - T)
    K = 0#
    XMin = B.X(0#)
    XMAX = B.X(0#)
    For i = 1# To B.N - 1# Step 1
        VV = B.X(i)
        If Abs(VV - T) < V Then
            V = Abs(VV - T)
            K = i
        End If
        XMin = MinReal(XMin, VV)
        XMAX = MaxReal(XMAX, VV)
    Next i
    '
    ' pivot point found, calculate dNumerator and dDenominator
    '
    XScale1 = 1# / (XMAX - XMin)
    XOffs1 = -(XMin / (XMAX - XMin)) + 1#
    XScale2 = 2#
    XOffs2 = -3#
    T = T * XScale1 + XOffs1
    T = T * XScale2 + XOffs2
    XK = B.X(K)
    XK = XK * XScale1 + XOffs1
    XK = XK * XScale2 + XOffs2
    V = T - XK
    N0 = 0#
    N1 = 0#
    D0 = 0#
    d1 = 0#
    XPrev = -2#
    For i = 0# To B.N - 1# Step 1
        XI = B.X(i)
        XI = XI * XScale1 + XOffs1
        XI = XI * XScale2 + XOffs2
        XPrev = XI
        If i <> K Then
            VV = Square(T - XI)
            S0 = (T - XK) / (T - XI)
            S1 = (XK - XI) / VV
        Else
            S0 = 1#
            S1 = 0#
        End If
        VV = B.w(i) * B.Y(i)
        N0 = N0 + S0 * VV
        N1 = N1 + S1 * VV
        VV = B.w(i)
        D0 = D0 + S0 * VV
        d1 = d1 + S1 * VV
    Next i
    F = B.SY * N0 / D0
    DF = (N1 * D0 - N0 * d1) / Square(D0)
    If DF <> 0# Then
        DF = Sgn(DF) * Exp(log(Abs(DF)) + log(B.SY) + log(XScale1) + log(XScale2))
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Differentiation of barycentric interpolant: first/second derivatives.
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant built with one of model building
'            subroutines.
'    T   -   interpolation point
'
'OUTPUT PARAMETERS:
'    F   -   barycentric interpolant at T
'    DF  -   first derivative
'    D2F -   second derivative
'
'NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
'whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
'BarycentricDiff1() subroutine in such cases.
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricDiff2(ByRef B As BarycentricInterpolant, _
         ByVal T As Double, _
         ByRef F As Double, _
         ByRef DF As Double, _
         ByRef D2F As Double)
    Dim V As Double
    Dim VV As Double
    Dim i As Long
    Dim K As Long
    Dim N0 As Double
    Dim N1 As Double
    Dim N2 As Double
    Dim D0 As Double
    Dim d1 As Double
    Dim D2 As Double
    Dim S0 As Double
    Dim S1 As Double
    Dim S2 As Double
    Dim XK As Double
    Dim XI As Double
    F = 0#
    DF = 0#
    D2F = 0#
    '
    ' special case: N=1
    '
    If B.N = 1# Then
        F = B.SY * B.Y(0#)
        DF = 0#
        D2F = 0#
        Exit Sub
    End If
    If B.SY = 0# Then
        F = 0#
        DF = 0#
        D2F = 0#
        Exit Sub
    End If
    '
    ' We assume than N>1 and B.SY>0. Find:
    ' 1. pivot point (X[i] closest to T)
    ' 2. width of interval containing X[i]
    '
    V = Abs(B.X(0#) - T)
    K = 0#
    For i = 1# To B.N - 1# Step 1
        VV = B.X(i)
        If Abs(VV - T) < V Then
            V = Abs(VV - T)
            K = i
        End If
    Next i
    '
    ' pivot point found, calculate dNumerator and dDenominator
    '
    XK = B.X(K)
    V = T - XK
    N0 = 0#
    N1 = 0#
    N2 = 0#
    D0 = 0#
    d1 = 0#
    D2 = 0#
    For i = 0# To B.N - 1# Step 1
        If i <> K Then
            XI = B.X(i)
            VV = Square(T - XI)
            S0 = (T - XK) / (T - XI)
            S1 = (XK - XI) / VV
            S2 = -(2# * (XK - XI) / (VV * (T - XI)))
        Else
            S0 = 1#
            S1 = 0#
            S2 = 0#
        End If
        VV = B.w(i) * B.Y(i)
        N0 = N0 + S0 * VV
        N1 = N1 + S1 * VV
        N2 = N2 + S2 * VV
        VV = B.w(i)
        D0 = D0 + S0 * VV
        d1 = d1 + S1 * VV
        D2 = D2 + S2 * VV
    Next i
    F = B.SY * N0 / D0
    DF = B.SY * (N1 * D0 - N0 * d1) / Square(D0)
    D2F = B.SY * ((N2 * D0 - N0 * D2) * Square(D0) - (N1 * D0 - N0 * d1) * 2# * D0 * d1) / Square(Square(D0))
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the argument.
'
'INPUT PARAMETERS:
'    B       -   rational interpolant in barycentric form
'    CA, CB  -   transformation coefficients: x = CA*t + CB
'
'OUTPUT PARAMETERS:
'    B       -   transformed interpolant with X replaced by T
'
'  -- ALGLIB PROJECT --
'     Copyright 19.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricLinTransX(ByRef B As BarycentricInterpolant, _
         ByVal CA As Double, _
         ByVal CB As Double)
    Dim i As Long
    Dim j As Long
    Dim V As Double
    '
    ' special case, replace by constant F(CB)
    '
    If CA = 0# Then
        B.SY = BarycentricCalc(B, CB)
        V = 1#
        For i = 0# To B.N - 1# Step 1
            B.Y(i) = 1#
            B.w(i) = V
            V = -V
        Next i
        Exit Sub
    End If
    '
    ' general case: CA<>0
    '
    For i = 0# To B.N - 1# Step 1
        B.X(i) = (B.X(i) - CB) / CA
    Next i
    If CA < 0# Then
        For i = 0# To B.N - 1# Step 1
            If i < B.N - 1# - i Then
                j = B.N - 1# - i
                V = B.X(i)
                B.X(i) = B.X(j)
                B.X(j) = V
                V = B.Y(i)
                B.Y(i) = B.Y(j)
                B.Y(j) = V
                V = B.w(i)
                B.w(i) = B.w(j)
                B.w(j) = V
            Else
                Exit For
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This  subroutine   performs   linear  transformation  of  the  barycentric
'interpolant.
'
'INPUT PARAMETERS:
'    B       -   rational interpolant in barycentric form
'    CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB
'
'OUTPUT PARAMETERS:
'    B       -   transformed interpolant
'
'  -- ALGLIB PROJECT --
'     Copyright 19.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricLinTransY(ByRef B As BarycentricInterpolant, _
         ByVal CA As Double, _
         ByVal CB As Double)
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    For i = 0# To B.N - 1# Step 1
        B.Y(i) = CA * B.SY * B.Y(i) + CB
    Next i
    B.SY = 0#
    For i = 0# To B.N - 1# Step 1
        B.SY = MaxReal(B.SY, Abs(B.Y(i)))
    Next i
    If B.SY > 0# Then
        V = 1# / B.SY
        For i_ = 0# To B.N - 1# Step 1
            B.Y(i_) = V * B.Y(i_)
        Next i_
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Extracts X/Y/W arrays from rational interpolant
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant
'
'OUTPUT PARAMETERS:
'    N   -   nodes count, N>0
'    X   -   interpolation nodes, array[0..N-1]
'    F   -   function values, array[0..N-1]
'    W   -   barycentric weights, array[0..N-1]
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricUnpack(ByRef B As BarycentricInterpolant, _
         ByRef N As Long, _
         ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef w() As Double)
    Dim V As Double
    Dim i_ As Long
    N = B.N
    ReDim X(0 To N - 1)
    ReDim Y(0 To N - 1)
    ReDim w(0 To N - 1)
    V = B.SY
    For i_ = 0# To N - 1# Step 1
        X(i_) = B.X(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        Y(i_) = V * B.Y(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        w(i_) = B.w(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Serialization of the barycentric interpolant
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant
'
'OUTPUT PARAMETERS:
'    RA      -   array of real numbers which contains interpolant,
'                array[0..RLen-1]
'    RLen    -   RA lenght
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricSerialize(ByRef B As BarycentricInterpolant, _
         ByRef RA() As Double, _
         ByRef RALen As Long)
    Dim i_ As Long
    Dim i1_ As Long
    RALen = 2# + 2# + 3# * B.N
    ReDim RA(0 To RALen - 1)
    RA(0#) = RALen
    RA(1#) = BRCVNum
    RA(2#) = B.N
    RA(3#) = B.SY
    i1_ = (0#) - (4#)
    For i_ = 4# To 4# + B.N - 1# Step 1
        RA(i_) = B.X(i_ + i1_)
    Next i_
    i1_ = (0#) - (4# + B.N)
    For i_ = 4# + B.N To 4# + 2# * B.N - 1# Step 1
        RA(i_) = B.Y(i_ + i1_)
    Next i_
    i1_ = (0#) - (4# + 2# * B.N)
    For i_ = 4# + 2# * B.N To 4# + 3# * B.N - 1# Step 1
        RA(i_) = B.w(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unserialization of the barycentric interpolant
'
'INPUT PARAMETERS:
'    RA  -   array of real numbers which contains interpolant,
'
'OUTPUT PARAMETERS:
'    B   -   barycentric interpolant
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricUnserialize(ByRef RA() As Double, _
         ByRef B As BarycentricInterpolant)
    Dim i_ As Long
    Dim i1_ As Long
    B.N = Round(RA(2#))
    B.SY = RA(3#)
    ReDim B.X(0 To B.N - 1)
    ReDim B.Y(0 To B.N - 1)
    ReDim B.w(0 To B.N - 1)
    i1_ = (4#) - (0#)
    For i_ = 0# To B.N - 1# Step 1
        B.X(i_) = RA(i_ + i1_)
    Next i_
    i1_ = (4# + B.N) - (0#)
    For i_ = 0# To B.N - 1# Step 1
        B.Y(i_) = RA(i_ + i1_)
    Next i_
    i1_ = (4# + 2# * B.N) - (0#)
    For i_ = 0# To B.N - 1# Step 1
        B.w(i_) = RA(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copying of the barycentric interpolant
'
'INPUT PARAMETERS:
'    B   -   barycentric interpolant
'
'OUTPUT PARAMETERS:
'    B2  -   copy(B1)
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricCopy(ByRef B As BarycentricInterpolant, _
         ByRef b2 As BarycentricInterpolant)
    Dim i_ As Long
    b2.N = B.N
    b2.SY = B.SY
    ReDim b2.X(0 To b2.N - 1)
    ReDim b2.Y(0 To b2.N - 1)
    ReDim b2.w(0 To b2.N - 1)
    For i_ = 0# To b2.N - 1# Step 1
        b2.X(i_) = B.X(i_)
    Next i_
    For i_ = 0# To b2.N - 1# Step 1
        b2.Y(i_) = B.Y(i_)
    Next i_
    For i_ = 0# To b2.N - 1# Step 1
        b2.w(i_) = B.w(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rational interpolant from X/Y/W arrays
'
'F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
'
'INPUT PARAMETERS:
'    X   -   interpolation nodes, array[0..N-1]
'    F   -   function values, array[0..N-1]
'    W   -   barycentric weights, array[0..N-1]
'    N   -   nodes count, N>0
'
'OUTPUT PARAMETERS:
'    B   -   barycentric interpolant built from (X, Y, W)
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricBuildXYW(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef B As BarycentricInterpolant)
    Dim i_ As Long
    '
    ' fill X/Y/W
    '
    ReDim B.X(0 To N - 1)
    ReDim B.Y(0 To N - 1)
    ReDim B.w(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        B.X(i_) = X(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        B.Y(i_) = Y(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        B.w(i_) = w(i_)
    Next i_
    B.N = N
    '
    ' Normalize
    '
    Call BarycentricNormalize(B)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rational interpolant without poles
'
'The subroutine constructs the rational interpolating function without real
'poles  (see  'Barycentric rational interpolation with no  poles  and  high
'rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
'information on this subject).
'
'Input parameters:
'    X   -   interpolation nodes, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    N   -   number of nodes, N>0.
'    D   -   order of the interpolation scheme, 0 <= D <= N-1.
'            D<0 will cause an error.
'            D>=N it will be replaced with D=N-1.
'            if you don't know what D to choose, use small value about 3-5.
'
'Output parameters:
'    B   -   barycentric interpolant.
'
'Note:
'    this algorithm always succeeds and calculates the weights  with  close
'    to machine precision.
'
'  -- ALGLIB PROJECT --
'     Copyright 17.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricBuildFloaterHormann(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByVal d As Long, _
         ByRef B As BarycentricInterpolant)
    Dim S0 As Double
    Dim S As Double
    Dim V As Double
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim Perm() As Long
    Dim WTemp() As Double
    Dim i_ As Long
    '
    ' Prepare
    '
    If d > N - 1# Then
        d = N - 1#
    End If
    B.N = N
    '
    ' special case: N=1
    '
    If N = 1# Then
        ReDim B.X(0 To N - 1)
        ReDim B.Y(0 To N - 1)
        ReDim B.w(0 To N - 1)
        B.X(0#) = X(0#)
        B.Y(0#) = Y(0#)
        B.w(0#) = 1#
        Call BarycentricNormalize(B)
        Exit Sub
    End If
    '
    ' Fill X/Y
    '
    ReDim B.X(0 To N - 1)
    ReDim B.Y(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        B.X(i_) = X(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        B.Y(i_) = Y(i_)
    Next i_
    Call TagSortFastR(B.X, B.Y, N)
    '
    ' Calculate Wk
    '
    ReDim B.w(0 To N - 1)
    S0 = 1#
    For K = 1# To d Step 1
        S0 = -S0
    Next K
    For K = 0# To N - 1# Step 1
        '
        ' Wk
        '
        S = 0#
        For i = MaxInt(K - d, 0#) To MinInt(K, N - 1# - d) Step 1
            V = 1#
            For j = i To i + d Step 1
                If j <> K Then
                    V = V / Abs(B.X(K) - B.X(j))
                End If
            Next j
            S = S + V
        Next i
        B.w(K) = S0 * S
        '
        ' Next S0
        '
        S0 = -S0
    Next K
    '
    ' Normalize
    '
    Call BarycentricNormalize(B)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weghted rational least  squares  fitting  using  Floater-Hormann  rational
'functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
'individual weights.
'
'Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
'functions. Different values of D are tried, optimal D (least WEIGHTED root
'mean square error) is chosen.  Task  is  linear,  so  linear least squares
'solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
'(mostly dominated by the least squares solver).
'
'SEE ALSO
'* BarycentricFitFloaterHormann(), "lightweight" fitting without invididual
'  weights and constraints.
'
'INPUT PARAMETERS:
'    X   -   points, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    W   -   weights, array[0..N-1]
'            Each summand in square  sum  of  approximation deviations from
'            given  values  is  multiplied  by  the square of corresponding
'            weight. Fill it by 1's if you don't  want  to  solve  weighted
'            task.
'    N   -   number of points, N>0.
'    XC  -   points where function values/derivatives are constrained,
'            array[0..K-1].
'    YC  -   values of constraints, array[0..K-1]
'    DC  -   array[0..K-1], types of constraints:
'            * DC[i]=0   means that S(XC[i])=YC[i]
'            * DC[i]=1   means that S'(XC[i])=YC[i]
'            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'    K   -   number of constraints, 0<=K<M.
'            K=0 means no constraints (XC/YC/DC are not used in such cases)
'    M   -   number of basis functions ( = number_of_nodes), M>=2.
'
'OUTPUT PARAMETERS:
'    Info-   same format as in LSFitLinearWC() subroutine.
'            * Info>0    task is solved
'            * Info<=0   an error occured:
'                        -4 means inconvergence of internal SVD
'                        -3 means inconsistent constraints
'                        -1 means another errors in parameters passed
'                           (N<=0, for example)
'    B   -   barycentric interpolant.
'    Rep -   report, same format as in LSFitLinearWC() subroutine.
'            Following fields are set:
'            * DBest         best value of the D parameter
'            * RMSError      rms error on the (X,Y).
'            * AvgError      average error on the (X,Y).
'            * AvgRelError   average relative error on the non-zero Y
'            * MaxError      maximum error
'                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'Setting constraints can lead  to undesired  results,  like ill-conditioned
'behavior, or inconsistency being detected. From the other side,  it allows
'us to improve quality of the fit. Here we summarize  our  experience  with
'constrained barycentric interpolants:
'* excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
'  functions aren't as flexible as splines (although they are very smooth).
'* the more evenly constraints are spread across [min(x),max(x)],  the more
'  chances that they will be consistent
'* the  greater  is  M (given  fixed  constraints),  the  more chances that
'  constraints will be consistent
'* in the general case, consistency of constraints IS NOT GUARANTEED.
'* in the several special cases, however, we CAN guarantee consistency.
'* one of this cases is constraints on the function  VALUES at the interval
'  boundaries. Note that consustency of the  constraints  on  the  function
'  DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
'  which are more flexible).
'* another  special  case  is ONE constraint on the function value (OR, but
'  not AND, derivative) anywhere in the interval
'
'Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
'can't solve your task without them. Anything beyond  special  cases  given
'above is not guaranteed and may result in inconsistency.
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricFitFloaterHormannWC(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC() As Double, _
         ByRef YC() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef B As BarycentricInterpolant, _
         ByRef Rep As BarycentricFitReport)
    Dim d As Long
    Dim i As Long
    Dim WRMSCur As Double
    Dim WRMSBest As Double
    Dim LocB As BarycentricInterpolant
    Dim LocRep As BarycentricFitReport
    Dim LocInfo As Long
    If N < 1# Or M < 2# Or K < 0# Or K >= M Then
        Info = -1#
        Exit Sub
    End If
    '
    ' Find optimal D
    '
    ' Info is -3 by default (degenerate constraints).
    ' If LocInfo will always be equal to -3, Info will remain equal to -3.
    ' If at least once LocInfo will be -4, Info will be -4.
    '
    WRMSBest = MaxRealNumber
    Rep.DBest = -1#
    Info = -3#
    For d = 0# To MinInt(9#, N - 1#) Step 1
        Call BarycentricFitWCFixedD(X, Y, w, N, XC, YC, DC, K, M, d, LocInfo, LocB, LocRep)
        If LocInfo > 0# Then
            '
            ' Calculate weghted RMS
            '
            WRMSCur = 0#
            For i = 0# To N - 1# Step 1
                WRMSCur = WRMSCur + Square(w(i) * (Y(i) - BarycentricCalc(LocB, X(i))))
            Next i
            WRMSCur = Sqr(WRMSCur / N)
            If WRMSCur < WRMSBest Or Rep.DBest < 0# Then
                Call BarycentricCopy(LocB, B)
                Rep.DBest = d
                Info = 1#
                Rep.RMSError = LocRep.RMSError
                Rep.AvgError = LocRep.AvgError
                Rep.AvgRelError = LocRep.AvgRelError
                Rep.MaxError = LocRep.MaxError
                Rep.TaskRCond = LocRep.TaskRCond
                WRMSBest = WRMSCur
            End If
        Else
            If LocInfo <> -3# And Info < 0# Then
                Info = LocInfo
            End If
        End If
    Next d
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Rational least squares fitting, without weights and constraints.
'
'See BarycentricFitFloaterHormannWC() for more information.
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BarycentricFitFloaterHormann(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef B As BarycentricInterpolant, _
         ByRef Rep As BarycentricFitReport)
    Dim w() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim DC() As Long
    Dim i As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim w(0 To N - 1)
    For i = 0# To N - 1# Step 1
        w(i) = 1#
    Next i
    Call BarycentricFitFloaterHormannWC(X, Y, w, N, XC, YC, DC, 0#, M, Info, B, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Normalization of barycentric interpolant:
'* B.N, B.X, B.Y and B.W are initialized
'* B.SY is NOT initialized
'* Y[] is normalized, scaling coefficient is stored in B.SY
'* W[] is normalized, no scaling coefficient is stored
'* X[] is sorted
'
'Internal subroutine.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BarycentricNormalize(ByRef B As BarycentricInterpolant)
    Dim P1() As Long
    Dim P2() As Long
    Dim i As Long
    Dim j As Long
    Dim J2 As Long
    Dim V As Double
    Dim i_ As Long
    '
    ' Normalize task: |Y|<=1, |W|<=1, sort X[]
    '
    B.SY = 0#
    For i = 0# To B.N - 1# Step 1
        B.SY = MaxReal(B.SY, Abs(B.Y(i)))
    Next i
    If B.SY > 0# And Abs(B.SY - 1#) > 10# * MachineEpsilon Then
        V = 1# / B.SY
        For i_ = 0# To B.N - 1# Step 1
            B.Y(i_) = V * B.Y(i_)
        Next i_
    End If
    V = 0#
    For i = 0# To B.N - 1# Step 1
        V = MaxReal(V, Abs(B.w(i)))
    Next i
    If V > 0# And Abs(V - 1#) > 10# * MachineEpsilon Then
        V = 1# / V
        For i_ = 0# To B.N - 1# Step 1
            B.w(i_) = V * B.w(i_)
        Next i_
    End If
    For i = 0# To B.N - 2# Step 1
        If B.X(i + 1#) < B.X(i) Then
            Call TagSort(B.X, B.N, P1, P2)
            For j = 0# To B.N - 1# Step 1
                J2 = P2(j)
                V = B.Y(j)
                B.Y(j) = B.Y(J2)
                B.Y(J2) = V
                V = B.w(j)
                B.w(j) = B.w(J2)
                B.w(J2) = V
            Next j
            Exit For
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine, calculates barycentric basis functions.
'Used for efficient simultaneous calculation of N basis functions.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BarycentricCalcBasis(ByRef B As BarycentricInterpolant, _
         ByVal T As Double, _
         ByRef Y() As Double)
    Dim S2 As Double
    Dim S As Double
    Dim V As Double
    Dim i As Long
    Dim j As Long
    Dim i_ As Long
    '
    ' special case: N=1
    '
    If B.N = 1# Then
        Y(0#) = 1#
        Exit Sub
    End If
    '
    ' Here we assume that task is normalized, i.e.:
    ' 1. abs(Y[i])<=1
    ' 2. abs(W[i])<=1
    ' 3. X[] is ordered
    '
    ' First, we decide: should we use "safe" formula (guarded
    ' against overflow) or fast one?
    '
    S = Abs(T - B.X(0#))
    For i = 0# To B.N - 1# Step 1
        V = B.X(i)
        If V = T Then
            For j = 0# To B.N - 1# Step 1
                Y(j) = 0#
            Next j
            Y(i) = 1#
            Exit Sub
        End If
        V = Abs(T - V)
        If V < S Then
            S = V
        End If
    Next i
    S2 = 0#
    For i = 0# To B.N - 1# Step 1
        V = S / (T - B.X(i))
        V = V * B.w(i)
        Y(i) = V
        S2 = S2 + V
    Next i
    V = 1# / S2
    For i_ = 0# To B.N - 1# Step 1
        Y(i_) = V * Y(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal Floater-Hormann fitting subroutine for fixed D
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BarycentricFitWCFixedD(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC_() As Double, _
         ByRef YC_() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByVal d As Long, _
         ByRef Info As Long, _
         ByRef B As BarycentricInterpolant, _
         ByRef Rep As BarycentricFitReport)
    Dim X() As Double
    Dim Y() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim FMatrix() As Double
    Dim CMatrix() As Double
    Dim Y2() As Double
    Dim W2() As Double
    Dim SX() As Double
    Dim SY() As Double
    Dim SBF() As Double
    Dim XOriginal() As Double
    Dim YOriginal() As Double
    Dim Tmp() As Double
    Dim LRep As LSFitReport
    Dim V0 As Double
    Dim V1 As Double
    Dim MX As Double
    Dim b2 As BarycentricInterpolant
    Dim i As Long
    Dim j As Long
    Dim RelCnt As Long
    Dim XA As Double
    Dim XB As Double
    Dim SA As Double
    Dim SB As Double
    Dim Decay As Double
    Dim i_ As Long
    X = X_
    Y = y_
    XC = XC_
    YC = YC_
    If N < 1# Or M < 2# Or K < 0# Or K >= M Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To K - 1# Step 1
        Info = 0#
        If DC(i) < 0# Then
            Info = -1#
        End If
        If DC(i) > 1# Then
            Info = -1#
        End If
        If Info < 0# Then
            Exit Sub
        End If
    Next i
    '
    ' weight decay for correct handling of task which becomes
    ' degenerate after constraints are applied
    '
    Decay = 10000# * MachineEpsilon
    '
    ' Scale X, Y, XC, YC
    '
    Call LSFitScaleXY(X, Y, N, XC, YC, DC, K, XA, XB, SA, SB, XOriginal, YOriginal)
    '
    ' allocate space, initialize:
    ' * FMatrix-   values of basis functions at X[]
    ' * CMatrix-   values (derivatives) of basis functions at XC[]
    '
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    ReDim FMatrix(0 To N + M - 1, 0 To M - 1)
    If K > 0# Then
        ReDim CMatrix(0 To K - 1, 0 To M + 1# - 1)
    End If
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    '
    ' Prepare design and constraints matrices:
    ' * fill constraints matrix
    ' * fill first N rows of design matrix with values
    ' * fill next M rows of design matrix with regularizing term
    ' * append M zeros to Y
    ' * append M elements, mean(abs(W)) each, to W
    '
    ReDim SX(0 To M - 1)
    ReDim SY(0 To M - 1)
    ReDim SBF(0 To M - 1)
    For j = 0# To M - 1# Step 1
        SX(j) = 2# * j / (M - 1#) - 1#
    Next j
    For i = 0# To M - 1# Step 1
        SY(i) = 1#
    Next i
    Call BarycentricBuildFloaterHormann(SX, SY, M, d, b2)
    MX = 0#
    For i = 0# To N - 1# Step 1
        Call BarycentricCalcBasis(b2, X(i), SBF)
        For i_ = 0# To M - 1# Step 1
            FMatrix(i, i_) = SBF(i_)
        Next i_
        Y2(i) = Y(i)
        W2(i) = w(i)
        MX = MX + Abs(w(i)) / N
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To M - 1# Step 1
            If i = j Then
                FMatrix(N + i, j) = Decay
            Else
                FMatrix(N + i, j) = 0#
            End If
        Next j
        Y2(N + i) = 0#
        W2(N + i) = MX
    Next i
    If K > 0# Then
        For j = 0# To M - 1# Step 1
            For i = 0# To M - 1# Step 1
                SY(i) = 0#
            Next i
            SY(j) = 1#
            Call BarycentricBuildFloaterHormann(SX, SY, M, d, b2)
            For i = 0# To K - 1# Step 1
                Call BarycentricDiff1(b2, XC(i), V0, V1)
                If DC(i) = 0# Then
                    CMatrix(i, j) = V0
                End If
                If DC(i) = 1# Then
                    CMatrix(i, j) = V1
                End If
            Next i
        Next j
        For i = 0# To K - 1# Step 1
            CMatrix(i, M) = YC(i)
        Next i
    End If
    '
    ' Solve constrained task
    '
    If K > 0# Then
        '
        ' solve using regularization
        '
        Call LSFitLinearWC(Y2, W2, FMatrix, CMatrix, N + M, M, K, Info, Tmp, LRep)
    Else
        '
        ' no constraints, no regularization needed
        '
        Call LSFitLinearWC(Y, w, FMatrix, CMatrix, N, M, K, Info, Tmp, LRep)
    End If
    If Info < 0# Then
        Exit Sub
    End If
    '
    ' Generate interpolant and scale it
    '
    For i_ = 0# To M - 1# Step 1
        SY(i_) = Tmp(i_)
    Next i_
    Call BarycentricBuildFloaterHormann(SX, SY, M, d, B)
    Call BarycentricLinTransX(B, 2# / (XB - XA), -((XA + XB) / (XB - XA)))
    Call BarycentricLinTransY(B, SB - SA, SA)
    '
    ' Scale absolute errors obtained from LSFitLinearW.
    ' Relative error should be calculated separately
    ' (because of shifting/scaling of the task)
    '
    Rep.TaskRCond = LRep.TaskRCond
    Rep.RMSError = LRep.RMSError * (SB - SA)
    Rep.AvgError = LRep.AvgError * (SB - SA)
    Rep.MaxError = LRep.MaxError * (SB - SA)
    Rep.AvgRelError = 0#
    RelCnt = 0#
    For i = 0# To N - 1# Step 1
        If YOriginal(i) <> 0# Then
            Rep.AvgRelError = Rep.AvgRelError + Abs(BarycentricCalc(B, XOriginal(i)) - YOriginal(i)) / Abs(YOriginal(i))
            RelCnt = RelCnt + 1#
        End If
    Next i
    If RelCnt <> 0# Then
        Rep.AvgRelError = Rep.AvgRelError / RelCnt
    End If
End Sub

