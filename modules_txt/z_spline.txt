''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2006-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional spline inteprolant
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type Spline1DInterpolant
    Periodic As Boolean
    N As Long
    K As Long
    X() As Double
    c() As Double
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Spline fitting report:
'    TaskRCond       reciprocal of task's condition number
'    RMSError        RMS error
'    AvgError        average error
'    AvgRelError     average relative error (for non-zero Y[I])
'    MaxError        maximum error
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type Spline1DFitReport
    TaskRCond As Double
    RMSError As Double
    AvgError As Double
    AvgRelError As Double
    MaxError As Double
End Type
'Global constants
Private Const Spline1DVNum As Long = 11#
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'2-dimensional spline inteprolant
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type Spline2DInterpolant
    K As Long
    c() As Double
End Type
'Global constants
Private Const Spline2DVNum As Long = 12#
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Parametric spline inteprolant: 2-dimensional curve.
'
'You should not try to access its members directly - use PSpline2XXXXXXXX()
'functions instead.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type PSpline2Interpolant
    N As Long
    Periodic As Boolean
    p() As Double
    X As Spline1DInterpolant
    Y As Spline1DInterpolant
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Parametric spline inteprolant: 3-dimensional curve.
'
'You should not try to access its members directly - use PSpline3XXXXXXXX()
'functions instead.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type PSpline3Interpolant
    N As Long
    Periodic As Boolean
    p() As Double
    X As Spline1DInterpolant
    Y As Spline1DInterpolant
    z As Spline1DInterpolant
End Type
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds linear spline interpolant
'
'INPUT PARAMETERS:
'    X   -   spline nodes, array[0..N-1]
'    Y   -   function values, array[0..N-1]
'    N   -   points count, N>=2
'
'OUTPUT PARAMETERS:
'    C   -   spline interpolant
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'  -- ALGLIB PROJECT --
'     Copyright 24.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildLinear(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByRef c As Spline1DInterpolant)
    Dim X() As Double
    Dim Y() As Double
    Dim i As Long
    X = X_
    Y = y_
    
    '
    ' Sort points
    '
    Call HeapSortPoints(X, Y, N)
    
    '
    ' Build
    '
    c.Periodic = False
    c.N = N
    c.K = 3#
    ReDim c.X(0 To N - 1)
    ReDim c.c(0 To 4# * (N - 1#) - 1)
    For i = 0# To N - 1# Step 1
        c.X(i) = X(i)
    Next i
    For i = 0# To N - 2# Step 1
        c.c(4# * i + 0#) = Y(i)
        c.c(4# * i + 1#) = (Y(i + 1#) - Y(i)) / (X(i + 1#) - X(i))
        c.c(4# * i + 2#) = 0#
        c.c(4# * i + 3#) = 0#
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds cubic spline interpolant.
'
'INPUT PARAMETERS:
'    X           -   spline nodes, array[0..N-1].
'    Y           -   function values, array[0..N-1].
'    N           -   points count, N>=2
'    BoundLType  -   boundary condition type for the left boundary
'    BoundL      -   left boundary condition (first or second derivative,
'                    depending on the BoundLType)
'    BoundRType  -   boundary condition type for the right boundary
'    BoundR      -   right boundary condition (first or second derivative,
'                    depending on the BoundRType)
'
'OUTPUT PARAMETERS:
'    C           -   spline interpolant
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'SETTING BOUNDARY VALUES:
'
'The BoundLType/BoundRType parameters can have the following values:
'    * -1, which corresonds to the periodic (cyclic) boundary conditions.
'          In this case:
'          * both BoundLType and BoundRType must be equal to -1.
'          * BoundL/BoundR are ignored
'          * Y[last] is ignored (it is assumed to be equal to Y[first]).
'    *  0, which  corresponds  to  the  parabolically   terminated  spline
'          (BoundL and/or BoundR are ignored).
'    *  1, which corresponds to the first derivative boundary condition
'    *  2, which corresponds to the second derivative boundary condition
'
'PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'However, this subroutine doesn't require you to specify equal  values  for
'the first and last points - it automatically forces them to be equal.
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildCubic(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByVal BoundLType As Long, _
         ByVal BoundL As Double, _
         ByVal BoundRType As Long, _
         ByVal BoundR As Double, _
         ByRef c As Spline1DInterpolant)
    Dim X() As Double
    Dim Y() As Double
    Dim a1() As Double
    Dim a2() As Double
    Dim a3() As Double
    Dim B() As Double
    Dim d() As Double
    Dim DT() As Double
    Dim i As Long
    Dim V As Double
    Dim i_ As Long
    X = X_
    Y = y_
    
    '
    ' Special cases:
    ' * N=2, parabolic terminated boundary condition on both ends
    ' * N=2, periodic boundary condition
    '
    If N = 2# And BoundLType = 0# And BoundRType = 0# Then
        
        '
        ' Change task type
        '
        BoundLType = 2#
        BoundL = 0#
        BoundRType = 2#
        BoundR = 0#
    End If
    If N = 2# And BoundLType = -1# And BoundRType = -1# Then
        
        '
        ' Change task type
        '
        BoundLType = 1#
        BoundL = 0#
        BoundRType = 1#
        BoundR = 0#
        Y(1#) = Y(0#)
    End If
    
    '
    ' Periodic and non-periodic boundary conditions are
    ' two separate classes
    '
    If BoundRType = -1# And BoundLType = -1# Then
        
        '
        ' Periodic boundary conditions
        '
        ReDim a1(0 To N - 1# - 1)
        ReDim a2(0 To N - 1# - 1)
        ReDim a3(0 To N - 1# - 1)
        ReDim B(0 To N - 1# - 1)
        
        '
        ' Sort points.
        '
        Call HeapSortPoints(X, Y, N)
        Y(N - 1#) = Y(0#)
        
        '
        ' Boundary conditions at N-1 points
        ' (one point less because last point is the same as first point).
        '
        a1(0#) = X(1#) - X(0#)
        a2(0#) = 2# * (X(1#) - X(0#) + X(N - 1#) - X(N - 2#))
        a3(0#) = X(N - 1#) - X(N - 2#)
        B(0#) = 3# * (Y(N - 1#) - Y(N - 2#)) / (X(N - 1#) - X(N - 2#)) * (X(1#) - X(0#)) + 3# * (Y(1#) - Y(0#)) / (X(1#) - X(0#)) * (X(N - 1#) - X(N - 2#))
        For i = 1# To N - 2# Step 1
            
            '
            ' Altough last point is [N-2], we use X[N-1] and Y[N-1]
            ' (because of periodicity)
            '
            a1(i) = X(i + 1#) - X(i)
            a2(i) = 2# * (X(i + 1#) - X(i - 1#))
            a3(i) = X(i) - X(i - 1#)
            B(i) = 3# * (Y(i) - Y(i - 1#)) / (X(i) - X(i - 1#)) * (X(i + 1#) - X(i)) + 3# * (Y(i + 1#) - Y(i)) / (X(i + 1#) - X(i)) * (X(i) - X(i - 1#))
        Next i
        
        '
        ' Solve, add last point (with index N-1)
        '
        Call SolveCyclicTridiagonal(a1, a2, a3, B, N - 1#, DT)
        ReDim d(0 To N - 1)
        For i_ = 0# To N - 2# Step 1
            d(i_) = DT(i_)
        Next i_
        d(N - 1#) = d(0#)
        
        '
        ' Now problem is reduced to the cubic Hermite spline
        '
        Call Spline1DBuildHermite(X, Y, d, N, c)
        c.Periodic = True
    Else
        
        '
        ' Non-periodic boundary condition
        '
        ReDim a1(0 To N - 1)
        ReDim a2(0 To N - 1)
        ReDim a3(0 To N - 1)
        ReDim B(0 To N - 1)
        
        '
        ' Sort points.
        '
        Call HeapSortPoints(X, Y, N)
        
        '
        ' Left boundary conditions
        '
        If BoundLType = 0# Then
            a1(0#) = 0#
            a2(0#) = 1#
            a3(0#) = 1#
            B(0#) = 2# * (Y(1#) - Y(0#)) / (X(1#) - X(0#))
        End If
        If BoundLType = 1# Then
            a1(0#) = 0#
            a2(0#) = 1#
            a3(0#) = 0#
            B(0#) = BoundL
        End If
        If BoundLType = 2# Then
            a1(0#) = 0#
            a2(0#) = 2#
            a3(0#) = 1#
            B(0#) = 3# * (Y(1#) - Y(0#)) / (X(1#) - X(0#)) - 0.5 * BoundL * (X(1#) - X(0#))
        End If
        
        '
        ' Central conditions
        '
        For i = 1# To N - 2# Step 1
            a1(i) = X(i + 1#) - X(i)
            a2(i) = 2# * (X(i + 1#) - X(i - 1#))
            a3(i) = X(i) - X(i - 1#)
            B(i) = 3# * (Y(i) - Y(i - 1#)) / (X(i) - X(i - 1#)) * (X(i + 1#) - X(i)) + 3# * (Y(i + 1#) - Y(i)) / (X(i + 1#) - X(i)) * (X(i) - X(i - 1#))
        Next i
        
        '
        ' Right boundary conditions
        '
        If BoundRType = 0# Then
            a1(N - 1#) = 1#
            a2(N - 1#) = 1#
            a3(N - 1#) = 0#
            B(N - 1#) = 2# * (Y(N - 1#) - Y(N - 2#)) / (X(N - 1#) - X(N - 2#))
        End If
        If BoundRType = 1# Then
            a1(N - 1#) = 0#
            a2(N - 1#) = 1#
            a3(N - 1#) = 0#
            B(N - 1#) = BoundR
        End If
        If BoundRType = 2# Then
            a1(N - 1#) = 1#
            a2(N - 1#) = 2#
            a3(N - 1#) = 0#
            B(N - 1#) = 3# * (Y(N - 1#) - Y(N - 2#)) / (X(N - 1#) - X(N - 2#)) + 0.5 * BoundR * (X(N - 1#) - X(N - 2#))
        End If
        
        '
        ' Solve
        '
        Call SolveTridiagonal(a1, a2, a3, B, N, d)
        
        '
        ' Now problem is reduced to the cubic Hermite spline
        '
        Call Spline1DBuildHermite(X, Y, d, N, c)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds Catmull-Rom spline interpolant.
'
'INPUT PARAMETERS:
'    X           -   spline nodes, array[0..N-1].
'    Y           -   function values, array[0..N-1].
'    N           -   points count, N>=2
'    BoundType   -   boundary condition type:
'                    * -1 for periodic boundary condition
'                    *  0 for parabolically terminated spline
'    Tension     -   tension parameter:
'                    * tension=0   corresponds to classic Catmull-Rom spline
'                    * 0<tension<1 corresponds to more general form - cardinal spline
'
'OUTPUT PARAMETERS:
'    C           -   spline interpolant
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
'
'Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
'However, this subroutine doesn't require you to specify equal  values  for
'the first and last points - it automatically forces them to be equal.
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildCatmullRom(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByVal BoundType As Long, _
         ByVal Tension As Double, _
         ByRef c As Spline1DInterpolant)
    Dim X() As Double
    Dim Y() As Double
    Dim a1() As Double
    Dim a2() As Double
    Dim a3() As Double
    Dim B() As Double
    Dim d() As Double
    Dim DT() As Double
    Dim i As Long
    Dim V As Double
    X = X_
    Y = y_
    
    '
    ' Special cases:
    ' * N=2, parabolic terminated boundary condition on both ends
    ' * N=2, periodic boundary condition
    '
    If N = 2# And BoundType = 0# Then
        
        '
        ' Just linear spline
        '
        Call Spline1DBuildLinear(X, Y, N, c)
        Exit Sub
    End If
    If N = 2# And BoundType = -1# Then
        
        '
        ' Same as cubic spline with periodic conditions
        '
        Call Spline1DBuildCubic(X, Y, N, -1#, 0#, -1#, 0#, c)
        Exit Sub
    End If
    
    '
    ' Periodic or non-periodic boundary conditions
    '
    If BoundType = -1# Then
        
        '
        ' Sort points.
        '
        Call HeapSortPoints(X, Y, N)
        Y(N - 1#) = Y(0#)
        
        '
        ' Periodic boundary conditions
        '
        ReDim d(0 To N - 1)
        d(0#) = (Y(1#) - Y(N - 2#)) / (2# * (X(1#) - X(0#) + X(N - 1#) - X(N - 2#)))
        For i = 1# To N - 2# Step 1
            d(i) = (1# - Tension) * (Y(i + 1#) - Y(i - 1#)) / (X(i + 1#) - X(i - 1#))
        Next i
        d(N - 1#) = d(0#)
        
        '
        ' Now problem is reduced to the cubic Hermite spline
        '
        Call Spline1DBuildHermite(X, Y, d, N, c)
        c.Periodic = True
    Else
        
        '
        ' Sort points.
        '
        Call HeapSortPoints(X, Y, N)
        
        '
        ' Non-periodic boundary conditions
        '
        ReDim d(0 To N - 1)
        For i = 1# To N - 2# Step 1
            d(i) = (1# - Tension) * (Y(i + 1#) - Y(i - 1#)) / (X(i + 1#) - X(i - 1#))
        Next i
        d(0#) = 2# * (Y(1#) - Y(0#)) / (X(1#) - X(0#)) - d(1#)
        d(N - 1#) = 2# * (Y(N - 1#) - Y(N - 2#)) / (X(N - 1#) - X(N - 2#)) - d(N - 2#)
        
        '
        ' Now problem is reduced to the cubic Hermite spline
        '
        Call Spline1DBuildHermite(X, Y, d, N, c)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds Hermite spline interpolant.
'
'INPUT PARAMETERS:
'    X           -   spline nodes, array[0..N-1]
'    Y           -   function values, array[0..N-1]
'    D           -   derivatives, array[0..N-1]
'    N           -   points count, N>=2
'
'OUTPUT PARAMETERS:
'    C           -   spline interpolant.
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildHermite(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByRef D_() As Double, _
         ByVal N As Long, _
         ByRef c As Spline1DInterpolant)
    Dim X() As Double
    Dim Y() As Double
    Dim d() As Double
    Dim i As Long
    Dim Delta As Double
    Dim Delta2 As Double
    Dim Delta3 As Double
    X = X_
    Y = y_
    d = D_
    
    '
    ' Sort points
    '
    Call HeapSortDPoints(X, Y, d, N)
    
    '
    ' Build
    '
    ReDim c.X(0 To N - 1)
    ReDim c.c(0 To 4# * (N - 1#) - 1)
    c.Periodic = False
    c.K = 3#
    c.N = N
    For i = 0# To N - 1# Step 1
        c.X(i) = X(i)
    Next i
    For i = 0# To N - 2# Step 1
        Delta = X(i + 1#) - X(i)
        Delta2 = Square(Delta)
        Delta3 = Delta * Delta2
        c.c(4# * i + 0#) = Y(i)
        c.c(4# * i + 1#) = d(i)
        c.c(4# * i + 2#) = (3# * (Y(i + 1#) - Y(i)) - 2# * d(i) * Delta - d(i + 1#) * Delta) / Delta2
        c.c(4# * i + 3#) = (2# * (Y(i) - Y(i + 1#)) + d(i) * Delta + d(i + 1#) * Delta) / Delta3
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds Akima spline interpolant
'
'INPUT PARAMETERS:
'    X           -   spline nodes, array[0..N-1]
'    Y           -   function values, array[0..N-1]
'    N           -   points count, N>=5
'
'OUTPUT PARAMETERS:
'    C           -   spline interpolant
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'  -- ALGLIB PROJECT --
'     Copyright 24.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DBuildAkima(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByRef c As Spline1DInterpolant)
    Dim X() As Double
    Dim Y() As Double
    Dim i As Long
    Dim d() As Double
    Dim w() As Double
    Dim Diff() As Double
    X = X_
    Y = y_
    
    '
    ' Sort points
    '
    Call HeapSortPoints(X, Y, N)
    
    '
    ' Prepare W (weights), Diff (divided differences)
    '
    ReDim w(0 To N - 1# - 1)
    ReDim Diff(0 To N - 1# - 1)
    For i = 0# To N - 2# Step 1
        Diff(i) = (Y(i + 1#) - Y(i)) / (X(i + 1#) - X(i))
    Next i
    For i = 1# To N - 2# Step 1
        w(i) = Abs(Diff(i) - Diff(i - 1#))
    Next i
    
    '
    ' Prepare Hermite interpolation scheme
    '
    ReDim d(0 To N - 1)
    For i = 2# To N - 3# Step 1
        If Abs(w(i - 1#)) + Abs(w(i + 1#)) <> 0# Then
            d(i) = (w(i + 1#) * Diff(i - 1#) + w(i - 1#) * Diff(i)) / (w(i + 1#) + w(i - 1#))
        Else
            d(i) = ((X(i + 1#) - X(i)) * Diff(i - 1#) + (X(i) - X(i - 1#)) * Diff(i)) / (X(i + 1#) - X(i - 1#))
        End If
    Next i
    d(0#) = DiffThreePoint(X(0#), X(0#), Y(0#), X(1#), Y(1#), X(2#), Y(2#))
    d(1#) = DiffThreePoint(X(1#), X(0#), Y(0#), X(1#), Y(1#), X(2#), Y(2#))
    d(N - 2#) = DiffThreePoint(X(N - 2#), X(N - 3#), Y(N - 3#), X(N - 2#), Y(N - 2#), X(N - 1#), Y(N - 1#))
    d(N - 1#) = DiffThreePoint(X(N - 1#), X(N - 3#), Y(N - 3#), X(N - 2#), Y(N - 2#), X(N - 1#), Y(N - 1#))
    
    '
    ' Build Akima spline using Hermite interpolation scheme
    '
    Call Spline1DBuildHermite(X, Y, d, N, c)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted fitting by cubic  spline,  with constraints on function values or
'derivatives.
'
'Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
'basis functions. Basis functions are cubic splines with continuous  second
'derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
'regularizing term is used  when  solving  constrained  tasks  (to  improve
'stability).
'
'Task is linear, so linear least squares solver is used. Complexity of this
'computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'SEE ALSO
'    Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
'                                less smooth)
'    Spline1DFitCubic()      -   "lightweight" fitting  by  cubic  splines,
'                                without invididual weights and constraints
'
'INPUT PARAMETERS:
'    X   -   points, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    W   -   weights, array[0..N-1]
'            Each summand in square  sum  of  approximation deviations from
'            given  values  is  multiplied  by  the square of corresponding
'            weight. Fill it by 1's if you don't  want  to  solve  weighted
'            task.
'    N   -   number of points, N>0.
'    XC  -   points where spline values/derivatives are constrained,
'            array[0..K-1].
'    YC  -   values of constraints, array[0..K-1]
'    DC  -   array[0..K-1], types of constraints:
'            * DC[i]=0   means that S(XC[i])=YC[i]
'            * DC[i]=1   means that S'(XC[i])=YC[i]
'            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'    K   -   number of constraints, 0<=K<M.
'            K=0 means no constraints (XC/YC/DC are not used in such cases)
'    M   -   number of basis functions ( = number_of_nodes+2), M>=4.
'
'OUTPUT PARAMETERS:
'    Info-   same format as in LSFitLinearWC() subroutine.
'            * Info>0    task is solved
'            * Info<=0   an error occured:
'                        -4 means inconvergence of internal SVD
'                        -3 means inconsistent constraints
'                        -1 means another errors in parameters passed
'                           (N<=0, for example)
'    S   -   spline interpolant.
'    Rep -   report, same format as in LSFitLinearWC() subroutine.
'            Following fields are set:
'            * RMSError      rms error on the (X,Y).
'            * AvgError      average error on the (X,Y).
'            * AvgRelError   average relative error on the non-zero Y
'            * MaxError      maximum error
'                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'Setting constraints can lead  to undesired  results,  like ill-conditioned
'behavior, or inconsistency being detected. From the other side,  it allows
'us to improve quality of the fit. Here we summarize  our  experience  with
'constrained regression splines:
'* excessive constraints can be inconsistent. Splines are  piecewise  cubic
'  functions, and it is easy to create an example, where  large  number  of
'  constraints  concentrated  in  small  area will result in inconsistency.
'  Just because spline is not flexible enough to satisfy all of  them.  And
'  same constraints spread across the  [min(x),max(x)]  will  be  perfectly
'  consistent.
'* the more evenly constraints are spread across [min(x),max(x)],  the more
'  chances that they will be consistent
'* the  greater  is  M (given  fixed  constraints),  the  more chances that
'  constraints will be consistent
'* in the general case, consistency of constraints IS NOT GUARANTEED.
'* in the several special cases, however, we CAN guarantee consistency.
'* one of this cases is constraints  on  the  function  values  AND/OR  its
'  derivatives at the interval boundaries.
'* another  special  case  is ONE constraint on the function value (OR, but
'  not AND, derivative) anywhere in the interval
'
'Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
'can't solve your task without them. Anything beyond  special  cases  given
'above is not guaranteed and may result in inconsistency.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DFitCubicWC(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC() As Double, _
         ByRef YC() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef S As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Call Spline1DFitInternal(0#, X, Y, w, N, XC, YC, DC, K, M, Info, S, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted  fitting  by Hermite spline,  with constraints on function values
'or first derivatives.
'
'Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
'basis functions. Basis functions are Hermite splines.  Small  regularizing
'term is used when solving constrained tasks (to improve stability).
'
'Task is linear, so linear least squares solver is used. Complexity of this
'computational scheme is O(N*M^2), mostly dominated by least squares solver
'
'SEE ALSO
'    Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
'                                more smooth)
'    Spline1DFitHermite()    -   "lightweight" Hermite fitting, without
'                                invididual weights and constraints
'
'INPUT PARAMETERS:
'    X   -   points, array[0..N-1].
'    Y   -   function values, array[0..N-1].
'    W   -   weights, array[0..N-1]
'            Each summand in square  sum  of  approximation deviations from
'            given  values  is  multiplied  by  the square of corresponding
'            weight. Fill it by 1's if you don't  want  to  solve  weighted
'            task.
'    N   -   number of points, N>0.
'    XC  -   points where spline values/derivatives are constrained,
'            array[0..K-1].
'    YC  -   values of constraints, array[0..K-1]
'    DC  -   array[0..K-1], types of constraints:
'            * DC[i]=0   means that S(XC[i])=YC[i]
'            * DC[i]=1   means that S'(XC[i])=YC[i]
'            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
'    K   -   number of constraints, 0<=K<M.
'            K=0 means no constraints (XC/YC/DC are not used in such cases)
'    M   -   number of basis functions (= 2 * number of nodes),
'            M>=4,
'            M IS EVEN!
'
'OUTPUT PARAMETERS:
'    Info-   same format as in LSFitLinearW() subroutine:
'            * Info>0    task is solved
'            * Info<=0   an error occured:
'                        -4 means inconvergence of internal SVD
'                        -3 means inconsistent constraints
'                        -2 means odd M was passed (which is not supported)
'                        -1 means another errors in parameters passed
'                           (N<=0, for example)
'    S   -   spline interpolant.
'    Rep -   report, same format as in LSFitLinearW() subroutine.
'            Following fields are set:
'            * RMSError      rms error on the (X,Y).
'            * AvgError      average error on the (X,Y).
'            * AvgRelError   average relative error on the non-zero Y
'            * MaxError      maximum error
'                            NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'IMPORTANT:
'    this subroitine supports only even M's
'
'
'ORDER OF POINTS
'
'Subroutine automatically sorts points, so caller may pass unsorted array.
'
'SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
'
'Setting constraints can lead  to undesired  results,  like ill-conditioned
'behavior, or inconsistency being detected. From the other side,  it allows
'us to improve quality of the fit. Here we summarize  our  experience  with
'constrained regression splines:
'* excessive constraints can be inconsistent. Splines are  piecewise  cubic
'  functions, and it is easy to create an example, where  large  number  of
'  constraints  concentrated  in  small  area will result in inconsistency.
'  Just because spline is not flexible enough to satisfy all of  them.  And
'  same constraints spread across the  [min(x),max(x)]  will  be  perfectly
'  consistent.
'* the more evenly constraints are spread across [min(x),max(x)],  the more
'  chances that they will be consistent
'* the  greater  is  M (given  fixed  constraints),  the  more chances that
'  constraints will be consistent
'* in the general case, consistency of constraints is NOT GUARANTEED.
'* in the several special cases, however, we can guarantee consistency.
'* one of this cases is  M>=4  and   constraints  on   the  function  value
'  (AND/OR its derivative) at the interval boundaries.
'* another special case is M>=4  and  ONE  constraint on the function value
'  (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]
'
'Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
'can't solve your task without them. Anything beyond  special  cases  given
'above is not guaranteed and may result in inconsistency.
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DFitHermiteWC(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC() As Double, _
         ByRef YC() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef S As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Call Spline1DFitInternal(1#, X, Y, w, N, XC, YC, DC, K, M, Info, S, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Least squares fitting by cubic spline.
'
'This subroutine is "lightweight" alternative for more complex and feature-
'rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
'about subroutine parameters (we don't duplicate it here because of length)
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DFitCubic(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef S As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Dim i As Long
    Dim w() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim DC() As Long
    If N > 0# Then
        ReDim w(0 To N - 1)
        For i = 0# To N - 1# Step 1
            w(i) = 1#
        Next i
    End If
    Call Spline1DFitCubicWC(X, Y, w, N, XC, YC, DC, 0#, M, Info, S, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Least squares fitting by Hermite spline.
'
'This subroutine is "lightweight" alternative for more complex and feature-
'rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
'more information about subroutine parameters (we don't duplicate  it  here
'because of length).
'
'  -- ALGLIB PROJECT --
'     Copyright 18.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DFitHermite(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef S As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Dim i As Long
    Dim w() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim DC() As Long
    If N > 0# Then
        ReDim w(0 To N - 1)
        For i = 0# To N - 1# Step 1
            w(i) = 1#
        Next i
    End If
    Call Spline1DFitHermiteWC(X, Y, w, N, XC, YC, DC, 0#, M, Info, S, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates the value of the spline at the given point X.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant
'    X   -   point
'
'Result:
'    S(x)
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Spline1DCalc(ByRef c As Spline1DInterpolant, _
         ByVal X As Double) As Double
    Dim Result As Double
    Dim L As Long
    Dim R As Long
    Dim M As Long
    Dim T As Double
    
    '
    ' correct if periodic
    '
    If c.Periodic Then
        Call APPeriodicMap(X, c.X(0#), c.X(c.N - 1#), T)
    End If
    
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 0#
    R = c.N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If c.X(M) >= X Then
            R = M
        Else
            L = M
        End If
    Loop
    
    '
    ' Interpolation
    '
    X = X - c.X(L)
    M = 4# * L
    Result = c.c(M) + X * (c.c(M + 1#) + X * (c.c(M + 2#) + X * c.c(M + 3#)))
    Spline1DCalc = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine differentiates the spline.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    X   -   point
'
'Result:
'    S   -   S(x)
'    DS  -   S'(x)
'    D2S -   S''(x)
'
'  -- ALGLIB PROJECT --
'     Copyright 24.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DDiff(ByRef c As Spline1DInterpolant, _
         ByVal X As Double, _
         ByRef S As Double, _
         ByRef DS As Double, _
         ByRef D2S As Double)
    Dim L As Long
    Dim R As Long
    Dim M As Long
    Dim T As Double
    
    '
    ' correct if periodic
    '
    If c.Periodic Then
        Call APPeriodicMap(X, c.X(0#), c.X(c.N - 1#), T)
    End If
    
    '
    ' Binary search
    '
    L = 0#
    R = c.N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If c.X(M) >= X Then
            R = M
        Else
            L = M
        End If
    Loop
    
    '
    ' Differentiation
    '
    X = X - c.X(L)
    M = 4# * L
    S = c.c(M) + X * (c.c(M + 1#) + X * (c.c(M + 2#) + X * c.c(M + 3#)))
    DS = c.c(M + 1#) + 2# * X * c.c(M + 2#) + 3# * Square(X) * c.c(M + 3#)
    D2S = 2# * c.c(M + 2#) + 6# * X * c.c(M + 3#)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine makes the copy of the spline.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'
'Result:
'    CC  -   spline copy
'
'  -- ALGLIB PROJECT --
'     Copyright 29.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DCopy(ByRef c As Spline1DInterpolant, _
         ByRef CC As Spline1DInterpolant)
    Dim i_ As Long
    CC.Periodic = c.Periodic
    CC.N = c.N
    CC.K = c.K
    ReDim CC.X(0 To CC.N - 1)
    For i_ = 0# To CC.N - 1# Step 1
        CC.X(i_) = c.X(i_)
    Next i_
    ReDim CC.c(0 To (CC.K + 1#) * (CC.N - 1#) - 1)
    For i_ = 0# To (CC.K + 1#) * (CC.N - 1#) - 1# Step 1
        CC.c(i_) = c.c(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine unpacks the spline into the coefficients table.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    X   -   point
'
'Result:
'    Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
'            For I = 0...N-2:
'                Tbl[I,0] = X[i]
'                Tbl[I,1] = X[i+1]
'                Tbl[I,2] = C0
'                Tbl[I,3] = C1
'                Tbl[I,4] = C2
'                Tbl[I,5] = C3
'            On [x[i], x[i+1]] spline is equals to:
'                S(x) = C0 + C1*t + C2*t^2 + C3*t^3
'                t = x-x[i]
'
'  -- ALGLIB PROJECT --
'     Copyright 29.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DUnpack(ByRef c As Spline1DInterpolant, _
         ByRef N As Long, _
         ByRef Tbl() As Double)
    Dim i As Long
    Dim j As Long
    ReDim Tbl(0# To c.N - 2#, 0# To 2# + c.K)
    N = c.N
    
    '
    ' Fill
    '
    For i = 0# To N - 2# Step 1
        Tbl(i, 0#) = c.X(i)
        Tbl(i, 1#) = c.X(i + 1#)
        For j = 0# To c.K Step 1
            Tbl(i, 2# + j) = c.c((c.K + 1#) * i + j)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the spline argument.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    A, B-   transformation coefficients: x = A*t + B
'Result:
'    C   -   transformed spline
'
'  -- ALGLIB PROJECT --
'     Copyright 30.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DLinTransX(ByRef c As Spline1DInterpolant, _
         ByVal A As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim j As Long
    Dim N As Long
    Dim V As Double
    Dim DV As Double
    Dim D2V As Double
    Dim X() As Double
    Dim Y() As Double
    Dim d() As Double
    N = c.N
    
    '
    ' Special case: A=0
    '
    If A = 0# Then
        V = Spline1DCalc(c, B)
        For i = 0# To N - 2# Step 1
            c.c((c.K + 1#) * i) = V
            For j = 1# To c.K Step 1
                c.c((c.K + 1#) * i + j) = 0#
            Next j
        Next i
        Exit Sub
    End If
    
    '
    ' General case: A<>0.
    ' Unpack, X, Y, dY/dX.
    ' Scale and pack again.
    '
    ReDim X(0# To N - 1#)
    ReDim Y(0# To N - 1#)
    ReDim d(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        X(i) = c.X(i)
        Call Spline1DDiff(c, X(i), V, DV, D2V)
        X(i) = (X(i) - B) / A
        Y(i) = V
        d(i) = A * DV
    Next i
    Call Spline1DBuildHermite(X, Y, d, N, c)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the spline.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    A, B-   transformation coefficients: S2(x) = A*S(x) + B
'Result:
'    C   -   transformed spline
'
'  -- ALGLIB PROJECT --
'     Copyright 30.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline1DLinTransY(ByRef c As Spline1DInterpolant, _
         ByVal A As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim j As Long
    Dim N As Long
    N = c.N
    For i = 0# To N - 2# Step 1
        c.c((c.K + 1#) * i) = A * c.c((c.K + 1#) * i) + B
        For j = 1# To c.K Step 1
            c.c((c.K + 1#) * i + j) = A * c.c((c.K + 1#) * i + j)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine integrates the spline.
'
'INPUT PARAMETERS:
'    C   -   spline interpolant.
'    X   -   right bound of the integration interval [a, x],
'            here 'a' denotes min(x[])
'Result:
'    integral(S(t)dt,a,x)
'
'  -- ALGLIB PROJECT --
'     Copyright 23.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Spline1DIntegrate(ByRef c As Spline1DInterpolant, _
         ByVal X As Double) As Double
    Dim Result As Double
    Dim N As Long
    Dim i As Long
    Dim j As Long
    Dim L As Long
    Dim R As Long
    Dim M As Long
    Dim w As Double
    Dim V As Double
    Dim T As Double
    Dim IntAB As Double
    Dim AdditionalTerm As Double
    N = c.N
    
    '
    ' Periodic splines require special treatment. We make
    ' following transformation:
    '
    '     integral(S(t)dt,A,X) = integral(S(t)dt,A,Z)+AdditionalTerm
    '
    ' here X may lie outside of [A,B], Z lies strictly in [A,B],
    ' AdditionalTerm is equals to integral(S(t)dt,A,B) times some
    ' integer number (may be zero).
    '
    If c.Periodic And (X < c.X(0#) Or X > c.X(c.N - 1#)) Then
        
        '
        ' compute integral(S(x)dx,A,B)
        '
        IntAB = 0#
        For i = 0# To c.N - 2# Step 1
            w = c.X(i + 1#) - c.X(i)
            M = (c.K + 1#) * i
            IntAB = IntAB + c.c(M) * w
            V = w
            For j = 1# To c.K Step 1
                V = V * w
                IntAB = IntAB + c.c(M + j) * V / (j + 1#)
            Next j
        Next i
        
        '
        ' map X into [A,B]
        '
        Call APPeriodicMap(X, c.X(0#), c.X(c.N - 1#), T)
        AdditionalTerm = T * IntAB
    Else
        AdditionalTerm = 0#
    End If
    
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 0#
    R = N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If c.X(M) >= X Then
            R = M
        Else
            L = M
        End If
    Loop
    
    '
    ' Integration
    '
    Result = 0#
    For i = 0# To L - 1# Step 1
        w = c.X(i + 1#) - c.X(i)
        M = (c.K + 1#) * i
        Result = Result + c.c(M) * w
        V = w
        For j = 1# To c.K Step 1
            V = V * w
            Result = Result + c.c(M + j) * V / (j + 1#)
        Next j
    Next i
    w = X - c.X(L)
    M = (c.K + 1#) * L
    V = w
    Result = Result + c.c(M) * w
    For j = 1# To c.K Step 1
        V = V * w
        Result = Result + c.c(M + j) * V / (j + 1#)
    Next j
    Result = Result + AdditionalTerm
    Spline1DIntegrate = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal spline fitting subroutine
'
'  -- ALGLIB PROJECT --
'     Copyright 08.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub Spline1DFitInternal(ByVal ST As Long, _
         ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByRef w() As Double, _
         ByVal N As Long, _
         ByRef XC_() As Double, _
         ByRef YC_() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef S As Spline1DInterpolant, _
         ByRef Rep As Spline1DFitReport)
    Dim X() As Double
    Dim Y() As Double
    Dim XC() As Double
    Dim YC() As Double
    Dim FMatrix() As Double
    Dim CMatrix() As Double
    Dim Y2() As Double
    Dim W2() As Double
    Dim SX() As Double
    Dim SY() As Double
    Dim SD() As Double
    Dim Tmp() As Double
    Dim XOriginal() As Double
    Dim YOriginal() As Double
    Dim LRep As LSFitReport
    Dim V0 As Double
    Dim V1 As Double
    Dim V2 As Double
    Dim MX As Double
    Dim S2 As Spline1DInterpolant
    Dim i As Long
    Dim j As Long
    Dim RelCnt As Long
    Dim XA As Double
    Dim XB As Double
    Dim SA As Double
    Dim SB As Double
    Dim BL As Double
    Dim BR As Double
    Dim Decay As Double
    Dim i_ As Long
    X = X_
    Y = y_
    XC = XC_
    YC = YC_
    If ST = 0# And M < 4# Then
        Info = -1#
        Exit Sub
    End If
    If ST = 1# And M < 4# Then
        Info = -1#
        Exit Sub
    End If
    If N < 1# Or K < 0# Or K >= M Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To K - 1# Step 1
        Info = 0#
        If DC(i) < 0# Then
            Info = -1#
        End If
        If DC(i) > 1# Then
            Info = -1#
        End If
        If Info < 0# Then
            Exit Sub
        End If
    Next i
    If ST = 1# And M Mod 2# <> 0# Then
        
        '
        ' Hermite fitter must have even number of basis functions
        '
        Info = -2#
        Exit Sub
    End If
    
    '
    ' weight decay for correct handling of task which becomes
    ' degenerate after constraints are applied
    '
    Decay = 10000# * MachineEpsilon
    
    '
    ' Scale X, Y, XC, YC
    '
    Call LSFitScaleXY(X, Y, N, XC, YC, DC, K, XA, XB, SA, SB, XOriginal, YOriginal)
    
    '
    ' allocate space, initialize:
    ' * SX     -   grid for basis functions
    ' * SY     -   values of basis functions at grid points
    ' * FMatrix-   values of basis functions at X[]
    ' * CMatrix-   values (derivatives) of basis functions at XC[]
    '
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    ReDim FMatrix(0 To N + M - 1, 0 To M - 1)
    If K > 0# Then
        ReDim CMatrix(0 To K - 1, 0 To M + 1# - 1)
    End If
    If ST = 0# Then
        
        '
        ' allocate space for cubic spline
        '
        ReDim SX(0 To M - 2# - 1)
        ReDim SY(0 To M - 2# - 1)
        For j = 0# To M - 2# - 1# Step 1
            SX(j) = 2# * j / (M - 2# - 1#) - 1#
        Next j
    End If
    If ST = 1# Then
        
        '
        ' allocate space for Hermite spline
        '
        ReDim SX(0 To M \ 2# - 1)
        ReDim SY(0 To M \ 2# - 1)
        ReDim SD(0 To M \ 2# - 1)
        For j = 0# To M \ 2# - 1# Step 1
            SX(j) = 2# * j / (M \ 2# - 1#) - 1#
        Next j
    End If
    
    '
    ' Prepare design and constraints matrices:
    ' * fill constraints matrix
    ' * fill first N rows of design matrix with values
    ' * fill next M rows of design matrix with regularizing term
    ' * append M zeros to Y
    ' * append M elements, mean(abs(W)) each, to W
    '
    For j = 0# To M - 1# Step 1
        
        '
        ' prepare Jth basis function
        '
        If ST = 0# Then
            
            '
            ' cubic spline basis
            '
            For i = 0# To M - 2# - 1# Step 1
                SY(i) = 0#
            Next i
            BL = 0#
            BR = 0#
            If j < M - 2# Then
                SY(j) = 1#
            End If
            If j = M - 2# Then
                BL = 1#
            End If
            If j = M - 1# Then
                BR = 1#
            End If
            Call Spline1DBuildCubic(SX, SY, M - 2#, 1#, BL, 1#, BR, S2)
        End If
        If ST = 1# Then
            
            '
            ' Hermite basis
            '
            For i = 0# To M \ 2# - 1# Step 1
                SY(i) = 0#
                SD(i) = 0#
            Next i
            If j Mod 2# = 0# Then
                SY(j \ 2#) = 1#
            Else
                SD(j \ 2#) = 1#
            End If
            Call Spline1DBuildHermite(SX, SY, SD, M \ 2#, S2)
        End If
        
        '
        ' values at X[], XC[]
        '
        For i = 0# To N - 1# Step 1
            FMatrix(i, j) = Spline1DCalc(S2, X(i))
        Next i
        For i = 0# To K - 1# Step 1
            Call Spline1DDiff(S2, XC(i), V0, V1, V2)
            If DC(i) = 0# Then
                CMatrix(i, j) = V0
            End If
            If DC(i) = 1# Then
                CMatrix(i, j) = V1
            End If
            If DC(i) = 2# Then
                CMatrix(i, j) = V2
            End If
        Next i
    Next j
    For i = 0# To K - 1# Step 1
        CMatrix(i, M) = YC(i)
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To M - 1# Step 1
            If i = j Then
                FMatrix(N + i, j) = Decay
            Else
                FMatrix(N + i, j) = 0#
            End If
        Next j
    Next i
    ReDim Y2(0 To N + M - 1)
    ReDim W2(0 To N + M - 1)
    For i_ = 0# To N - 1# Step 1
        Y2(i_) = Y(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        W2(i_) = w(i_)
    Next i_
    MX = 0#
    For i = 0# To N - 1# Step 1
        MX = MX + Abs(w(i))
    Next i
    MX = MX / N
    For i = 0# To M - 1# Step 1
        Y2(N + i) = 0#
        W2(N + i) = MX
    Next i
    
    '
    ' Solve constrained task
    '
    If K > 0# Then
        
        '
        ' solve using regularization
        '
        Call LSFitLinearWC(Y2, W2, FMatrix, CMatrix, N + M, M, K, Info, Tmp, LRep)
    Else
        
        '
        ' no constraints, no regularization needed
        '
        Call LSFitLinearWC(Y, w, FMatrix, CMatrix, N, M, K, Info, Tmp, LRep)
    End If
    If Info < 0# Then
        Exit Sub
    End If
    
    '
    ' Generate spline and scale it
    '
    If ST = 0# Then
        
        '
        ' cubic spline basis
        '
        For i_ = 0# To M - 2# - 1# Step 1
            SY(i_) = Tmp(i_)
        Next i_
        Call Spline1DBuildCubic(SX, SY, M - 2#, 1#, Tmp(M - 2#), 1#, Tmp(M - 1#), S)
    End If
    If ST = 1# Then
        
        '
        ' Hermite basis
        '
        For i = 0# To M \ 2# - 1# Step 1
            SY(i) = Tmp(2# * i)
            SD(i) = Tmp(2# * i + 1#)
        Next i
        Call Spline1DBuildHermite(SX, SY, SD, M \ 2#, S)
    End If
    Call Spline1DLinTransX(S, 2# / (XB - XA), -((XA + XB) / (XB - XA)))
    Call Spline1DLinTransY(S, SB - SA, SA)
    
    '
    ' Scale absolute errors obtained from LSFitLinearW.
    ' Relative error should be calculated separately
    ' (because of shifting/scaling of the task)
    '
    Rep.TaskRCond = LRep.TaskRCond
    Rep.RMSError = LRep.RMSError * (SB - SA)
    Rep.AvgError = LRep.AvgError * (SB - SA)
    Rep.MaxError = LRep.MaxError * (SB - SA)
    Rep.AvgRelError = 0#
    RelCnt = 0#
    For i = 0# To N - 1# Step 1
        If YOriginal(i) <> 0# Then
            Rep.AvgRelError = Rep.AvgRelError + Abs(Spline1DCalc(S, XOriginal(i)) - YOriginal(i)) / Abs(YOriginal(i))
            RelCnt = RelCnt + 1#
        End If
    Next i
    If RelCnt <> 0# Then
        Rep.AvgRelError = Rep.AvgRelError / RelCnt
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Heap sort.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HeapSortPoints(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByVal N As Long)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim T As Long
    Dim Tmp As Double
    Dim IsAscending As Boolean
    Dim IsDescending As Boolean
    
    '
    ' Test for already sorted set
    '
    IsAscending = True
    IsDescending = True
    For i = 1# To N - 1# Step 1
        IsAscending = IsAscending And X(i) > X(i - 1#)
        IsDescending = IsDescending And X(i) < X(i - 1#)
    Next i
    If IsAscending Then
        Exit Sub
    End If
    If IsDescending Then
        For i = 0# To N - 1# Step 1
            j = N - 1# - i
            If j <= i Then
                Exit For
            End If
            Tmp = X(i)
            X(i) = X(j)
            X(j) = Tmp
            Tmp = Y(i)
            Y(i) = Y(j)
            Y(j) = Tmp
        Next i
        Exit Sub
    End If
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    i = 2#
    Do
        T = i
        Do While T <> 1#
            K = T \ 2#
            If X(K - 1#) >= X(T - 1#) Then
                T = 1#
            Else
                Tmp = X(K - 1#)
                X(K - 1#) = X(T - 1#)
                X(T - 1#) = Tmp
                Tmp = Y(K - 1#)
                Y(K - 1#) = Y(T - 1#)
                Y(T - 1#) = Tmp
                T = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        Tmp = X(i)
        X(i) = X(0#)
        X(0#) = Tmp
        Tmp = Y(i)
        Y(i) = Y(0#)
        Y(0#) = Tmp
        T = 1#
        Do While T <> 0#
            K = 2# * T
            If K > i Then
                T = 0#
            Else
                If K < i Then
                    If X(K) > X(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If X(T - 1#) >= X(K - 1#) Then
                    T = 0#
                Else
                    Tmp = X(K - 1#)
                    X(K - 1#) = X(T - 1#)
                    X(T - 1#) = Tmp
                    Tmp = Y(K - 1#)
                    Y(K - 1#) = Y(T - 1#)
                    Y(T - 1#) = Tmp
                    T = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Heap sort.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HeapSortDPoints(ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef d() As Double, _
         ByVal N As Long)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim T As Long
    Dim Tmp As Double
    Dim IsAscending As Boolean
    Dim IsDescending As Boolean
    
    '
    ' Test for already sorted set
    '
    IsAscending = True
    IsDescending = True
    For i = 1# To N - 1# Step 1
        IsAscending = IsAscending And X(i) > X(i - 1#)
        IsDescending = IsDescending And X(i) < X(i - 1#)
    Next i
    If IsAscending Then
        Exit Sub
    End If
    If IsDescending Then
        For i = 0# To N - 1# Step 1
            j = N - 1# - i
            If j <= i Then
                Exit For
            End If
            Tmp = X(i)
            X(i) = X(j)
            X(j) = Tmp
            Tmp = Y(i)
            Y(i) = Y(j)
            Y(j) = Tmp
            Tmp = d(i)
            d(i) = d(j)
            d(j) = Tmp
        Next i
        Exit Sub
    End If
    
    '
    ' Special case: N=1
    '
    If N = 1# Then
        Exit Sub
    End If
    
    '
    ' General case
    '
    i = 2#
    Do
        T = i
        Do While T <> 1#
            K = T \ 2#
            If X(K - 1#) >= X(T - 1#) Then
                T = 1#
            Else
                Tmp = X(K - 1#)
                X(K - 1#) = X(T - 1#)
                X(T - 1#) = Tmp
                Tmp = Y(K - 1#)
                Y(K - 1#) = Y(T - 1#)
                Y(T - 1#) = Tmp
                Tmp = d(K - 1#)
                d(K - 1#) = d(T - 1#)
                d(T - 1#) = Tmp
                T = K
            End If
        Loop
        i = i + 1#
    Loop Until Not i <= N
    i = N - 1#
    Do
        Tmp = X(i)
        X(i) = X(0#)
        X(0#) = Tmp
        Tmp = Y(i)
        Y(i) = Y(0#)
        Y(0#) = Tmp
        Tmp = d(i)
        d(i) = d(0#)
        d(0#) = Tmp
        T = 1#
        Do While T <> 0#
            K = 2# * T
            If K > i Then
                T = 0#
            Else
                If K < i Then
                    If X(K) > X(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If X(T - 1#) >= X(K - 1#) Then
                    T = 0#
                Else
                    Tmp = X(K - 1#)
                    X(K - 1#) = X(T - 1#)
                    X(T - 1#) = Tmp
                    Tmp = Y(K - 1#)
                    Y(K - 1#) = Y(T - 1#)
                    Y(T - 1#) = Tmp
                    Tmp = d(K - 1#)
                    d(K - 1#) = d(T - 1#)
                    d(T - 1#) = Tmp
                    T = K
                End If
            End If
        Loop
        i = i - 1#
    Loop Until Not i >= 1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Tridiagonal solver. Solves
'
'( B[0] C[0]                      )
'( A[1] B[1] C[1]                 )
'(      A[2] B[2] C[2]            )
'(            ..........          ) * X = D
'(            ..........          )
'(           A[N-2] B[N-2] C[N-2] )
'(                  A[N-1] B[N-1] )
'
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SolveTridiagonal(ByRef A_() As Double, _
         ByRef B_() As Double, _
         ByRef C_() As Double, _
         ByRef D_() As Double, _
         ByVal N As Long, _
         ByRef X() As Double)
    Dim A() As Double
    Dim B() As Double
    Dim c() As Double
    Dim d() As Double
    Dim K As Long
    Dim T As Double
    A = A_
    B = B_
    c = C_
    d = D_
    ReDim X(0# To N - 1#)
    A(0#) = 0#
    c(N - 1#) = 0#
    For K = 1# To N - 1# Step 1
        T = A(K) / B(K - 1#)
        B(K) = B(K) - T * c(K - 1#)
        d(K) = d(K) - T * d(K - 1#)
    Next K
    X(N - 1#) = d(N - 1#) / B(N - 1#)
    For K = N - 2# To 0# Step -1
        X(K) = (d(K) - c(K) * X(K + 1#)) / B(K)
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Cyclic tridiagonal solver. Solves
'
'( B[0] C[0]                 A[0] )
'( A[1] B[1] C[1]                 )
'(      A[2] B[2] C[2]            )
'(            ..........          ) * X = D
'(            ..........          )
'(           A[N-2] B[N-2] C[N-2] )
'( C[N-1]           A[N-1] B[N-1] )
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SolveCyclicTridiagonal(ByRef A() As Double, _
         ByRef B_() As Double, _
         ByRef c() As Double, _
         ByRef d() As Double, _
         ByVal N As Long, _
         ByRef X() As Double)
    Dim B() As Double
    Dim K As Long
    Dim T As Double
    Dim alpha As Double
    Dim beta As Double
    Dim Gamma As Double
    Dim Y() As Double
    Dim z() As Double
    Dim U() As Double
    B = B_
    beta = A(0#)
    alpha = c(N - 1#)
    Gamma = -B(0#)
    B(0#) = 2# * B(0#)
    B(N - 1#) = B(N - 1#) - alpha * beta / Gamma
    ReDim U(0 To N - 1)
    For K = 0# To N - 1# Step 1
        U(K) = 0#
    Next K
    U(0#) = Gamma
    U(N - 1#) = alpha
    Call SolveTridiagonal(A, B, c, d, N, Y)
    Call SolveTridiagonal(A, B, c, U, N, z)
    ReDim X(0 To N - 1)
    For K = 0# To N - 1# Step 1
        X(K) = Y(K) - (Y(0#) + beta / Gamma * Y(N - 1#)) / (1# + z(0#) + beta / Gamma * z(N - 1#)) * z(K)
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Three-point differentiation
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function DiffThreePoint(ByVal T As Double, _
         ByVal X0 As Double, _
         ByVal F0 As Double, _
         ByVal X1 As Double, _
         ByVal F1 As Double, _
         ByVal X2 As Double, _
         ByVal F2 As Double) As Double
    Dim Result As Double
    Dim A As Double
    Dim B As Double
    T = T - X0
    X1 = X1 - X0
    X2 = X2 - X0
    A = (F2 - F0 - X2 / X1 * (F1 - F0)) / (Square(X2) - X1 * X2)
    B = (F1 - F0 - A * Square(X1)) / X1
    Result = 2# * A * T + B
    DiffThreePoint = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds bilinear spline coefficients table.
'
'Input parameters:
'    X   -   spline abscissas, array[0..N-1]
'    Y   -   spline ordinates, array[0..M-1]
'    F   -   function values, array[0..M-1,0..N-1]
'    M,N -   grid size, M>=2, N>=2
'
'Output parameters:
'    C   -   spline interpolant
'
'  -- ALGLIB PROJECT --
'     Copyright 05.07.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DBuildBilinear(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByRef F_() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef c As Spline2DInterpolant)
    Dim X() As Double
    Dim Y() As Double
    Dim F() As Double
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim TblSize As Long
    Dim Shift As Long
    Dim T As Double
    Dim DX() As Double
    Dim DY() As Double
    Dim DXY() As Double
    X = X_
    Y = y_
    F = F_
    
    '
    ' Sort points
    '
    For j = 0# To N - 1# Step 1
        K = j
        For i = j + 1# To N - 1# Step 1
            If X(i) < X(K) Then
                K = i
            End If
        Next i
        If K <> j Then
            For i = 0# To M - 1# Step 1
                T = F(i, j)
                F(i, j) = F(i, K)
                F(i, K) = T
            Next i
            T = X(j)
            X(j) = X(K)
            X(K) = T
        End If
    Next j
    For i = 0# To M - 1# Step 1
        K = i
        For j = i + 1# To M - 1# Step 1
            If Y(j) < Y(K) Then
                K = j
            End If
        Next j
        If K <> i Then
            For j = 0# To N - 1# Step 1
                T = F(i, j)
                F(i, j) = F(K, j)
                F(K, j) = T
            Next j
            T = Y(i)
            Y(i) = Y(K)
            Y(K) = T
        End If
    Next i
    
    '
    ' Fill C:
    '  C[0]            -   length(C)
    '  C[1]            -   type(C):
    '                      -1 = bilinear interpolant
    '                      -3 = general cubic spline
    '                           (see BuildBicubicSpline)
    '  C[2]:
    '      N (x count)
    '  C[3]:
    '      M (y count)
    '  C[4]...C[4+N-1]:
    '      x[i], i = 0...N-1
    '  C[4+N]...C[4+N+M-1]:
    '      y[i], i = 0...M-1
    '  C[4+N+M]...C[4+N+M+(N*M-1)]:
    '      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
    '
    c.K = 1#
    TblSize = 4# + N + M + N * M
    ReDim c.c(0# To TblSize - 1#)
    c.c(0#) = TblSize
    c.c(1#) = -1#
    c.c(2#) = N
    c.c(3#) = M
    For i = 0# To N - 1# Step 1
        c.c(4# + i) = X(i)
    Next i
    For i = 0# To M - 1# Step 1
        c.c(4# + N + i) = Y(i)
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            Shift = i * N + j
            c.c(4# + N + M + Shift) = F(i, j)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine builds bicubic spline coefficients table.
'
'Input parameters:
'    X   -   spline abscissas, array[0..N-1]
'    Y   -   spline ordinates, array[0..M-1]
'    F   -   function values, array[0..M-1,0..N-1]
'    M,N -   grid size, M>=2, N>=2
'
'Output parameters:
'    C   -   spline interpolant
'
'  -- ALGLIB PROJECT --
'     Copyright 05.07.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DBuildBicubic(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByRef F_() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef c As Spline2DInterpolant)
    Dim X() As Double
    Dim Y() As Double
    Dim F() As Double
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim TblSize As Long
    Dim Shift As Long
    Dim T As Double
    Dim DX() As Double
    Dim DY() As Double
    Dim DXY() As Double
    X = X_
    Y = y_
    F = F_
    
    '
    ' Sort points
    '
    For j = 0# To N - 1# Step 1
        K = j
        For i = j + 1# To N - 1# Step 1
            If X(i) < X(K) Then
                K = i
            End If
        Next i
        If K <> j Then
            For i = 0# To M - 1# Step 1
                T = F(i, j)
                F(i, j) = F(i, K)
                F(i, K) = T
            Next i
            T = X(j)
            X(j) = X(K)
            X(K) = T
        End If
    Next j
    For i = 0# To M - 1# Step 1
        K = i
        For j = i + 1# To M - 1# Step 1
            If Y(j) < Y(K) Then
                K = j
            End If
        Next j
        If K <> i Then
            For j = 0# To N - 1# Step 1
                T = F(i, j)
                F(i, j) = F(K, j)
                F(K, j) = T
            Next j
            T = Y(i)
            Y(i) = Y(K)
            Y(K) = T
        End If
    Next i
    
    '
    ' Fill C:
    '  C[0]            -   length(C)
    '  C[1]            -   type(C):
    '                      -1 = bilinear interpolant
    '                           (see BuildBilinearInterpolant)
    '                      -3 = general cubic spline
    '  C[2]:
    '      N (x count)
    '  C[3]:
    '      M (y count)
    '  C[4]...C[4+N-1]:
    '      x[i], i = 0...N-1
    '  C[4+N]...C[4+N+M-1]:
    '      y[i], i = 0...M-1
    '  C[4+N+M]...C[4+N+M+(N*M-1)]:
    '      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
    '  C[4+N+M+N*M]...C[4+N+M+(2*N*M-1)]:
    '      df(i,j)/dx table.
    '  C[4+N+M+2*N*M]...C[4+N+M+(3*N*M-1)]:
    '      df(i,j)/dy table.
    '  C[4+N+M+3*N*M]...C[4+N+M+(4*N*M-1)]:
    '      d2f(i,j)/dxdy table.
    '
    c.K = 3#
    TblSize = 4# + N + M + 4# * N * M
    ReDim c.c(0# To TblSize - 1#)
    c.c(0#) = TblSize
    c.c(1#) = -3#
    c.c(2#) = N
    c.c(3#) = M
    For i = 0# To N - 1# Step 1
        c.c(4# + i) = X(i)
    Next i
    For i = 0# To M - 1# Step 1
        c.c(4# + N + i) = Y(i)
    Next i
    Call BicubicCalcDerivatives(F, X, Y, M, N, DX, DY, DXY)
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            Shift = i * N + j
            c.c(4# + N + M + Shift) = F(i, j)
            c.c(4# + N + M + N * M + Shift) = DX(i, j)
            c.c(4# + N + M + 2# * N * M + Shift) = DY(i, j)
            c.c(4# + N + M + 3# * N * M + Shift) = DXY(i, j)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates the value of the bilinear or bicubic spline  at
'the given point X.
'
'Input parameters:
'    C   -   coefficients table.
'            Built by BuildBilinearSpline or BuildBicubicSpline.
'    X, Y-   point
'
'Result:
'    S(x,y)
'
'  -- ALGLIB PROJECT --
'     Copyright 05.07.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function Spline2DCalc(ByRef c As Spline2DInterpolant, _
         ByVal X As Double, _
         ByVal Y As Double) As Double
    Dim Result As Double
    Dim V As Double
    Dim VX As Double
    Dim VY As Double
    Dim VXY As Double
    Call Spline2DDiff(c, X, Y, V, VX, VY, VXY)
    Result = V
    Spline2DCalc = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine calculates the value of the bilinear or bicubic spline  at
'the given point X and its derivatives.
'
'Input parameters:
'    C   -   spline interpolant.
'    X, Y-   point
'
'Output parameters:
'    F   -   S(x,y)
'    FX  -   dS(x,y)/dX
'    FY  -   dS(x,y)/dY
'    FXY -   d2S(x,y)/dXdY
'
'  -- ALGLIB PROJECT --
'     Copyright 05.07.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DDiff(ByRef c As Spline2DInterpolant, _
         ByVal X As Double, _
         ByVal Y As Double, _
         ByRef F As Double, _
         ByRef FX As Double, _
         ByRef FY As Double, _
         ByRef FXY As Double)
    Dim N As Long
    Dim M As Long
    Dim T As Double
    Dim DT As Double
    Dim U As Double
    Dim DU As Double
    Dim IX As Long
    Dim IY As Long
    Dim L As Long
    Dim R As Long
    Dim H As Long
    Dim Shift1 As Long
    Dim S1 As Long
    Dim S2 As Long
    Dim S3 As Long
    Dim S4 As Long
    Dim SF As Long
    Dim SFX As Long
    Dim SFY As Long
    Dim SFXY As Long
    Dim Y1 As Double
    Dim Y2 As Double
    Dim Y3 As Double
    Dim Y4 As Double
    Dim V As Double
    Dim T0 As Double
    Dim T1 As Double
    Dim T2 As Double
    Dim T3 As Double
    Dim U0 As Double
    Dim U1 As Double
    Dim U2 As Double
    Dim U3 As Double
    N = Round(c.c(2#))
    M = Round(c.c(3#))
    
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 4#
    R = 4# + N - 2# + 1#
    Do While L <> R - 1#
        H = (L + R) \ 2#
        If c.c(H) >= X Then
            R = H
        Else
            L = H
        End If
    Loop
    T = (X - c.c(L)) / (c.c(L + 1#) - c.c(L))
    DT = 1# / (c.c(L + 1#) - c.c(L))
    IX = L - 4#
    
    '
    ' Binary search in the [ y[0], ..., y[m-2] ] (y[m-1] is not included)
    '
    L = 4# + N
    R = 4# + N + (M - 2#) + 1#
    Do While L <> R - 1#
        H = (L + R) \ 2#
        If c.c(H) >= Y Then
            R = H
        Else
            L = H
        End If
    Loop
    U = (Y - c.c(L)) / (c.c(L + 1#) - c.c(L))
    DU = 1# / (c.c(L + 1#) - c.c(L))
    IY = L - (4# + N)
    
    '
    ' Prepare F, dF/dX, dF/dY, d2F/dXdY
    '
    F = 0#
    FX = 0#
    FY = 0#
    FXY = 0#
    
    '
    ' Bilinear interpolation
    '
    If Round(c.c(1#)) = -1# Then
        Shift1 = 4# + N + M
        Y1 = c.c(Shift1 + N * IY + IX)
        Y2 = c.c(Shift1 + N * IY + (IX + 1#))
        Y3 = c.c(Shift1 + N * (IY + 1#) + (IX + 1#))
        Y4 = c.c(Shift1 + N * (IY + 1#) + IX)
        F = (1# - T) * (1# - U) * Y1 + T * (1# - U) * Y2 + T * U * Y3 + (1# - T) * U * Y4
        FX = (-((1# - U) * Y1) + (1# - U) * Y2 + U * Y3 - U * Y4) * DT
        FY = (-((1# - T) * Y1) - T * Y2 + T * Y3 + (1# - T) * Y4) * DU
        FXY = (Y1 - Y2 + Y3 - Y4) * DU * DT
        Exit Sub
    End If
    
    '
    ' Bicubic interpolation
    '
    If Round(c.c(1#)) = -3# Then
        
        '
        ' Prepare info
        '
        T0 = 1#
        T1 = T
        T2 = Square(T)
        T3 = T * T2
        U0 = 1#
        U1 = U
        U2 = Square(U)
        U3 = U * U2
        SF = 4# + N + M
        SFX = 4# + N + M + N * M
        SFY = 4# + N + M + 2# * N * M
        SFXY = 4# + N + M + 3# * N * M
        S1 = N * IY + IX
        S2 = N * IY + (IX + 1#)
        S3 = N * (IY + 1#) + (IX + 1#)
        S4 = N * (IY + 1#) + IX
        
        '
        ' Calculate
        '
        V = (1# * c.c(SF + S1))
        F = F + V * T0 * U0
        V = (1# * c.c(SFY + S1) / DU)
        F = F + V * T0 * U1
        FY = FY + 1# * V * T0 * U0 * DU
        V = -(3# * c.c(SF + S1)) + 3# * c.c(SF + S4) - 2# * c.c(SFY + S1) / DU - 1# * c.c(SFY + S4) / DU
        F = F + V * T0 * U2
        FY = FY + 2# * V * T0 * U1 * DU
        V = (2# * c.c(SF + S1)) - 2# * c.c(SF + S4) + 1# * c.c(SFY + S1) / DU + 1# * c.c(SFY + S4) / DU
        F = F + V * T0 * U3
        FY = FY + 3# * V * T0 * U2 * DU
        V = (1# * c.c(SFX + S1) / DT)
        F = F + V * T1 * U0
        FX = FX + 1# * V * T0 * U0 * DT
        V = (1# * c.c(SFXY + S1) / (DT * DU))
        F = F + V * T1 * U1
        FX = FX + 1# * V * T0 * U1 * DT
        FY = FY + 1# * V * T1 * U0 * DU
        FXY = FXY + 1# * V * T0 * U0 * DT * DU
        V = -(3# * c.c(SFX + S1) / DT) + 3# * c.c(SFX + S4) / DT - 2# * c.c(SFXY + S1) / (DT * DU) - 1# * c.c(SFXY + S4) / (DT * DU)
        F = F + V * T1 * U2
        FX = FX + 1# * V * T0 * U2 * DT
        FY = FY + 2# * V * T1 * U1 * DU
        FXY = FXY + 2# * V * T0 * U1 * DT * DU
        V = (2# * c.c(SFX + S1) / DT) - 2# * c.c(SFX + S4) / DT + 1# * c.c(SFXY + S1) / (DT * DU) + 1# * c.c(SFXY + S4) / (DT * DU)
        F = F + V * T1 * U3
        FX = FX + 1# * V * T0 * U3 * DT
        FY = FY + 3# * V * T1 * U2 * DU
        FXY = FXY + 3# * V * T0 * U2 * DT * DU
        V = -(3# * c.c(SF + S1)) + 3# * c.c(SF + S2) - 2# * c.c(SFX + S1) / DT - 1# * c.c(SFX + S2) / DT
        F = F + V * T2 * U0
        FX = FX + 2# * V * T1 * U0 * DT
        V = -(3# * c.c(SFY + S1) / DU) + 3# * c.c(SFY + S2) / DU - 2# * c.c(SFXY + S1) / (DT * DU) - 1# * c.c(SFXY + S2) / (DT * DU)
        F = F + V * T2 * U1
        FX = FX + 2# * V * T1 * U1 * DT
        FY = FY + 1# * V * T2 * U0 * DU
        FXY = FXY + 2# * V * T1 * U0 * DT * DU
        V = (9# * c.c(SF + S1)) - 9# * c.c(SF + S2) + 9# * c.c(SF + S3) - 9# * c.c(SF + S4) + 6# * c.c(SFX + S1) / DT + 3# * c.c(SFX + S2) / DT - 3# * c.c(SFX + S3) / DT - 6# * c.c(SFX + S4) / DT + 6# * c.c(SFY + S1) / DU - 6# * c.c(SFY + S2) / DU - 3# * c.c(SFY + S3) / DU + 3# * c.c(SFY + S4) / DU + 4# * c.c(SFXY + S1) / (DT * DU) + 2# * c.c(SFXY + S2) / (DT * DU) + 1# * c.c(SFXY + S3) / (DT * DU) + 2# * c.c(SFXY + S4) / (DT * DU)
        F = F + V * T2 * U2
        FX = FX + 2# * V * T1 * U2 * DT
        FY = FY + 2# * V * T2 * U1 * DU
        FXY = FXY + 4# * V * T1 * U1 * DT * DU
        V = -(6# * c.c(SF + S1)) + 6# * c.c(SF + S2) - 6# * c.c(SF + S3) + 6# * c.c(SF + S4) - 4# * c.c(SFX + S1) / DT - 2# * c.c(SFX + S2) / DT + 2# * c.c(SFX + S3) / DT + 4# * c.c(SFX + S4) / DT - 3# * c.c(SFY + S1) / DU + 3# * c.c(SFY + S2) / DU + 3# * c.c(SFY + S3) / DU - 3# * c.c(SFY + S4) / DU - 2# * c.c(SFXY + S1) / (DT * DU) - 1# * c.c(SFXY + S2) / (DT * DU) - 1# * c.c(SFXY + S3) / (DT * DU) - 2# * c.c(SFXY + S4) / (DT * DU)
        F = F + V * T2 * U3
        FX = FX + 2# * V * T1 * U3 * DT
        FY = FY + 3# * V * T2 * U2 * DU
        FXY = FXY + 6# * V * T1 * U2 * DT * DU
        V = (2# * c.c(SF + S1)) - 2# * c.c(SF + S2) + 1# * c.c(SFX + S1) / DT + 1# * c.c(SFX + S2) / DT
        F = F + V * T3 * U0
        FX = FX + 3# * V * T2 * U0 * DT
        V = (2# * c.c(SFY + S1) / DU) - 2# * c.c(SFY + S2) / DU + 1# * c.c(SFXY + S1) / (DT * DU) + 1# * c.c(SFXY + S2) / (DT * DU)
        F = F + V * T3 * U1
        FX = FX + 3# * V * T2 * U1 * DT
        FY = FY + 1# * V * T3 * U0 * DU
        FXY = FXY + 3# * V * T2 * U0 * DT * DU
        V = -(6# * c.c(SF + S1)) + 6# * c.c(SF + S2) - 6# * c.c(SF + S3) + 6# * c.c(SF + S4) - 3# * c.c(SFX + S1) / DT - 3# * c.c(SFX + S2) / DT + 3# * c.c(SFX + S3) / DT + 3# * c.c(SFX + S4) / DT - 4# * c.c(SFY + S1) / DU + 4# * c.c(SFY + S2) / DU + 2# * c.c(SFY + S3) / DU - 2# * c.c(SFY + S4) / DU - 2# * c.c(SFXY + S1) / (DT * DU) - 2# * c.c(SFXY + S2) / (DT * DU) - 1# * c.c(SFXY + S3) / (DT * DU) - 1# * c.c(SFXY + S4) / (DT * DU)
        F = F + V * T3 * U2
        FX = FX + 3# * V * T2 * U2 * DT
        FY = FY + 2# * V * T3 * U1 * DU
        FXY = FXY + 6# * V * T2 * U1 * DT * DU
        V = (4# * c.c(SF + S1)) - 4# * c.c(SF + S2) + 4# * c.c(SF + S3) - 4# * c.c(SF + S4) + 2# * c.c(SFX + S1) / DT + 2# * c.c(SFX + S2) / DT - 2# * c.c(SFX + S3) / DT - 2# * c.c(SFX + S4) / DT + 2# * c.c(SFY + S1) / DU - 2# * c.c(SFY + S2) / DU - 2# * c.c(SFY + S3) / DU + 2# * c.c(SFY + S4) / DU + 1# * c.c(SFXY + S1) / (DT * DU) + 1# * c.c(SFXY + S2) / (DT * DU) + 1# * c.c(SFXY + S3) / (DT * DU) + 1# * c.c(SFXY + S4) / (DT * DU)
        F = F + V * T3 * U3
        FX = FX + 3# * V * T2 * U3 * DT
        FY = FY + 3# * V * T3 * U2 * DU
        FXY = FXY + 9# * V * T2 * U2 * DT * DU
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine unpacks two-dimensional spline into the coefficients table
'
'Input parameters:
'    C   -   spline interpolant.
'
'Result:
'    M, N-   grid size (x-axis and y-axis)
'    Tbl -   coefficients table, unpacked format,
'            [0..(N-1)*(M-1)-1, 0..19].
'            For I = 0...M-2, J=0..N-2:
'                K =  I*(N-1)+J
'                Tbl[K,0] = X[j]
'                Tbl[K,1] = X[j+1]
'                Tbl[K,2] = Y[i]
'                Tbl[K,3] = Y[i+1]
'                Tbl[K,4] = C00
'                Tbl[K,5] = C01
'                Tbl[K,6] = C02
'                Tbl[K,7] = C03
'                Tbl[K,8] = C10
'                Tbl[K,9] = C11
'                ...
'                Tbl[K,19] = C33
'            On each grid square spline is equals to:
'                S(x) = SUM(c[i,j]*(x^i)*(y^j), i=0..3, j=0..3)
'                t = x-x[j]
'                u = y-y[i]
'
'  -- ALGLIB PROJECT --
'     Copyright 29.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DUnpack(ByRef c As Spline2DInterpolant, _
         ByRef M As Long, _
         ByRef N As Long, _
         ByRef Tbl() As Double)
    Dim i As Long
    Dim j As Long
    Dim CI As Long
    Dim CJ As Long
    Dim K As Long
    Dim p As Long
    Dim Shift As Long
    Dim S1 As Long
    Dim S2 As Long
    Dim S3 As Long
    Dim S4 As Long
    Dim SF As Long
    Dim SFX As Long
    Dim SFY As Long
    Dim SFXY As Long
    Dim Y1 As Double
    Dim Y2 As Double
    Dim Y3 As Double
    Dim Y4 As Double
    Dim DT As Double
    Dim DU As Double
    N = Round(c.c(2#))
    M = Round(c.c(3#))
    ReDim Tbl(0# To (N - 1#) * (M - 1#) - 1#, 0# To 19#)
    
    '
    ' Fill
    '
    For i = 0# To M - 2# Step 1
        For j = 0# To N - 2# Step 1
            p = i * (N - 1#) + j
            Tbl(p, 0#) = c.c(4# + j)
            Tbl(p, 1#) = c.c(4# + j + 1#)
            Tbl(p, 2#) = c.c(4# + N + i)
            Tbl(p, 3#) = c.c(4# + N + i + 1#)
            DT = 1# / (Tbl(p, 1#) - Tbl(p, 0#))
            DU = 1# / (Tbl(p, 3#) - Tbl(p, 2#))
            
            '
            ' Bilinear interpolation
            '
            If Round(c.c(1#)) = -1# Then
                For K = 4# To 19# Step 1
                    Tbl(p, K) = 0#
                Next K
                Shift = 4# + N + M
                Y1 = c.c(Shift + N * i + j)
                Y2 = c.c(Shift + N * i + (j + 1#))
                Y3 = c.c(Shift + N * (i + 1#) + (j + 1#))
                Y4 = c.c(Shift + N * (i + 1#) + j)
                Tbl(p, 4#) = Y1
                Tbl(p, 4# + 1# * 4# + 0#) = Y2 - Y1
                Tbl(p, 4# + 0# * 4# + 1#) = Y4 - Y1
                Tbl(p, 4# + 1# * 4# + 1#) = Y3 - Y2 - Y4 + Y1
            End If
            
            '
            ' Bicubic interpolation
            '
            If Round(c.c(1#)) = -3# Then
                SF = 4# + N + M
                SFX = 4# + N + M + N * M
                SFY = 4# + N + M + 2# * N * M
                SFXY = 4# + N + M + 3# * N * M
                S1 = N * i + j
                S2 = N * i + (j + 1#)
                S3 = N * (i + 1#) + (j + 1#)
                S4 = N * (i + 1#) + j
                Tbl(p, 4# + 0# * 4# + 0#) = (1# * c.c(SF + S1))
                Tbl(p, 4# + 0# * 4# + 1#) = (1# * c.c(SFY + S1) / DU)
                Tbl(p, 4# + 0# * 4# + 2#) = -(3# * c.c(SF + S1)) + 3# * c.c(SF + S4) - 2# * c.c(SFY + S1) / DU - 1# * c.c(SFY + S4) / DU
                Tbl(p, 4# + 0# * 4# + 3#) = (2# * c.c(SF + S1)) - 2# * c.c(SF + S4) + 1# * c.c(SFY + S1) / DU + 1# * c.c(SFY + S4) / DU
                Tbl(p, 4# + 1# * 4# + 0#) = (1# * c.c(SFX + S1) / DT)
                Tbl(p, 4# + 1# * 4# + 1#) = (1# * c.c(SFXY + S1) / (DT * DU))
                Tbl(p, 4# + 1# * 4# + 2#) = -(3# * c.c(SFX + S1) / DT) + 3# * c.c(SFX + S4) / DT - 2# * c.c(SFXY + S1) / (DT * DU) - 1# * c.c(SFXY + S4) / (DT * DU)
                Tbl(p, 4# + 1# * 4# + 3#) = (2# * c.c(SFX + S1) / DT) - 2# * c.c(SFX + S4) / DT + 1# * c.c(SFXY + S1) / (DT * DU) + 1# * c.c(SFXY + S4) / (DT * DU)
                Tbl(p, 4# + 2# * 4# + 0#) = -(3# * c.c(SF + S1)) + 3# * c.c(SF + S2) - 2# * c.c(SFX + S1) / DT - 1# * c.c(SFX + S2) / DT
                Tbl(p, 4# + 2# * 4# + 1#) = -(3# * c.c(SFY + S1) / DU) + 3# * c.c(SFY + S2) / DU - 2# * c.c(SFXY + S1) / (DT * DU) - 1# * c.c(SFXY + S2) / (DT * DU)
                Tbl(p, 4# + 2# * 4# + 2#) = (9# * c.c(SF + S1)) - 9# * c.c(SF + S2) + 9# * c.c(SF + S3) - 9# * c.c(SF + S4) + 6# * c.c(SFX + S1) / DT + 3# * c.c(SFX + S2) / DT - 3# * c.c(SFX + S3) / DT - 6# * c.c(SFX + S4) / DT + 6# * c.c(SFY + S1) / DU - 6# * c.c(SFY + S2) / DU - 3# * c.c(SFY + S3) / DU + 3# * c.c(SFY + S4) / DU + 4# * c.c(SFXY + S1) / (DT * DU) + 2# * c.c(SFXY + S2) / (DT * DU) + 1# * c.c(SFXY + S3) / (DT * DU) + 2# * c.c(SFXY + S4) / (DT * DU)
                Tbl(p, 4# + 2# * 4# + 3#) = -(6# * c.c(SF + S1)) + 6# * c.c(SF + S2) - 6# * c.c(SF + S3) + 6# * c.c(SF + S4) - 4# * c.c(SFX + S1) / DT - 2# * c.c(SFX + S2) / DT + 2# * c.c(SFX + S3) / DT + 4# * c.c(SFX + S4) / DT - 3# * c.c(SFY + S1) / DU + 3# * c.c(SFY + S2) / DU + 3# * c.c(SFY + S3) / DU - 3# * c.c(SFY + S4) / DU - 2# * c.c(SFXY + S1) / (DT * DU) - 1# * c.c(SFXY + S2) / (DT * DU) - 1# * c.c(SFXY + S3) / (DT * DU) - 2# * c.c(SFXY + S4) / (DT * DU)
                Tbl(p, 4# + 3# * 4# + 0#) = (2# * c.c(SF + S1)) - 2# * c.c(SF + S2) + 1# * c.c(SFX + S1) / DT + 1# * c.c(SFX + S2) / DT
                Tbl(p, 4# + 3# * 4# + 1#) = (2# * c.c(SFY + S1) / DU) - 2# * c.c(SFY + S2) / DU + 1# * c.c(SFXY + S1) / (DT * DU) + 1# * c.c(SFXY + S2) / (DT * DU)
                Tbl(p, 4# + 3# * 4# + 2#) = -(6# * c.c(SF + S1)) + 6# * c.c(SF + S2) - 6# * c.c(SF + S3) + 6# * c.c(SF + S4) - 3# * c.c(SFX + S1) / DT - 3# * c.c(SFX + S2) / DT + 3# * c.c(SFX + S3) / DT + 3# * c.c(SFX + S4) / DT - 4# * c.c(SFY + S1) / DU + 4# * c.c(SFY + S2) / DU + 2# * c.c(SFY + S3) / DU - 2# * c.c(SFY + S4) / DU - 2# * c.c(SFXY + S1) / (DT * DU) - 2# * c.c(SFXY + S2) / (DT * DU) - 1# * c.c(SFXY + S3) / (DT * DU) - 1# * c.c(SFXY + S4) / (DT * DU)
                Tbl(p, 4# + 3# * 4# + 3#) = (4# * c.c(SF + S1)) - 4# * c.c(SF + S2) + 4# * c.c(SF + S3) - 4# * c.c(SF + S4) + 2# * c.c(SFX + S1) / DT + 2# * c.c(SFX + S2) / DT - 2# * c.c(SFX + S3) / DT - 2# * c.c(SFX + S4) / DT + 2# * c.c(SFY + S1) / DU - 2# * c.c(SFY + S2) / DU - 2# * c.c(SFY + S3) / DU + 2# * c.c(SFY + S4) / DU + 1# * c.c(SFXY + S1) / (DT * DU) + 1# * c.c(SFXY + S2) / (DT * DU) + 1# * c.c(SFXY + S3) / (DT * DU) + 1# * c.c(SFXY + S4) / (DT * DU)
            End If
            
            '
            ' Rescale Cij
            '
            For CI = 0# To 3# Step 1
                For CJ = 0# To 3# Step 1
                    Tbl(p, 4# + CI * 4# + CJ) = Tbl(p, 4# + CI * 4# + CJ) * Power(DT, CI) * Power(DU, CJ)
                Next CJ
            Next CI
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the spline argument.
'
'Input parameters:
'    C       -   spline interpolant
'    AX, BX  -   transformation coefficients: x = A*t + B
'    AY, BY  -   transformation coefficients: y = A*u + B
'Result:
'    C   -   transformed spline
'
'  -- ALGLIB PROJECT --
'     Copyright 30.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DLinTransXY(ByRef c As Spline2DInterpolant, _
         ByVal AX As Double, _
         ByVal BX As Double, _
         ByVal AY As Double, _
         ByVal BY As Double)
    Dim i As Long
    Dim j As Long
    Dim N As Long
    Dim M As Long
    Dim V As Double
    Dim X() As Double
    Dim Y() As Double
    Dim F() As Double
    Dim TypeC As Long
    TypeC = Round(c.c(1#))
    N = Round(c.c(2#))
    M = Round(c.c(3#))
    ReDim X(0# To N - 1#)
    ReDim Y(0# To M - 1#)
    ReDim F(0# To M - 1#, 0# To N - 1#)
    For j = 0# To N - 1# Step 1
        X(j) = c.c(4# + j)
    Next j
    For i = 0# To M - 1# Step 1
        Y(i) = c.c(4# + N + i)
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            F(i, j) = c.c(4# + N + M + i * N + j)
        Next j
    Next i
    
    '
    ' Special case: AX=0 or AY=0
    '
    If AX = 0# Then
        For i = 0# To M - 1# Step 1
            V = Spline2DCalc(c, BX, Y(i))
            For j = 0# To N - 1# Step 1
                F(i, j) = V
            Next j
        Next i
        If TypeC = -3# Then
            Call Spline2DBuildBicubic(X, Y, F, M, N, c)
        End If
        If TypeC = -1# Then
            Call Spline2DBuildBilinear(X, Y, F, M, N, c)
        End If
        AX = 1#
        BX = 0#
    End If
    If AY = 0# Then
        For j = 0# To N - 1# Step 1
            V = Spline2DCalc(c, X(j), BY)
            For i = 0# To M - 1# Step 1
                F(i, j) = V
            Next i
        Next j
        If TypeC = -3# Then
            Call Spline2DBuildBicubic(X, Y, F, M, N, c)
        End If
        If TypeC = -1# Then
            Call Spline2DBuildBilinear(X, Y, F, M, N, c)
        End If
        AY = 1#
        BY = 0#
    End If
    
    '
    ' General case: AX<>0, AY<>0
    ' Unpack, scale and pack again.
    '
    For j = 0# To N - 1# Step 1
        X(j) = (X(j) - BX) / AX
    Next j
    For i = 0# To M - 1# Step 1
        Y(i) = (Y(i) - BY) / AY
    Next i
    If TypeC = -3# Then
        Call Spline2DBuildBicubic(X, Y, F, M, N, c)
    End If
    If TypeC = -1# Then
        Call Spline2DBuildBilinear(X, Y, F, M, N, c)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine performs linear transformation of the spline.
'
'Input parameters:
'    C   -   spline interpolant.
'    A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B
'
'Output parameters:
'    C   -   transformed spline
'
'  -- ALGLIB PROJECT --
'     Copyright 30.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DLinTransF(ByRef c As Spline2DInterpolant, _
         ByVal A As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim j As Long
    Dim N As Long
    Dim M As Long
    Dim X() As Double
    Dim Y() As Double
    Dim F() As Double
    Dim TypeC As Long
    TypeC = Round(c.c(1#))
    N = Round(c.c(2#))
    M = Round(c.c(3#))
    ReDim X(0# To N - 1#)
    ReDim Y(0# To M - 1#)
    ReDim F(0# To M - 1#, 0# To N - 1#)
    For j = 0# To N - 1# Step 1
        X(j) = c.c(4# + j)
    Next j
    For i = 0# To M - 1# Step 1
        Y(i) = c.c(4# + N + i)
    Next i
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            F(i, j) = A * c.c(4# + N + M + i * N + j) + B
        Next j
    Next i
    If TypeC = -3# Then
        Call Spline2DBuildBicubic(X, Y, F, M, N, c)
    End If
    If TypeC = -1# Then
        Call Spline2DBuildBilinear(X, Y, F, M, N, c)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine makes the copy of the spline model.
'
'Input parameters:
'    C   -   spline interpolant
'
'Output parameters:
'    CC  -   spline copy
'
'  -- ALGLIB PROJECT --
'     Copyright 29.06.2007 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DCopy(ByRef c As Spline2DInterpolant, _
         ByRef CC As Spline2DInterpolant)
    Dim N As Long
    Dim i_ As Long
    CC.K = c.K
    N = Round(c.c(0#))
    ReDim CC.c(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        CC.c(i_) = c.c(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Serialization of the spline interpolant
'
'INPUT PARAMETERS:
'    B   -   spline interpolant
'
'OUTPUT PARAMETERS:
'    RA      -   array of real numbers which contains interpolant,
'                array[0..RLen-1]
'    RLen    -   RA lenght
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DSerialize(ByRef c As Spline2DInterpolant, _
         ByRef RA() As Double, _
         ByRef RALen As Long)
    Dim CLen As Long
    Dim i_ As Long
    Dim i1_ As Long
    CLen = Round(c.c(0#))
    RALen = 3# + CLen
    ReDim RA(0 To RALen - 1)
    RA(0#) = RALen
    RA(1#) = Spline2DVNum
    RA(2#) = c.K
    i1_ = (0#) - (3#)
    For i_ = 3# To 3# + CLen - 1# Step 1
        RA(i_) = c.c(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unserialization of the spline interpolant
'
'INPUT PARAMETERS:
'    RA  -   array of real numbers which contains interpolant,
'
'OUTPUT PARAMETERS:
'    B   -   spline interpolant
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DUnserialize(ByRef RA() As Double, _
         ByRef c As Spline2DInterpolant)
    Dim CLen As Long
    Dim i_ As Long
    Dim i1_ As Long
    c.K = Round(RA(2#))
    CLen = Round(RA(3#))
    ReDim c.c(0 To CLen - 1)
    i1_ = (3#) - (0#)
    For i_ = 0# To CLen - 1# Step 1
        c.c(i_) = RA(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bicubic spline resampling
'
'Input parameters:
'    A           -   function values at the old grid,
'                    array[0..OldHeight-1, 0..OldWidth-1]
'    OldHeight   -   old grid height, OldHeight>1
'    OldWidth    -   old grid width, OldWidth>1
'    NewHeight   -   new grid height, NewHeight>1
'    NewWidth    -   new grid width, NewWidth>1
'
'Output parameters:
'    B           -   function values at the new grid,
'                    array[0..NewHeight-1, 0..NewWidth-1]
'
'  -- ALGLIB routine --
'     15 May, 2007
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DResampleBicubic(ByRef A() As Double, _
         ByVal OldHeight As Long, _
         ByVal OldWidth As Long, _
         ByRef B() As Double, _
         ByVal NewHeight As Long, _
         ByVal NewWidth As Long)
    Dim Buf() As Double
    Dim X() As Double
    Dim Y() As Double
    Dim c As Spline1DInterpolant
    Dim i As Long
    Dim j As Long
    Dim MW As Long
    Dim MH As Long
    
    '
    ' Prepare
    '
    MW = MaxInt(OldWidth, NewWidth)
    MH = MaxInt(OldHeight, NewHeight)
    ReDim B(0# To NewHeight - 1#, 0# To NewWidth - 1#)
    ReDim Buf(0# To OldHeight - 1#, 0# To NewWidth - 1#)
    ReDim X(0# To MaxInt(MW, MH) - 1#)
    ReDim Y(0# To MaxInt(MW, MH) - 1#)
    
    '
    ' Horizontal interpolation
    '
    For i = 0# To OldHeight - 1# Step 1
        
        '
        ' Fill X, Y
        '
        For j = 0# To OldWidth - 1# Step 1
            X(j) = j / (OldWidth - 1#)
            Y(j) = A(i, j)
        Next j
        
        '
        ' Interpolate and place result into temporary matrix
        '
        Call Spline1DBuildCubic(X, Y, OldWidth, 0#, 0#, 0#, 0#, c)
        For j = 0# To NewWidth - 1# Step 1
            Buf(i, j) = Spline1DCalc(c, j / (NewWidth - 1#))
        Next j
    Next i
    
    '
    ' Vertical interpolation
    '
    For j = 0# To NewWidth - 1# Step 1
        
        '
        ' Fill X, Y
        '
        For i = 0# To OldHeight - 1# Step 1
            X(i) = i / (OldHeight - 1#)
            Y(i) = Buf(i, j)
        Next i
        
        '
        ' Interpolate and place result into B
        '
        Call Spline1DBuildCubic(X, Y, OldHeight, 0#, 0#, 0#, 0#, c)
        For i = 0# To NewHeight - 1# Step 1
            B(i, j) = Spline1DCalc(c, i / (NewHeight - 1#))
        Next i
    Next j
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Bilinear spline resampling
'
'Input parameters:
'    A           -   function values at the old grid,
'                    array[0..OldHeight-1, 0..OldWidth-1]
'    OldHeight   -   old grid height, OldHeight>1
'    OldWidth    -   old grid width, OldWidth>1
'    NewHeight   -   new grid height, NewHeight>1
'    NewWidth    -   new grid width, NewWidth>1
'
'Output parameters:
'    B           -   function values at the new grid,
'                    array[0..NewHeight-1, 0..NewWidth-1]
'
'  -- ALGLIB routine --
'     09.07.2007
'     Copyright by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub Spline2DResampleBilinear(ByRef A() As Double, _
         ByVal OldHeight As Long, _
         ByVal OldWidth As Long, _
         ByRef B() As Double, _
         ByVal NewHeight As Long, _
         ByVal NewWidth As Long)
    Dim i As Long
    Dim j As Long
    Dim L As Long
    Dim c As Long
    Dim T As Double
    Dim U As Double
    ReDim B(0# To NewHeight - 1#, 0# To NewWidth - 1#)
    For i = 0# To NewHeight - 1# Step 1
        For j = 0# To NewWidth - 1# Step 1
            L = i * (OldHeight - 1#) \ (NewHeight - 1#)
            If L = OldHeight - 1# Then
                L = OldHeight - 2#
            End If
            U = i / (NewHeight - 1#) * (OldHeight - 1#) - L
            c = j * (OldWidth - 1#) \ (NewWidth - 1#)
            If c = OldWidth - 1# Then
                c = OldWidth - 2#
            End If
            T = j * (OldWidth - 1#) / (NewWidth - 1#) - c
            B(i, j) = (1# - T) * (1# - U) * A(L, c) + T * (1# - U) * A(L, c + 1#) + T * U * A(L + 1#, c + 1#) + (1# - T) * U * A(L + 1#, c)
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine.
'Calculation of the first derivatives and the cross-derivative.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub BicubicCalcDerivatives(ByRef A() As Double, _
         ByRef X() As Double, _
         ByRef Y() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef DX() As Double, _
         ByRef DY() As Double, _
         ByRef DXY() As Double)
    Dim i As Long
    Dim j As Long
    Dim XT() As Double
    Dim FT() As Double
    Dim c() As Double
    Dim S As Double
    Dim DS As Double
    Dim D2S As Double
    ReDim DX(0# To M - 1#, 0# To N - 1#)
    ReDim DY(0# To M - 1#, 0# To N - 1#)
    ReDim DXY(0# To M - 1#, 0# To N - 1#)
    
    '
    ' dF/dX
    '
    ReDim XT(0# To N - 1#)
    ReDim FT(0# To N - 1#)
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            XT(j) = X(j)
            FT(j) = A(i, j)
        Next j
        Call BuildCubicSpline(XT, FT, N, 0#, 0#, 0#, 0#, c)
        For j = 0# To N - 1# Step 1
            Call SplineDifferentiation(c, X(j), S, DS, D2S)
            DX(i, j) = DS
        Next j
    Next i
    
    '
    ' dF/dY
    '
    ReDim XT(0# To M - 1#)
    ReDim FT(0# To M - 1#)
    For j = 0# To N - 1# Step 1
        For i = 0# To M - 1# Step 1
            XT(i) = Y(i)
            FT(i) = A(i, j)
        Next i
        Call BuildCubicSpline(XT, FT, M, 0#, 0#, 0#, 0#, c)
        For i = 0# To M - 1# Step 1
            Call SplineDifferentiation(c, Y(i), S, DS, D2S)
            DY(i, j) = DS
        Next i
    Next j
    
    '
    ' d2F/dXdY
    '
    ReDim XT(0# To N - 1#)
    ReDim FT(0# To N - 1#)
    For i = 0# To M - 1# Step 1
        For j = 0# To N - 1# Step 1
            XT(j) = X(j)
            FT(j) = DY(i, j)
        Next j
        Call BuildCubicSpline(XT, FT, N, 0#, 0#, 0#, 0#, c)
        For j = 0# To N - 1# Step 1
            Call SplineDifferentiation(c, X(j), S, DS, D2S)
            DXY(i, j) = DS
        Next j
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub BuildLinearSpline(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByRef c() As Double)
    Dim X() As Double
    Dim Y() As Double
    Dim i As Long
    Dim TblSize As Long
    X = X_
    Y = y_
    '
    ' Sort points
    '
    Call HeapSortPoints(X, Y, N)
    '
    ' Fill C:
    '  C[0]            -   length(C)
    '  C[1]            -   type(C):
    '                      3 - general cubic spline
    '  C[2]            -   N
    '  C[3]...C[3+N-1] -   x[i], i = 0...N-1
    '  C[3+N]...C[3+N+(N-1)*4-1] - coefficients table
    '
    TblSize = 3# + N + (N - 1#) * 4#
    ReDim c(0# To TblSize - 1#)
    c(0#) = TblSize
    c(1#) = 3#
    c(2#) = N
    For i = 0# To N - 1# Step 1
        c(3# + i) = X(i)
    Next i
    For i = 0# To N - 2# Step 1
        c(3# + N + 4# * i + 0#) = Y(i)
        c(3# + N + 4# * i + 1#) = (Y(i + 1#) - Y(i)) / (X(i + 1#) - X(i))
        c(3# + N + 4# * i + 2#) = 0#
        c(3# + N + 4# * i + 3#) = 0#
    Next i
End Sub
Public Sub BuildCubicSpline(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByVal BoundLType As Long, _
         ByVal BoundL As Double, _
         ByVal BoundRType As Long, _
         ByVal BoundR As Double, _
         ByRef c() As Double)
    Dim X() As Double
    Dim Y() As Double
    Dim a1() As Double
    Dim a2() As Double
    Dim a3() As Double
    Dim B() As Double
    Dim d() As Double
    Dim i As Long
    Dim TblSize As Long
    Dim Delta As Double
    Dim Delta2 As Double
    Dim Delta3 As Double
    X = X_
    Y = y_
    ReDim a1(0# To N - 1#)
    ReDim a2(0# To N - 1#)
    ReDim a3(0# To N - 1#)
    ReDim B(0# To N - 1#)
    '
    ' Special case:
    ' * N=2
    ' * parabolic terminated boundary condition on both ends
    '
    If N = 2# And BoundLType = 0# And BoundRType = 0# Then
        '
        ' Change task type
        '
        BoundLType = 2#
        BoundL = 0#
        BoundRType = 2#
        BoundR = 0#
    End If
    '
    '
    ' Sort points
    '
    Call HeapSortPoints(X, Y, N)
    '
    ' Left boundary conditions
    '
    If BoundLType = 0# Then
        a1(0#) = 0#
        a2(0#) = 1#
        a3(0#) = 1#
        B(0#) = 2# * (Y(1#) - Y(0#)) / (X(1#) - X(0#))
    End If
    If BoundLType = 1# Then
        a1(0#) = 0#
        a2(0#) = 1#
        a3(0#) = 0#
        B(0#) = BoundL
    End If
    If BoundLType = 2# Then
        a1(0#) = 0#
        a2(0#) = 2#
        a3(0#) = 1#
        B(0#) = 3# * (Y(1#) - Y(0#)) / (X(1#) - X(0#)) - 0.5 * BoundL * (X(1#) - X(0#))
    End If
    '
    ' Central conditions
    '
    For i = 1# To N - 2# Step 1
        a1(i) = X(i + 1#) - X(i)
        a2(i) = 2# * (X(i + 1#) - X(i - 1#))
        a3(i) = X(i) - X(i - 1#)
        B(i) = 3# * (Y(i) - Y(i - 1#)) / (X(i) - X(i - 1#)) * (X(i + 1#) - X(i)) + 3# * (Y(i + 1#) - Y(i)) / (X(i + 1#) - X(i)) * (X(i) - X(i - 1#))
    Next i
    '
    ' Right boundary conditions
    '
    If BoundRType = 0# Then
        a1(N - 1#) = 1#
        a2(N - 1#) = 1#
        a3(N - 1#) = 0#
        B(N - 1#) = 2# * (Y(N - 1#) - Y(N - 2#)) / (X(N - 1#) - X(N - 2#))
    End If
    If BoundRType = 1# Then
        a1(N - 1#) = 0#
        a2(N - 1#) = 1#
        a3(N - 1#) = 0#
        B(N - 1#) = BoundR
    End If
    If BoundRType = 2# Then
        a1(N - 1#) = 1#
        a2(N - 1#) = 2#
        a3(N - 1#) = 0#
        B(N - 1#) = 3# * (Y(N - 1#) - Y(N - 2#)) / (X(N - 1#) - X(N - 2#)) + 0.5 * BoundR * (X(N - 1#) - X(N - 2#))
    End If
    '
    ' Solve
    '
    Call SolveTridiagonal(a1, a2, a3, B, N, d)
    '
    ' Now problem is reduced to the cubic Hermite spline
    '
    Call BuildHermiteSpline(X, Y, d, N, c)
End Sub
Public Sub BuildHermiteSpline(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByRef D_() As Double, _
         ByVal N As Long, _
         ByRef c() As Double)
    Dim X() As Double
    Dim Y() As Double
    Dim d() As Double
    Dim i As Long
    Dim TblSize As Long
    Dim Delta As Double
    Dim Delta2 As Double
    Dim Delta3 As Double
    X = X_
    Y = y_
    d = D_
    '
    ' Sort points
    '
    Call HeapSortDPoints(X, Y, d, N)
    '
    ' Fill C:
    '  C[0]            -   length(C)
    '  C[1]            -   type(C):
    '                      3 - general cubic spline
    '  C[2]            -   N
    '  C[3]...C[3+N-1] -   x[i], i = 0...N-1
    '  C[3+N]...C[3+N+(N-1)*4-1] - coefficients table
    '
    TblSize = 3# + N + (N - 1#) * 4#
    ReDim c(0# To TblSize - 1#)
    c(0#) = TblSize
    c(1#) = 3#
    c(2#) = N
    For i = 0# To N - 1# Step 1
        c(3# + i) = X(i)
    Next i
    For i = 0# To N - 2# Step 1
        Delta = X(i + 1#) - X(i)
        Delta2 = Square(Delta)
        Delta3 = Delta * Delta2
        c(3# + N + 4# * i + 0#) = Y(i)
        c(3# + N + 4# * i + 1#) = d(i)
        c(3# + N + 4# * i + 2#) = (3# * (Y(i + 1#) - Y(i)) - 2# * d(i) * Delta - d(i + 1#) * Delta) / Delta2
        c(3# + N + 4# * i + 3#) = (2# * (Y(i) - Y(i + 1#)) + d(i) * Delta + d(i + 1#) * Delta) / Delta3
    Next i
End Sub
Public Sub BuildAkimaSpline(ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByVal N As Long, _
         ByRef c() As Double)
    Dim X() As Double
    Dim Y() As Double
    Dim i As Long
    Dim d() As Double
    Dim w() As Double
    Dim Diff() As Double
    X = X_
    Y = y_
    '
    ' Sort points
    '
    Call HeapSortPoints(X, Y, N)
    '
    ' Prepare W (weights), Diff (divided differences)
    '
    ReDim w(1# To N - 2#)
    ReDim Diff(0# To N - 2#)
    For i = 0# To N - 2# Step 1
        Diff(i) = (Y(i + 1#) - Y(i)) / (X(i + 1#) - X(i))
    Next i
    For i = 1# To N - 2# Step 1
        w(i) = Abs(Diff(i) - Diff(i - 1#))
    Next i
    '
    ' Prepare Hermite interpolation scheme
    '
    ReDim d(0# To N - 1#)
    For i = 2# To N - 3# Step 1
        If Abs(w(i - 1#)) + Abs(w(i + 1#)) <> 0# Then
            d(i) = (w(i + 1#) * Diff(i - 1#) + w(i - 1#) * Diff(i)) / (w(i + 1#) + w(i - 1#))
        Else
            d(i) = ((X(i + 1#) - X(i)) * Diff(i - 1#) + (X(i) - X(i - 1#)) * Diff(i)) / (X(i + 1#) - X(i - 1#))
        End If
    Next i
    d(0#) = DiffThreePoint(X(0#), X(0#), Y(0#), X(1#), Y(1#), X(2#), Y(2#))
    d(1#) = DiffThreePoint(X(1#), X(0#), Y(0#), X(1#), Y(1#), X(2#), Y(2#))
    d(N - 2#) = DiffThreePoint(X(N - 2#), X(N - 3#), Y(N - 3#), X(N - 2#), Y(N - 2#), X(N - 1#), Y(N - 1#))
    d(N - 1#) = DiffThreePoint(X(N - 1#), X(N - 3#), Y(N - 3#), X(N - 2#), Y(N - 2#), X(N - 1#), Y(N - 1#))
    '
    ' Build Akima spline using Hermite interpolation scheme
    '
    Call BuildHermiteSpline(X, Y, d, N, c)
End Sub
Public Function SplineInterpolation(ByRef c() As Double, _
         ByVal X As Double) As Double
    Dim Result As Double
    Dim N As Long
    Dim L As Long
    Dim R As Long
    Dim M As Long
    N = Round(c(2#))
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 3#
    R = 3# + N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If c(M) >= X Then
            R = M
        Else
            L = M
        End If
    Loop
    '
    ' Interpolation
    '
    X = X - c(L)
    M = 3# + N + 4# * (L - 3#)
    Result = c(M) + X * (c(M + 1#) + X * (c(M + 2#) + X * c(M + 3#)))
    SplineInterpolation = Result
End Function
Public Sub SplineDifferentiation(ByRef c() As Double, _
         ByVal X As Double, _
         ByRef S As Double, _
         ByRef DS As Double, _
         ByRef D2S As Double)
    Dim N As Long
    Dim L As Long
    Dim R As Long
    Dim M As Long
    N = Round(c(2#))
    '
    ' Binary search
    '
    L = 3#
    R = 3# + N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If c(M) >= X Then
            R = M
        Else
            L = M
        End If
    Loop
    '
    ' Differentiation
    '
    X = X - c(L)
    M = 3# + N + 4# * (L - 3#)
    S = c(M) + X * (c(M + 1#) + X * (c(M + 2#) + X * c(M + 3#)))
    DS = c(M + 1#) + 2# * X * c(M + 2#) + 3# * Square(X) * c(M + 3#)
    D2S = 2# * c(M + 2#) + 6# * X * c(M + 3#)
End Sub
Public Sub SplineCopy(ByRef c() As Double, ByRef CC() As Double)
    Dim S As Long
    Dim i_ As Long
    S = Round(c(0#))
    ReDim CC(0# To S - 1#)
    For i_ = 0# To S - 1# Step 1
        CC(i_) = c(i_)
    Next i_
End Sub
Public Sub SplineUnpack(ByRef c() As Double, _
         ByRef N As Long, _
         ByRef Tbl() As Double)
    Dim i As Long
    N = Round(c(2#))
    ReDim Tbl(0# To N - 2#, 0# To 5#)
    '
    ' Fill
    '
    For i = 0# To N - 2# Step 1
        Tbl(i, 0#) = c(3# + i)
        Tbl(i, 1#) = c(3# + i + 1#)
        Tbl(i, 2#) = c(3# + N + 4# * i)
        Tbl(i, 3#) = c(3# + N + 4# * i + 1#)
        Tbl(i, 4#) = c(3# + N + 4# * i + 2#)
        Tbl(i, 5#) = c(3# + N + 4# * i + 3#)
    Next i
End Sub
Public Sub SplineLinTransX(ByRef c() As Double, _
         ByVal A As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim N As Long
    Dim V As Double
    Dim DV As Double
    Dim D2V As Double
    Dim X() As Double
    Dim Y() As Double
    Dim d() As Double
    N = Round(c(2#))
    '
    ' Special case: A=0
    '
    If A = 0# Then
        V = SplineInterpolation(c, B)
        For i = 0# To N - 2# Step 1
            c(3# + N + 4# * i) = V
            c(3# + N + 4# * i + 1#) = 0#
            c(3# + N + 4# * i + 2#) = 0#
            c(3# + N + 4# * i + 3#) = 0#
        Next i
        Exit Sub
    End If
    '
    ' General case: A<>0.
    ' Unpack, X, Y, dY/dX.
    ' Scale and pack again.
    '
    ReDim X(0# To N - 1#)
    ReDim Y(0# To N - 1#)
    ReDim d(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        X(i) = c(3# + i)
        Call SplineDifferentiation(c, X(i), V, DV, D2V)
        X(i) = (X(i) - B) / A
        Y(i) = V
        d(i) = A * DV
    Next i
    Call BuildHermiteSpline(X, Y, d, N, c)
End Sub
Public Sub SplineLinTransY(ByRef c() As Double, _
         ByVal A As Double, _
         ByVal B As Double)
    Dim i As Long
    Dim N As Long
    Dim V As Double
    Dim DV As Double
    Dim D2V As Double
    Dim X() As Double
    Dim Y() As Double
    Dim d() As Double
    N = Round(c(2#))
    '
    ' Special case: A=0
    '
    For i = 0# To N - 2# Step 1
        c(3# + N + 4# * i) = A * c(3# + N + 4# * i) + B
        c(3# + N + 4# * i + 1#) = A * c(3# + N + 4# * i + 1#)
        c(3# + N + 4# * i + 2#) = A * c(3# + N + 4# * i + 2#)
        c(3# + N + 4# * i + 3#) = A * c(3# + N + 4# * i + 3#)
    Next i
End Sub
Public Function SplineIntegration(ByRef c() As Double, _
         ByVal X As Double) As Double
    Dim Result As Double
    Dim N As Long
    Dim i As Long
    Dim L As Long
    Dim R As Long
    Dim M As Long
    Dim w As Double
    N = Round(c(2#))
    '
    ' Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
    '
    L = 3#
    R = 3# + N - 2# + 1#
    Do While L <> R - 1#
        M = (L + R) \ 2#
        If c(M) >= X Then
            R = M
        Else
            L = M
        End If
    Loop
    '
    ' Integration
    '
    Result = 0#
    For i = 3# To L - 1# Step 1
        w = c(i + 1#) - c(i)
        M = 3# + N + 4# * (i - 3#)
        Result = Result + c(M) * w
        Result = Result + c(M + 1#) * Square(w) / 2#
        Result = Result + c(M + 2#) * Square(w) * w / 3#
        Result = Result + c(M + 3#) * Square(Square(w)) / 4#
    Next i
    w = X - c(L)
    M = 3# + N + 4# * (L - 3#)
    Result = Result + c(M) * w
    Result = Result + c(M + 1#) * Square(w) / 2#
    Result = Result + c(M + 2#) * Square(w) * w / 3#
    Result = Result + c(M + 3#) * Square(Square(w)) / 4#
    SplineIntegration = Result
End Function
Public Sub Spline3BuildTable(ByVal N As Long, _
         ByRef DiffN As Long, _
         ByRef X_() As Double, _
         ByRef y_() As Double, _
         ByRef BoundL As Double, _
         ByRef BoundR As Double, _
         ByRef ctbl() As Double)
    Dim X() As Double
    Dim Y() As Double
    Dim c As Boolean
    Dim E As Long
    Dim G As Long
    Dim Tmp As Double
    Dim nxm1 As Long
    Dim i As Long
    Dim j As Long
    Dim DX As Double
    Dim DXJ As Double
    Dim DYJ As Double
    Dim DXJP1 As Double
    Dim DYJP1 As Double
    Dim DXP As Double
    Dim DYP As Double
    Dim YPPA As Double
    Dim YPPB As Double
    Dim PJ As Double
    Dim b1 As Double
    Dim b2 As Double
    Dim b3 As Double
    Dim b4 As Double
    X = X_
    Y = y_
    N = N - 1#
    G = (N + 1#) \ 2#
    Do
        i = G
        Do
            j = i - G
            c = True
            Do
                If X(j) <= X(j + G) Then
                    c = False
                Else
                    Tmp = X(j)
                    X(j) = X(j + G)
                    X(j + G) = Tmp
                    Tmp = Y(j)
                    Y(j) = Y(j + G)
                    Y(j + G) = Tmp
                End If
                j = j - 1#
            Loop Until Not (j >= 0# And c)
            i = i + 1#
        Loop Until Not i <= N
        G = G \ 2#
    Loop Until Not G > 0#
    ReDim ctbl(0# To 4#, 0# To N)
    N = N + 1#
    If DiffN = 1# Then
        b1 = 1#
        b2 = 6# / (X(1#) - X(0#)) * ((Y(1#) - Y(0#)) / (X(1#) - X(0#)) - BoundL)
        b3 = 1#
        b4 = 6# / (X(N - 1#) - X(N - 2#)) * (BoundR - (Y(N - 1#) - Y(N - 2#)) / (X(N - 1#) - X(N - 2#)))
    Else
        b1 = 0#
        b2 = 2# * BoundL
        b3 = 0#
        b4 = 2# * BoundR
    End If
    nxm1 = N - 1#
    If N >= 2# Then
        If N > 2# Then
            DXJ = X(1#) - X(0#)
            DYJ = Y(1#) - Y(0#)
            j = 2#
            Do While j <= nxm1
                DXJP1 = X(j) - X(j - 1#)
                DYJP1 = Y(j) - Y(j - 1#)
                DXP = DXJ + DXJP1
                ctbl(1#, j - 1#) = DXJP1 / DXP
                ctbl(2#, j - 1#) = 1# - ctbl(1#, j - 1#)
                ctbl(3#, j - 1#) = 6# * (DYJP1 / DXJP1 - DYJ / DXJ) / DXP
                DXJ = DXJP1
                DYJ = DYJP1
                j = j + 1#
            Loop
        End If
        ctbl(1#, 0#) = -(b1 / 2#)
        ctbl(2#, 0#) = b2 / 2#
        If N <> 2# Then
            j = 2#
            Do While j <= nxm1
                PJ = ctbl(2#, j - 1#) * ctbl(1#, j - 2#) + 2#
                ctbl(1#, j - 1#) = -(ctbl(1#, j - 1#) / PJ)
                ctbl(2#, j - 1#) = (ctbl(3#, j - 1#) - ctbl(2#, j - 1#) * ctbl(2#, j - 2#)) / PJ
                j = j + 1#
            Loop
        End If
        YPPB = (b4 - b3 * ctbl(2#, nxm1 - 1#)) / (b3 * ctbl(1#, nxm1 - 1#) + 2#)
        i = 1#
        Do While i <= nxm1
            j = N - i
            YPPA = ctbl(1#, j - 1#) * YPPB + ctbl(2#, j - 1#)
            DX = X(j) - X(j - 1#)
            ctbl(3#, j - 1#) = (YPPB - YPPA) / DX / 6#
            ctbl(2#, j - 1#) = YPPA / 2#
            ctbl(1#, j - 1#) = (Y(j) - Y(j - 1#)) / DX - (ctbl(2#, j - 1#) + ctbl(3#, j - 1#) * DX) * DX
            YPPB = YPPA
            i = i + 1#
        Loop
        For i = 1# To N Step 1
            ctbl(0#, i - 1#) = Y(i - 1#)
            ctbl(4#, i - 1#) = X(i - 1#)
        Next i
    End If
End Sub
Public Function Spline3Interpolate(ByVal N As Long, _
         ByRef c() As Double, _
         ByRef X As Double) As Double
    Dim Result As Double
    Dim i As Long
    Dim L As Long
    Dim Half As Long
    Dim First As Long
    Dim Middle As Long
    N = N - 1#
    L = N
    First = 0#
    Do While L > 0#
        Half = L \ 2#
        Middle = First + Half
        If c(4#, Middle) < X Then
            First = Middle + 1#
            L = L - Half - 1#
        Else
            L = Half
        End If
    Loop
    i = First - 1#
    If i < 0# Then
        i = 0#
    End If
    Result = c(0#, i) + (X - c(4#, i)) * (c(1#, i) + (X - c(4#, i)) * (c(2#, i) + c(3#, i) * (X - c(4#, i))))
    Spline3Interpolate = Result
End Function
'Private Sub HeapSortPoints(ByRef X() As Double, _
'         ByRef y() As Double, _
'         ByVal N As Long)
'    Dim i As Long
'    Dim j As Long
'    Dim K As Long
'    Dim T As Long
'    Dim Tmp As Double
'    Dim IsAscending As Boolean
'    Dim IsDescending As Boolean
'
'
'    '
'    ' Test for already sorted set
'    '
'    IsAscending = True
'    IsDescending = True
'    For i = 1# To N - 1# Step 1
'        IsAscending = IsAscending And X(i) > X(i - 1#)
'        IsDescending = IsDescending And X(i) < X(i - 1#)
'    Next i
'    If IsAscending Then
'        Exit Sub
'    End If
'    If IsDescending Then
'        For i = 0# To N - 1# Step 1
'            j = N - 1# - i
'            If j <= i Then
'                Exit For
'            End If
'            Tmp = X(i)
'            X(i) = X(j)
'            X(j) = Tmp
'            Tmp = y(i)
'            y(i) = y(j)
'            y(j) = Tmp
'        Next i
'        Exit Sub
'    End If
'
'    '
'    ' Special case: N=1
'    '
'    If N = 1# Then
'        Exit Sub
'    End If
'
'    '
'    ' General case
'    '
'    i = 2#
'    Do
'        T = i
'        Do While T <> 1#
'            K = T \ 2#
'            If X(K - 1#) >= X(T - 1#) Then
'                T = 1#
'            Else
'                Tmp = X(K - 1#)
'                X(K - 1#) = X(T - 1#)
'                X(T - 1#) = Tmp
'                Tmp = y(K - 1#)
'                y(K - 1#) = y(T - 1#)
'                y(T - 1#) = Tmp
'                T = K
'            End If
'        Loop
'        i = i + 1#
'    Loop Until Not i <= N
'    i = N - 1#
'    Do
'        Tmp = X(i)
'        X(i) = X(0#)
'        X(0#) = Tmp
'        Tmp = y(i)
'        y(i) = y(0#)
'        y(0#) = Tmp
'        T = 1#
'        Do While T <> 0#
'            K = 2# * T
'            If K > i Then
'                T = 0#
'            Else
'                If K < i Then
'                    If X(K) > X(K - 1#) Then
'                        K = K + 1#
'                    End If
'                End If
'                If X(T - 1#) >= X(K - 1#) Then
'                    T = 0#
'                Else
'                    Tmp = X(K - 1#)
'                    X(K - 1#) = X(T - 1#)
'                    X(T - 1#) = Tmp
'                    Tmp = y(K - 1#)
'                    y(K - 1#) = y(T - 1#)
'                    y(T - 1#) = Tmp
'                    T = K
'                End If
'            End If
'        Loop
'        i = i - 1#
'    Loop Until Not i >= 1#
'End Sub
'
'
'Private Sub HeapSortDPoints(ByRef X() As Double, _
'         ByRef y() As Double, _
'         ByRef D() As Double, _
'         ByVal N As Long)
'    Dim i As Long
'    Dim j As Long
'    Dim K As Long
'    Dim T As Long
'    Dim Tmp As Double
'    Dim IsAscending As Boolean
'    Dim IsDescending As Boolean
'
'
'    '
'    ' Test for already sorted set
'    '
'    IsAscending = True
'    IsDescending = True
'    For i = 1# To N - 1# Step 1
'        IsAscending = IsAscending And X(i) > X(i - 1#)
'        IsDescending = IsDescending And X(i) < X(i - 1#)
'    Next i
'    If IsAscending Then
'        Exit Sub
'    End If
'    If IsDescending Then
'        For i = 0# To N - 1# Step 1
'            j = N - 1# - i
'            If j <= i Then
'                Exit For
'            End If
'            Tmp = X(i)
'            X(i) = X(j)
'            X(j) = Tmp
'            Tmp = y(i)
'            y(i) = y(j)
'            y(j) = Tmp
'            Tmp = D(i)
'            D(i) = D(j)
'            D(j) = Tmp
'        Next i
'        Exit Sub
'    End If
'
'    '
'    ' Special case: N=1
'    '
'    If N = 1# Then
'        Exit Sub
'    End If
'
'    '
'    ' General case
'    '
'    i = 2#
'    Do
'        T = i
'        Do While T <> 1#
'            K = T \ 2#
'            If X(K - 1#) >= X(T - 1#) Then
'                T = 1#
'            Else
'                Tmp = X(K - 1#)
'                X(K - 1#) = X(T - 1#)
'                X(T - 1#) = Tmp
'                Tmp = y(K - 1#)
'                y(K - 1#) = y(T - 1#)
'                y(T - 1#) = Tmp
'                Tmp = D(K - 1#)
'                D(K - 1#) = D(T - 1#)
'                D(T - 1#) = Tmp
'                T = K
'            End If
'        Loop
'        i = i + 1#
'    Loop Until Not i <= N
'    i = N - 1#
'    Do
'        Tmp = X(i)
'        X(i) = X(0#)
'        X(0#) = Tmp
'        Tmp = y(i)
'        y(i) = y(0#)
'        y(0#) = Tmp
'        Tmp = D(i)
'        D(i) = D(0#)
'        D(0#) = Tmp
'        T = 1#
'        Do While T <> 0#
'            K = 2# * T
'            If K > i Then
'                T = 0#
'            Else
'                If K < i Then
'                    If X(K) > X(K - 1#) Then
'                        K = K + 1#
'                    End If
'                End If
'                If X(T - 1#) >= X(K - 1#) Then
'                    T = 0#
'                Else
'                    Tmp = X(K - 1#)
'                    X(K - 1#) = X(T - 1#)
'                    X(T - 1#) = Tmp
'                    Tmp = y(K - 1#)
'                    y(K - 1#) = y(T - 1#)
'                    y(T - 1#) = Tmp
'                    Tmp = D(K - 1#)
'                    D(K - 1#) = D(T - 1#)
'                    D(T - 1#) = Tmp
'                    T = K
'                End If
'            End If
'        Loop
'        i = i - 1#
'    Loop Until Not i >= 1#
'End Sub
'Private Sub SolveTridiagonal(ByRef A_() As Double, _
'         ByRef B_() As Double, _
'         ByRef C_() As Double, _
'         ByRef D_() As Double, _
'         ByVal N As Long, _
'         ByRef X() As Double)
'    Dim A() As Double
'    Dim B() As Double
'    Dim C() As Double
'    Dim D() As Double
'    Dim K As Long
'    Dim T As Double
'    A = A_
'    B = B_
'    C = C_
'    D = D_
'
'    ReDim X(0# To N - 1#)
'    A(0#) = 0#
'    C(N - 1#) = 0#
'    For K = 1# To N - 1# Step 1
'        T = A(K) / B(K - 1#)
'        B(K) = B(K) - T * C(K - 1#)
'        D(K) = D(K) - T * D(K - 1#)
'    Next K
'    X(N - 1#) = D(N - 1#) / B(N - 1#)
'    For K = N - 2# To 0# Step -1
'        X(K) = (D(K) - C(K) * X(K + 1#)) / B(K)
'    Next K
'End Sub
'
'Private Function DiffThreePoint(ByVal T As Double, _
'         ByVal X0 As Double, _
'         ByVal F0 As Double, _
'         ByVal X1 As Double, _
'         ByVal F1 As Double, _
'         ByVal X2 As Double, _
'         ByVal F2 As Double) As Double
'    Dim Result As Double
'    Dim A As Double
'    Dim B As Double
'
'    T = T - X0
'    X1 = X1 - X0
'    X2 = X2 - X0
'    A = (F2 - F0 - X2 / X1 * (F1 - F0)) / (Square(X2) - X1 * X2)
'    B = (F1 - F0 - A * Square(X1)) / X1
'    Result = 2# * A * T + B
'
'    DiffThreePoint = Result
'End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2006-2010, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  builds  non-periodic 2-dimensional parametric spline  which
'starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).
'
'INPUT PARAMETERS:
'    XY  -   points, array[0..N-1,0..1].
'            XY[I,0:1] corresponds to the Ith point.
'            Order of points is important!
'    N   -   points count, N>=5 for Akima splines, N>=2 for other types  of
'            splines.
'    ST  -   spline type:
'            * 0     Akima spline
'            * 1     parabolically terminated Catmull-Rom spline (Tension=0)
'            * 2     parabolically terminated cubic spline
'    PT  -   parameterization type:
'            * 0     uniform
'            * 1     chord length
'            * 2     centripetal
'
'OUTPUT PARAMETERS:
'    P   -   parametric spline interpolant
'
'
'NOTES:
'* this function  assumes  that  there all consequent points  are distinct.
'  I.e. (x0,y0)<>(x1,y1),  (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so on.
'  However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
'  =(x2,y2).
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Build(ByRef XY_() As Double, _
         ByVal N As Long, _
         ByVal ST As Long, _
         ByVal PT As Long, _
         ByRef p As PSpline2Interpolant)
    Dim XY() As Double
    Dim Tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    XY = XY_
    If ST = 0# Then
    Else
    End If
    
    '
    ' Prepare
    '
    p.N = N
    p.Periodic = False
    ReDim Tmp(0 To N - 1)
    
    '
    ' Build parameterization, check that all parameters are distinct
    '
    Call PSpline2Par(XY, N, PT, p.p)
    
    '
    ' Build splines
    '
    If ST = 0# Then
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildAkima(p.p, Tmp, N, p.X)
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildAkima(p.p, Tmp, N, p.Y)
    End If
    If ST = 1# Then
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N, 0#, 0#, p.X)
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N, 0#, 0#, p.Y)
    End If
    If ST = 2# Then
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N, 0#, 0#, 0#, 0#, p.X)
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N, 0#, 0#, 0#, 0#, p.Y)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  builds  non-periodic 3-dimensional parametric spline  which
'starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).
'
'Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
'description here.
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Build(ByRef XY_() As Double, _
         ByVal N As Long, _
         ByVal ST As Long, _
         ByVal PT As Long, _
         ByRef p As PSpline3Interpolant)
    Dim XY() As Double
    Dim Tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    XY = XY_
    If ST = 0# Then
    Else
    End If
    
    '
    ' Prepare
    '
    p.N = N
    p.Periodic = False
    ReDim Tmp(0 To N - 1)
    
    '
    ' Build parameterization, check that all parameters are distinct
    '
    Call PSpline3Par(XY, N, PT, p.p)
    
    '
    ' Build splines
    '
    If ST = 0# Then
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildAkima(p.p, Tmp, N, p.X)
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildAkima(p.p, Tmp, N, p.Y)
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 2#)
        Next i_
        Call Spline1DBuildAkima(p.p, Tmp, N, p.z)
    End If
    If ST = 1# Then
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N, 0#, 0#, p.X)
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N, 0#, 0#, p.Y)
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 2#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N, 0#, 0#, p.z)
    End If
    If ST = 2# Then
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 0#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N, 0#, 0#, 0#, 0#, p.X)
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 1#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N, 0#, 0#, 0#, 0#, p.Y)
        For i_ = 0# To N - 1# Step 1
            Tmp(i_) = XY(i_, 2#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N, 0#, 0#, 0#, 0#, p.z)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This  function  builds  periodic  2-dimensional  parametric  spline  which
'starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
'back to (X[0],Y[0]).
'
'INPUT PARAMETERS:
'    XY  -   points, array[0..N-1,0..1].
'            XY[I,0:1] corresponds to the Ith point.
'            XY[N-1,0:1] must be different from XY[0,0:1].
'            Order of points is important!
'    N   -   points count, N>=3 for other types of splines.
'    ST  -   spline type:
'            * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
'            * 2     cubic spline with cyclic boundary conditions
'    PT  -   parameterization type:
'            * 0     uniform
'            * 1     chord length
'            * 2     centripetal
'
'OUTPUT PARAMETERS:
'    P   -   parametric spline interpolant
'
'
'NOTES:
'* this function  assumes  that there all consequent points  are  distinct.
'  I.e. (x0,y0)<>(x1,y1), (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so  on.
'  However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
'  =(x2,y2).
'* last point of sequence is NOT equal to the first  point.  You  shouldn't
'  make curve "explicitly periodic" by making them equal.
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2BuildPeriodic(ByRef XY_() As Double, _
         ByVal N As Long, _
         ByVal ST As Long, _
         ByVal PT As Long, _
         ByRef p As PSpline2Interpolant)
    Dim XY() As Double
    Dim XYP() As Double
    Dim Tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    XY = XY_
    
    '
    ' Prepare
    '
    p.N = N
    p.Periodic = True
    ReDim Tmp(0 To N + 1# - 1)
    ReDim XYP(0 To N + 1# - 1, 0 To 2# - 1)
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 0#) = XY(i_, 0#)
    Next i_
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 1#) = XY(i_, 1#)
    Next i_
    For i_ = 0# To 1# Step 1
        XYP(N, i_) = XY(0#, i_)
    Next i_
    
    '
    ' Build parameterization, check that all parameters are distinct
    '
    Call PSpline2Par(XYP, N + 1#, PT, p.p)
    
    '
    ' Build splines
    '
    If ST = 1# Then
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 0#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N + 1#, -1#, 0#, p.X)
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 1#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N + 1#, -1#, 0#, p.Y)
    End If
    If ST = 2# Then
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 0#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N + 1#, -1#, 0#, -1#, 0#, p.X)
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 1#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N + 1#, -1#, 0#, -1#, 0#, p.Y)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This  function  builds  periodic  3-dimensional  parametric  spline  which
'starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
'and then back to (X[0],Y[0],Z[0]).
'
'Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
'description here.
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3BuildPeriodic(ByRef XY_() As Double, _
         ByVal N As Long, _
         ByVal ST As Long, _
         ByVal PT As Long, _
         ByRef p As PSpline3Interpolant)
    Dim XY() As Double
    Dim XYP() As Double
    Dim Tmp() As Double
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    XY = XY_
    
    '
    ' Prepare
    '
    p.N = N
    p.Periodic = True
    ReDim Tmp(0 To N + 1# - 1)
    ReDim XYP(0 To N + 1# - 1, 0 To 3# - 1)
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 0#) = XY(i_, 0#)
    Next i_
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 1#) = XY(i_, 1#)
    Next i_
    For i_ = 0# To N - 1# Step 1
        XYP(i_, 2#) = XY(i_, 2#)
    Next i_
    For i_ = 0# To 2# Step 1
        XYP(N, i_) = XY(0#, i_)
    Next i_
    
    '
    ' Build parameterization, check that all parameters are distinct
    '
    Call PSpline3Par(XYP, N + 1#, PT, p.p)
    
    '
    ' Build splines
    '
    If ST = 1# Then
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 0#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N + 1#, -1#, 0#, p.X)
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 1#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N + 1#, -1#, 0#, p.Y)
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 2#)
        Next i_
        Call Spline1DBuildCatmullRom(p.p, Tmp, N + 1#, -1#, 0#, p.z)
    End If
    If ST = 2# Then
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 0#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N + 1#, -1#, 0#, -1#, 0#, p.X)
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 1#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N + 1#, -1#, 0#, -1#, 0#, p.Y)
        For i_ = 0# To N Step 1
            Tmp(i_) = XYP(i_, 2#)
        Next i_
        Call Spline1DBuildCubic(p.p, Tmp, N + 1#, -1#, 0#, -1#, 0#, p.z)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function returns vector of parameter values correspoding to points.
'
'I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
'have
'    (X[0],Y[0]) = PSpline2Calc(P,U[0]),
'    (X[1],Y[1]) = PSpline2Calc(P,U[1]),
'    (X[2],Y[2]) = PSpline2Calc(P,U[2]),
'    ...
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'
'OUTPUT PARAMETERS:
'    N   -   array size
'    T   -   array[0..N-1]
'
'
'NOTES:
'* for non-periodic splines U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]=1
'* for periodic splines     U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]<1
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2ParameterValues(ByRef p As PSpline2Interpolant, _
         ByRef N As Long, _
         ByRef T() As Double)
    Dim i_ As Long
    N = p.N
    ReDim T(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        T(i_) = p.p(i_)
    Next i_
    T(0#) = 0#
    If Not p.Periodic Then
        T(N - 1#) = 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function returns vector of parameter values correspoding to points.
'
'Same as PSpline2ParameterValues(), but for 3D.
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3ParameterValues(ByRef p As PSpline3Interpolant, _
         ByRef N As Long, _
         ByRef T() As Double)
    Dim i_ As Long
    N = p.N
    ReDim T(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        T(i_) = p.p(i_)
    Next i_
    T(0#) = 0#
    If Not p.Periodic Then
        T(N - 1#) = 1#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  the value of the parametric spline for a  given
'value of parameter T
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-position
'    Y   -   Y-position
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Calc(ByRef p As PSpline2Interpolant, _
         ByVal T As Double, _
         ByRef X As Double, _
         ByRef Y As Double)
    If p.Periodic Then
        T = T - Int(T)
    End If
    X = Spline1DCalc(p.X, T)
    Y = Spline1DCalc(p.Y, T)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  the value of the parametric spline for a  given
'value of parameter T.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-position
'    Y   -   Y-position
'    Z   -   Z-position
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Calc(ByRef p As PSpline3Interpolant, _
         ByVal T As Double, _
         ByRef X As Double, _
         ByRef Y As Double, _
         ByRef z As Double)
    If p.Periodic Then
        T = T - Int(T)
    End If
    X = Spline1DCalc(p.X, T)
    Y = Spline1DCalc(p.Y, T)
    z = Spline1DCalc(p.z, T)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  tangent vector for a given value of parameter T
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X    -   X-component of tangent vector (normalized)
'    Y    -   Y-component of tangent vector (normalized)
'
'NOTE:
'    X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Tangent(ByRef p As PSpline2Interpolant, _
         ByVal T As Double, _
         ByRef X As Double, _
         ByRef Y As Double)
    Dim V As Double
    Dim V0 As Double
    Dim V1 As Double
    If p.Periodic Then
        T = T - Int(T)
    End If
    Call PSpline2Diff(p, T, V0, X, V1, Y)
    If X <> 0# Or Y <> 0# Then
        
        '
        ' this code is a bit more complex than X^2+Y^2 to avoid
        ' overflow for large values of X and Y.
        '
        V = SafePythag2(X, Y)
        X = X / V
        Y = Y / V
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  tangent vector for a given value of parameter T
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X    -   X-component of tangent vector (normalized)
'    Y    -   Y-component of tangent vector (normalized)
'    Z    -   Z-component of tangent vector (normalized)
'
'NOTE:
'    X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Tangent(ByRef p As PSpline3Interpolant, _
         ByVal T As Double, _
         ByRef X As Double, _
         ByRef Y As Double, _
         ByRef z As Double)
    Dim V As Double
    Dim V0 As Double
    Dim V1 As Double
    Dim V2 As Double
    If p.Periodic Then
        T = T - Int(T)
    End If
    Call PSpline3Diff(p, T, V0, X, V1, Y, V2, z)
    If X <> 0# Or Y <> 0# Or z <> 0# Then
        V = SafePythag3(X, Y, z)
        X = X / V
        Y = Y / V
        z = z / V
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function calculates derivative, i.e. it returns (dX/dT,dY/dT).
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-value
'    DX  -   X-derivative
'    Y   -   Y-value
'    DY  -   Y-derivative
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Diff(ByRef p As PSpline2Interpolant, _
         ByVal T As Double, _
         ByRef X As Double, _
         ByRef DX As Double, _
         ByRef Y As Double, _
         ByRef DY As Double)
    Dim D2S As Double
    If p.Periodic Then
        T = T - Int(T)
    End If
    Call Spline1DDiff(p.X, T, X, DX, D2S)
    Call Spline1DDiff(p.Y, T, Y, DY, D2S)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-value
'    DX  -   X-derivative
'    Y   -   Y-value
'    DY  -   Y-derivative
'    Z   -   Z-value
'    DZ  -   Z-derivative
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Diff(ByRef p As PSpline3Interpolant, _
         ByVal T As Double, _
         ByRef X As Double, _
         ByRef DX As Double, _
         ByRef Y As Double, _
         ByRef DY As Double, _
         ByRef z As Double, _
         ByRef DZ As Double)
    Dim D2S As Double
    If p.Periodic Then
        T = T - Int(T)
    End If
    Call Spline1DDiff(p.X, T, X, DX, D2S)
    Call Spline1DDiff(p.Y, T, Y, DY, D2S)
    Call Spline1DDiff(p.z, T, z, DZ, D2S)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function calculates first and second derivative with respect to T.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-value
'    DX  -   derivative
'    D2X -   second derivative
'    Y   -   Y-value
'    DY  -   derivative
'    D2Y -   second derivative
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline2Diff2(ByRef p As PSpline2Interpolant, _
         ByVal T As Double, _
         ByRef X As Double, _
         ByRef DX As Double, _
         ByRef D2X As Double, _
         ByRef Y As Double, _
         ByRef DY As Double, _
         ByRef D2Y As Double)
    If p.Periodic Then
        T = T - Int(T)
    End If
    Call Spline1DDiff(p.X, T, X, DX, D2X)
    Call Spline1DDiff(p.Y, T, Y, DY, D2Y)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function calculates first and second derivative with respect to T.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    T   -   point:
'            * T in [0,1] corresponds to interval spanned by points
'            * for non-periodic splines T<0 (or T>1) correspond to parts of
'              the curve before the first (after the last) point
'            * for periodic splines T<0 (or T>1) are projected  into  [0,1]
'              by making T=T-floor(T).
'
'OUTPUT PARAMETERS:
'    X   -   X-value
'    DX  -   derivative
'    D2X -   second derivative
'    Y   -   Y-value
'    DY  -   derivative
'    D2Y -   second derivative
'    Z   -   Z-value
'    DZ  -   derivative
'    D2Z -   second derivative
'
'
'  -- ALGLIB PROJECT --
'     Copyright 28.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub PSpline3Diff2(ByRef p As PSpline3Interpolant, _
         ByVal T As Double, _
         ByRef X As Double, _
         ByRef DX As Double, _
         ByRef D2X As Double, _
         ByRef Y As Double, _
         ByRef DY As Double, _
         ByRef D2Y As Double, _
         ByRef z As Double, _
         ByRef DZ As Double, _
         ByRef D2Z As Double)
    If p.Periodic Then
        T = T - Int(T)
    End If
    Call Spline1DDiff(p.X, T, X, DX, D2X)
    Call Spline1DDiff(p.Y, T, Y, DY, D2Y)
    Call Spline1DDiff(p.z, T, z, DZ, D2Z)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  arc length, i.e. length of  curve  between  t=a
'and t=b.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    A,B -   parameter values corresponding to arc ends:
'            * B>A will result in positive length returned
'            * B<A will result in negative length returned
'
'RESULT:
'    length of arc starting at T=A and ending at T=B.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 30.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PSpline2ArcLength(ByRef p As PSpline2Interpolant, _
         ByVal A As Double, _
         ByVal B As Double) As Double
    Dim Result As Double
    Dim State As AutoGKState
    Dim Rep As AutoGKReport
    Dim SX As Double
    Dim DSX As Double
    Dim D2SX As Double
    Dim SY As Double
    Dim DSY As Double
    Dim D2SY As Double
    Call AutoGKSmooth(A, B, State)
    Do While AutoGKIteration(State)
        Call Spline1DDiff(p.X, State.X, SX, DSX, D2SX)
        Call Spline1DDiff(p.Y, State.X, SY, DSY, D2SY)
        State.F = SafePythag2(DSX, DSY)
    Loop
    Call AutoGKResults(State, Result, Rep)
    PSpline2ArcLength = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function  calculates  arc length, i.e. length of  curve  between  t=a
'and t=b.
'
'INPUT PARAMETERS:
'    P   -   parametric spline interpolant
'    A,B -   parameter values corresponding to arc ends:
'            * B>A will result in positive length returned
'            * B<A will result in negative length returned
'
'RESULT:
'    length of arc starting at T=A and ending at T=B.
'
'
'  -- ALGLIB PROJECT --
'     Copyright 30.05.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function PSpline3ArcLength(ByRef p As PSpline3Interpolant, _
         ByVal A As Double, _
         ByVal B As Double) As Double
    Dim Result As Double
    Dim State As AutoGKState
    Dim Rep As AutoGKReport
    Dim SX As Double
    Dim DSX As Double
    Dim D2SX As Double
    Dim SY As Double
    Dim DSY As Double
    Dim D2SY As Double
    Dim SZ As Double
    Dim DSZ As Double
    Dim D2SZ As Double
    Call AutoGKSmooth(A, B, State)
    Do While AutoGKIteration(State)
        Call Spline1DDiff(p.X, State.X, SX, DSX, D2SX)
        Call Spline1DDiff(p.Y, State.X, SY, DSY, D2SY)
        Call Spline1DDiff(p.z, State.X, SZ, DSZ, D2SZ)
        State.F = SafePythag3(DSX, DSY, DSZ)
    Loop
    Call AutoGKResults(State, Result, Rep)
    PSpline3ArcLength = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Builds non-periodic parameterization for 2-dimensional spline
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub PSpline2Par(ByRef XY() As Double, _
         ByVal N As Long, _
         ByVal PT As Long, _
         ByRef p() As Double)
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    
    '
    ' Build parameterization:
    ' * fill by non-normalized values
    ' * normalize them so we have P[0]=0, P[N-1]=1.
    '
    ReDim p(0 To N - 1)
    If PT = 0# Then
        For i = 0# To N - 1# Step 1
            p(i) = i
        Next i
    End If
    If PT = 1# Then
        p(0#) = 0#
        For i = 1# To N - 1# Step 1
            p(i) = p(i - 1#) + SafePythag2(XY(i, 0#) - XY(i - 1#, 0#), XY(i, 1#) - XY(i - 1#, 1#))
        Next i
    End If
    If PT = 2# Then
        p(0#) = 0#
        For i = 1# To N - 1# Step 1
            p(i) = p(i - 1#) + Sqr(SafePythag2(XY(i, 0#) - XY(i - 1#, 0#), XY(i, 1#) - XY(i - 1#, 1#)))
        Next i
    End If
    V = 1# / p(N - 1#)
    For i_ = 0# To N - 1# Step 1
        p(i_) = V * p(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Builds non-periodic parameterization for 3-dimensional spline
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub PSpline3Par(ByRef XY() As Double, _
         ByVal N As Long, _
         ByVal PT As Long, _
         ByRef p() As Double)
    Dim V As Double
    Dim i As Long
    Dim i_ As Long
    
    '
    ' Build parameterization:
    ' * fill by non-normalized values
    ' * normalize them so we have P[0]=0, P[N-1]=1.
    '
    ReDim p(0 To N - 1)
    If PT = 0# Then
        For i = 0# To N - 1# Step 1
            p(i) = i
        Next i
    End If
    If PT = 1# Then
        p(0#) = 0#
        For i = 1# To N - 1# Step 1
            p(i) = p(i - 1#) + SafePythag3(XY(i, 0#) - XY(i - 1#, 0#), XY(i, 1#) - XY(i - 1#, 1#), XY(i, 2#) - XY(i - 1#, 2#))
        Next i
    End If
    If PT = 2# Then
        p(0#) = 0#
        For i = 1# To N - 1# Step 1
            p(i) = p(i - 1#) + Sqr(SafePythag3(XY(i, 0#) - XY(i - 1#, 0#), XY(i, 1#) - XY(i - 1#, 1#), XY(i, 2#) - XY(i - 1#, 2#)))
        Next i
    End If
    V = 1# / p(N - 1#)
    For i_ = 0# To N - 1# Step 1
        p(i_) = V * p(i_)
    Next i_
End Sub

