'=======================================================================================
'Unifloc 7.39 mu bug fix                              khabibullinra@gmail.com
'Petroleum engineering calculations modules (macroses)
'2000 - 2022
'
'=======================================================================================
'функции для проведения расчетов из интерфейса Excel
'расчет параметров работы скважины с УЭЦН
Option Explicit
'description_to_manual      - для автогенерации
'расчет распределения давления и температуры в скважине
'на основе забойного давления (расчет снизу вверх)
Public Function well_calc_from_pwf(ByVal p_wf_atma As Double, _
                                   ByVal t_wf_C, _
                                   ByVal feed_json As String, _
                                   ByVal construction_json As String, _
                                   ByVal esp_json As String, _
                                   ByVal t_model_json As String, _
                                   ByVal h_perf_m As Double, _
                                   ByVal h_esp_m As Double, _
                          Optional ByVal calibr_grav As Double = 1, _
                          Optional ByVal calibr_fric As Double = 1, _
                          Optional ByVal ksep As Double = 0.5, _
                          Optional ByVal ipr_json As String = "", _
                          Optional ByVal t_crit_C As Double = 0, _
                          Optional ByVal p_cas_atma = 0, _
                          Optional ByVal flow_corr As Integer = 0, _
                          Optional ByVal fast As Boolean = False)
'p_wf_atma - забойное давление
't_wf_C - температура флюида на забое скважины
'feed_json - параметры потока в скважине (с забоя)
'construction_json - конструкция скважины (как для трубы)
'esp_json - параметры ЭЦН, используйте encode_esp_pump
'           если не заданы, то скважина фонтанирующая
't_model_json - температурная модель, рекомендуется модель 2
'h_perf_m - глубина верхних дыр перфорации, точка расчета забойного
'           давления
'h_esp_m - глубина спуска ЭЦН. Длина ЭЦН игнорируется
'          в конструкции диаметры должны учитывать глубину спуска ЭЦН
'calibr_grav - калибровка для гидравлической корреляции по гравитации
'calibr_fric - калибровка для гидравлической корреляции по трению
'ksep - общий коэффициент сепарации газа на приеме ЭЦН
'ipr_json - параметры пласта, используйте encode_ipr
'           если не заданы, считается для постоянного дебита из feed_json
't_crit_C - критическая температура для АСПО
'          в результатах будет вычислена глубина достижения t_crit_C
'p_cas_atma - затрубное давление, если задано будет рассчитан h_dyn_m
'flow_corr - номер гидравлической корреляции, как для трубы
'fast - флаг, если 1 то будет рассчитано только давление,
'       если 0 - то результат json с кривыми
'description_end
On Error GoTo er1:
    Const calc_along_coord = False
    Const flow_along_coord = False
    
    Dim esp As New CESPpump
    Dim pipe_below_esp As New CPipe
    Dim pipe_above_esp As New CPipe
    Dim pipe_casing_liq As New CPipe
    Dim pipe_casing_gas As New CPipe
    Dim ipr_vogel As New CReservoirVogel
    
    Dim res1 As PTtype
    Dim p_intake_atma As Double
    Dim t_intake_C As Double
    Dim p_dis_atma As Double
    Dim t_dis_C As Double
    Dim p_buf_atma As Double
    Dim t_buf_C As Double
    Dim p_res_atma As Double
    Dim pi_m3dayatm As Double
    Dim pb_atma As Double
    Dim fw_perc As Double
    Dim q_liq_sm3day As Double
    
    Dim feed_sep As String
    Dim gas_fraction As Double
    Dim qgas_cas_sm3day As Double
    
    Dim f As Dictionary
    Dim dout As New Dictionary
    
    Dim crv_p As New CInterpolation
    Dim crv_t As New CInterpolation
    Dim crv_cas_p As New CInterpolation
    
    Dim n_sol As Integer
    Dim h_crit
    
' расчет снизу вверх по заданному забойному давлению
    Set f = ParseJson(feed_json)
    q_liq_sm3day = f("q_liq_sm3day")
' 0. если задана IPR  то пытаемся оценить дебит
    If Len(ipr_json) > 0 Then
        Dim d As Dictionary
        Set d = ParseJson(ipr_json)
        p_res_atma = d("p_res_atma")
        pi_m3dayatm = d("pi_m3dayatm")
        pb_atma = d("pb_atma")
        fw_perc = d("fw_perc")
        
        Call ipr_vogel.InitProp(p_res_atma, pb_atma, fw_perc)
        ipr_vogel.pi_sm3dayatm = pi_m3dayatm
        q_liq_sm3day = ipr_vogel.calc_q_liq_sm3day(p_wf_atma)
        
        f("q_liq_sm3day") = q_liq_sm3day
        feed_json = ConvertToJson(f)
        
    End If
' 1. расчет участка э/к от забоя до приема насоса
' инициализируем трубу с первым фидом, который всегда есть
    
    Set pipe_below_esp = new_pipeline_with_feed(construction_json, _
                                                feed_json, _
                                                t_model_json, _
                                                calc_along_coord, _
                                                flow_along_coord, _
                                                flow_corr, _
                                                calibr_grav, _
                                                calibr_fric, _
                                                h_esp_m + 1, h_perf_m)
    If fast Then
        res1 = pipe_below_esp.calc_dPipe(p_wf_atma, t_wf_C, noCurves)
    Else
        res1 = pipe_below_esp.calc_dPipe(p_wf_atma, t_wf_C, mainCurves)
    End If
    p_intake_atma = res1.p_atma
    t_intake_C = res1.t_C
    
    
 
    
    If Len(esp_json) > 1 Then
       ' если данные по ЭЦН есть - пытаемся их анализировать
       ' 2. расчет свойств потока с учетом сепарации газа
       feed_sep = feed_mod_separate_gas(ksep, p_intake_atma, t_intake_C, feed_json)
       gas_fraction = feed_gas_fraction_d(p_intake_atma, t_intake_C, feed_json, ksep)
       qgas_cas_sm3day = feed_q_gas_free_sm3day(p_intake_atma, t_intake_C, feed_json) * ksep
       ' 3. расчет перепада давления в ЭЦН
       Call esp.init_json(esp_json)
       esp.fluid.init_feed (feed_sep)
       Call esp.calc_ESP(p_intake_atma, t_intake_C)
       
       p_dis_atma = esp.p_dis_atma
       t_dis_C = esp.t_dis_C
    Else
        ' если данных по ЭЦН нет - тогда это фонтанирующая скважина
        feed_sep = feed_json
       p_dis_atma = p_intake_atma
       t_dis_C = t_intake_C
    End If
 ' 4. расчет распределения давления в НКТ
    Set pipe_above_esp = new_pipeline_with_feed(construction_json, _
                                                feed_sep, _
                                                t_model_json, _
                                                calc_along_coord, _
                                                flow_along_coord, _
                                                flow_corr, _
                                                calibr_grav, _
                                                calibr_fric, _
                                                0, h_esp_m)
    If fast Then
        res1 = pipe_above_esp.calc_dPipe(p_dis_atma, t_dis_C, noCurves)
    Else
        res1 = pipe_above_esp.calc_dPipe(p_dis_atma, t_dis_C, mainCurves)
    End If
    p_buf_atma = res1.p_atma
    t_buf_C = res1.t_C
    
 ' 5. если задано затрубное давление построим распределение давления в затрубе
    If p_cas_atma > 0 And Not fast And Len(esp_json) > 1 Then
        Set f = ParseJson(feed_sep)
        f("q_gas_free_sm3day") = qgas_cas_sm3day
        feed_sep = ConvertToJson(f)
        Set pipe_casing_liq = new_pipeline_with_feed(construction_json, _
                                                    feed_sep, _
                                                    t_model_json, _
                                                    calc_along_coord, _
                                                    flow_along_coord, _
                                                    flow_corr, _
                                                    calibr_grav, _
                                                    calibr_fric, _
                                                    0, h_esp_m)
        Call pipe_casing_liq.set_ZNLF
        res1 = pipe_casing_liq.calc_dPipe(p_intake_atma, t_intake_C, mainCurves)
        'построим распределение давления для газа
        
        Set pipe_casing_gas = new_pipeline_with_feed(construction_json, _
                                                    feed_sep, _
                                                    t_model_json, _
                                                    Not calc_along_coord, _
                                                    flow_along_coord, _
                                                    10, _
                                                    calibr_grav, _
                                                    calibr_fric, _
                                                    0, h_esp_m)
        res1 = pipe_casing_gas.calc_dPipe(p_cas_atma, t_intake_C, mainCurves)
        
        ' найдем динамический уровень и построим совместное распределения для газа и жидкости
        Dim h_dyn_m As Double
        h_dyn_m = intersection(pipe_casing_liq.curve("c_P"), pipe_casing_gas.curve("c_P"))(1)
        If h_dyn_m < 0 Then h_dyn_m = 0
        Dim i As Integer
        Set crv_cas_p = pipe_casing_liq.curve("c_P")
        For i = 1 To crv_cas_p.num_points
            Call crv_cas_p.AddPoint(h_dyn_m, crv_cas_p.getPoint(h_dyn_m), True)
            If crv_cas_p.pointX(i) < h_dyn_m Then
                Call crv_cas_p.AddPoint(crv_cas_p.pointX(i), pipe_casing_gas.curve("c_P").getPoint(crv_cas_p.pointX(i)))
            End If
        Next i
        
    End If
    
' подготовим кривые для вывода результатов
    If Not fast Then
        Call crv_p.AddPointsCurve(pipe_above_esp.curve("c_P").ClonePointsToNum(25), pipe_below_esp.curve("c_P").ClonePointsToNum(10))
        Call crv_t.AddPointsCurve(pipe_above_esp.curve("c_T").ClonePointsToNum(25), pipe_below_esp.curve("c_T").ClonePointsToNum(10))
        
    
        h_crit = 0
        n_sol = crv_t.FindSolutions(t_crit_C, TS_NO_EXTRPOLATION)
        If n_sol > 0 Then h_crit = crv_t.SolutionPointX(1)
        If t_crit_C > crv_t.maxy Then h_crit = crv_t.maxx
    End If
    
    
    
    If Not fast Then
        
        dout.Add "q_liq_sm3day", q_liq_sm3day
        dout.Add "p_wf_atma", p_wf_atma
        dout.Add "p_intake_atma", p_intake_atma
        dout.Add "p_dis_atma", p_dis_atma
        dout.Add "p_buf_atma", p_buf_atma
        dout.Add "h_crit_m", h_crit
        dout.Add "c_P", crv_p.getDict
        dout.Add "c_T", crv_t.getDict
        If p_cas_atma > 0 Then
            dout.Add "c_cas_P", pipe_casing_liq.curve("c_P").ClonePointsToNum(25).getDict
        End If
        
        dout.Add "h_dyn_m", h_dyn_m
        dout.Add "gas_fraction at pump", gas_fraction
        dout.Add "q_gas_cas_sm3day", qgas_cas_sm3day
        well_calc_from_pwf = ConvertToJson(dout)
    Else
        well_calc_from_pwf = p_buf_atma
    End If
     
    Exit Function
er1:
    well_calc_from_pwf = "error " & Err.Description
 
End Function
' функция расчета ошибки оценки забойного давления
Private Function calc_well_pwf(ByVal p_wf As Double, _
                                   CoeffA As Variant) As Double
   
    
    Dim p_wh_atma As Double
    
    Dim t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, ipr_json, t_crit_C, p_cas_atma, flow_corr
    
    p_wh_atma = CoeffA(0)
    
    t_wf_C = CoeffA(1)
    feed_json = CoeffA(2)
    construction_json = CoeffA(3)
    esp_json = CoeffA(4)
    t_model_json = CoeffA(5)
    h_perf_m = CoeffA(6)
    h_esp_m = CoeffA(7)
    calibr_grav = CoeffA(8)
    calibr_fric = CoeffA(9)
    ksep = CoeffA(10)
    ipr_json = CoeffA(11)
    t_crit_C = CoeffA(12)
    p_cas_atma = CoeffA(13)
    flow_corr = CoeffA(14)
    
    calc_well_pwf = well_calc_from_pwf(p_wf, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, ipr_json, t_crit_C, p_cas_atma, flow_corr, fast:=True) - p_wh_atma
End Function
'description_to_manual      - для автогенерации
'расчет распределения давления и температуры в скважине
'на основе устьевого (буферного) давления (расчет  сверху вниз)
Public Function well_calc_from_pwh(ByVal p_wh_atma As Double, _
                                   ByVal t_wf_C, _
                                   ByVal feed_json As String, _
                                   ByVal construction_json As String, _
                                   ByVal esp_json As String, _
                                   ByVal t_model_json As String, _
                                   ByVal h_perf_m As Double, _
                                   ByVal h_esp_m As Double, _
                          Optional ByVal calibr_grav As Double = 1, _
                          Optional ByVal calibr_fric As Double = 1, _
                          Optional ByVal ksep As Double = 0.5, _
                          Optional ByVal ipr_json As String = "", _
                          Optional ByVal t_crit_C As Double = 0, _
                          Optional ByVal p_cas_atma = 0, _
                          Optional ByVal flow_corr As Integer = 0)
'p_wh_atma - устьевое (буферное) давление
't_wf_C - температура флюида на забое скважины
'feed_json - параметры потока в скважине (с забоя)
'construction_json - конструкция скважины (как для трубы)
'esp_json - параметры ЭЦН, используйте encode_esp_pump
'           если не заданы, то скважина фонтанирующая
't_model_json - температурная модель, рекомендуется модель 2
'h_perf_m - глубина верхних дыр перфорации, точка расчета забойного
'           давления
'h_esp_m - глубина спуска ЭЦН. Длина ЭЦН игнорируется
'          в конструкции диаметры должны учитывать глубину спуска ЭЦН
'calibr_grav - калибровка для гидравлической корреляции по гравитации
'calibr_fric - калибровка для гидравлической корреляции по трению
'ksep - общий коэффициент сепарации газа на приеме ЭЦН
'ipr_json - параметры пласта, используйте encode_ipr
'           если не заданы, считается для постоянного дебита из feed_json
't_crit_C - критическая температура для АСПО
'          в результатах будет вычислена глубина достижения t_crit_C
'p_cas_atma - затрубное давление, если задано будет рассчитан h_dyn_m
'flow_corr - номер гидравлической корреляции, как для трубы
'description_end
        
' расчет сверху вниз по заданному буферному давлению
    Dim p_wf_max As Double
    Dim res As String
    Dim CoeffA(0 To 14)
    Dim prm As New CSolveParam
    Dim i As Integer
On Error GoTo er1:
    p_wf_max = 500
    
' 0. если задана IPR  то пытаемся оценить граничное забойное давление
    If Len(ipr_json) > 0 Then
        Dim d As Dictionary
        Set d = ParseJson(ipr_json)
        p_wf_max = d("p_res_atma")
    End If
        
    
    CoeffA(0) = p_wh_atma
    CoeffA(1) = t_wf_C
    CoeffA(2) = feed_json
    CoeffA(3) = construction_json
    CoeffA(4) = esp_json
    CoeffA(5) = t_model_json
    CoeffA(6) = h_perf_m
    CoeffA(7) = h_esp_m
    CoeffA(8) = calibr_grav
    CoeffA(9) = calibr_fric
    CoeffA(10) = ksep
    CoeffA(11) = ipr_json
    CoeffA(12) = t_crit_C
    CoeffA(13) = p_cas_atma
    CoeffA(14) = flow_corr
    
    prm.y_tolerance = 0.01
    
    If solve_equation_bisection("calc_well_pwf", 1, p_wf_max, CoeffA, prm) Then
        res = well_calc_from_pwf(prm.x_solution, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, ipr_json, t_crit_C, p_cas_atma, flow_corr)
        well_calc_from_pwh = res
    Else
        ' здесь может оказаться, что решениий несколько и надо искать их посреди интервала
        For i = 1 To 10
            If solve_equation_bisection("calc_well_pwf", 1 + (p_wf_max / 10) * (i - 1), 1 + (p_wf_max / 10) * i, CoeffA, prm) Then
                res = well_calc_from_pwf(prm.x_solution, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, ipr_json, t_crit_C, p_cas_atma, flow_corr)
                well_calc_from_pwh = res
                Exit Function
            Else
                well_calc_from_pwh = "not found"
            End If
        Next i
    End If
    Exit Function
er1:
    well_calc_from_pwh = "error" & Err.Description
End Function
Private Function update(json As String, val As Double) As String
    Dim d As Dictionary
 ' оценим границу сверху
    If Len(json) > 0 Then
        Set d = ParseJson(json)
        d("calibr_head") = val
        json = ConvertToJson(d)
    End If
    update = json
End Function
              
Public Function unf_well_calc_pintake_from_pwf( _
                                   ByVal p_wf_atma As Double, _
                                   ByVal t_wf_C, _
                                   ByVal feed_json As String, _
                                   ByVal construction_json As String, _
                                   ByVal t_model_json As String, _
                                   ByVal h_perf_m As Double, _
                                   ByVal h_esp_m As Double, _
                          Optional ByVal calibr_grav As Double = 1, _
                          Optional ByVal calibr_fric As Double = 1, _
                          Optional ByVal ipr_json As String = "", _
                          Optional ByVal flow_corr As Integer = 0)
    Const calc_along_coord = False
    Const flow_along_coord = False
    Dim pipe_below_esp As New CPipe
    Dim ipr_vogel As New CReservoirVogel
    Dim res1 As PTtype
    Dim p_res_atma As Double
    Dim pi_m3dayatm As Double
    Dim pb_atma As Double
    Dim fw_perc As Double
    Dim q_liq_sm3day As Double
    Dim f As Dictionary
    
' расчет снизу вверх по заданному забойному давлению
    Set f = ParseJson(feed_json)
    q_liq_sm3day = f("q_liq_sm3day")
' 0. если задана IPR  то пытаемся оценить дебит
    If Len(ipr_json) > 0 Then
        Dim d As Dictionary
        Set d = ParseJson(ipr_json)
        p_res_atma = d("p_res_atma")
        pi_m3dayatm = d("pi_m3dayatm")
        pb_atma = d("pb_atma")
        fw_perc = d("fw_perc")
        
        Call ipr_vogel.InitProp(p_res_atma, pb_atma, fw_perc)
        ipr_vogel.pi_sm3dayatm = pi_m3dayatm
        q_liq_sm3day = ipr_vogel.calc_q_liq_sm3day(p_wf_atma)
        
        f("q_liq_sm3day") = q_liq_sm3day
        feed_json = ConvertToJson(f)
        
    End If
' 1. расчет участка э/к от забоя до приема насоса
' инициализируем трубу с первым фидом, который всегда есть
    Set pipe_below_esp = new_pipeline_with_feed(construction_json, _
                                                feed_json, _
                                                t_model_json, _
                                                calc_along_coord, _
                                                flow_along_coord, _
                                                flow_corr, _
                                                calibr_grav, _
                                                calibr_fric, _
                                                h_esp_m + 1, h_perf_m)
    
    res1 = pipe_below_esp.calc_dPipe(p_wf_atma, t_wf_C, noCurves)
    unf_well_calc_pintake_from_pwf = res1.p_atma
End Function
              
' функция расчета ошибки оценки забойного давления
Private Function calc_well_pwf_from_pint(ByVal p_wf As Double, _
                                   CoeffA As Variant) As Double
   
    
    Dim p_int_atma As Double
    
    Dim t_wf_C, feed_json, construction_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ipr_json, flow_corr
    
    p_int_atma = CoeffA(0)
    
    t_wf_C = CoeffA(1)
    feed_json = CoeffA(2)
    construction_json = CoeffA(3)
    t_model_json = CoeffA(4)
    h_perf_m = CoeffA(5)
    h_esp_m = CoeffA(6)
    calibr_grav = CoeffA(7)
    calibr_fric = CoeffA(8)
    ipr_json = CoeffA(9)
    flow_corr = CoeffA(10)
    
    Dim res As String
    Dim dres As Dictionary
    
    res = unf_well_calc_pintake_from_pwf(p_wf, t_wf_C, feed_json, construction_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ipr_json, flow_corr)
    
    calc_well_pwf_from_pint = res - p_int_atma
    
    
End Function
              
' функция расчета ошибки оценки забойного давления
Private Function calc_well_calibr_esp(ByVal calibr_esp As Double, _
                                   CoeffA As Variant) As Double
   
    
    Dim p_wh_atma As Double
    
    Dim p_wf_atma, t_wf_C, feed_json, construction_json, esp_json As String, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, ipr_json, t_crit_C, p_cas_atma, flow_corr
    
    p_wh_atma = CoeffA(0)
    
    p_wf_atma = CoeffA(1)
    t_wf_C = CoeffA(2)
    feed_json = CoeffA(3)
    construction_json = CoeffA(4)
    esp_json = CoeffA(5)
    t_model_json = CoeffA(6)
    h_perf_m = CoeffA(7)
    h_esp_m = CoeffA(8)
    calibr_grav = CoeffA(9)
    calibr_fric = CoeffA(10)
    ksep = CoeffA(11)
    ipr_json = CoeffA(12)
    t_crit_C = CoeffA(13)
    p_cas_atma = CoeffA(14)
    flow_corr = CoeffA(15)
    
    esp_json = update(esp_json, calibr_esp)
    
    calc_well_calibr_esp = well_calc_from_pwf(p_wf_atma, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, ipr_json, t_crit_C, p_cas_atma, flow_corr, fast:=True) - p_wh_atma
    
End Function
'description_to_manual      - для автогенерации
'расчет распределения давления и температуры в скважине
'на основе устьевого (буферного) и забойного давления
'модель калибруется деградацией ЭЦН
Public Function well_calc_from_pintake( _
                                   ByVal p_intake_atma As Double, _
                                   ByVal t_wf_C, _
                                   ByVal feed_json As String, _
                                   ByVal construction_json As String, _
                                   ByVal esp_json As String, _
                                   ByVal t_model_json As String, _
                                   ByVal h_perf_m As Double, _
                                   ByVal h_esp_m As Double, _
                          Optional ByVal calibr_grav As Double = 1, _
                          Optional ByVal calibr_fric As Double = 1, _
                          Optional ByVal ksep As Double = 0.5, _
                          Optional ByVal ipr_json As String = "", _
                          Optional ByVal t_crit_C As Double = 0, _
                          Optional ByVal p_cas_atma = 0, _
                          Optional ByVal p_wh_atma As Double = 10, _
                          Optional ByVal flow_corr As Integer = 0)
'p_intake_atma - давление на приеме насоса
't_wf_C - температура флюида на забое скважины
'feed_json - параметры потока в скважине (с забоя)
'construction_json - конструкция скважины (как для трубы)
'esp_json - параметры ЭЦН, используйте encode_esp_pump
'           если не заданы, то скважина фонтанирующая
't_model_json - температурная модель, рекомендуется модель 2
'h_perf_m - глубина верхних дыр перфорации, точка расчета забойного
'           давления
'h_esp_m - глубина спуска ЭЦН. Длина ЭЦН игнорируется
'          в конструкции диаметры должны учитывать глубину спуска ЭЦН
'calibr_grav - калибровка для гидравлической корреляции по гравитации
'calibr_fric - калибровка для гидравлической корреляции по трению
'ksep - общий коэффициент сепарации газа на приеме ЭЦН
'ipr_json - параметры пласта, используйте encode_ipr
'           если не заданы, считается для постоянного дебита из feed_json
't_crit_C - критическая температура для АСПО
'          в результатах будет вычислена глубина достижения t_crit_C
'p_cas_atma - затрубное давление, если задано будет рассчитан h_dyn_m
'p_wh_atma - устьевое (буферное) давление
'flow_corr - номер гидравлической корреляции, как для трубы
'description_end
    
    Dim p_wf_max As Double
    Dim p_wf_atma As Double
    Dim res As String
    Dim dres As Dictionary
    
    Dim CoeffA(0 To 10)
    Dim prm As New CSolveParam
    Dim CoeffB(0 To 15)
    
On Error GoTo er1:
    If Len(esp_json) < 2 Then
        well_calc_from_pintake = "esp data needed"
        Exit Function
    End If
    
    p_wf_max = 300
' 0. если задана IPR  то пытаемся оценить граничное забойное давление
    If Len(ipr_json) > 0 Then
        Dim d As Dictionary
        Set d = ParseJson(ipr_json)
        p_wf_max = d("p_res_atma")
    End If
        
' 1. Оценим давление на забое по известному давлению на приеме
'    чтобы снизить погрешность из за влияния температуры считаем итерациями
'    используя внутри расчет снизу вверх, при котором температура корректно оценивается
    CoeffA(0) = p_intake_atma
    CoeffA(1) = t_wf_C
    CoeffA(2) = feed_json
    CoeffA(3) = construction_json
    CoeffA(4) = t_model_json
    CoeffA(5) = h_perf_m
    CoeffA(6) = h_esp_m
    CoeffA(7) = calibr_grav
    CoeffA(8) = calibr_fric
    CoeffA(9) = ipr_json
    CoeffA(10) = flow_corr
    
    prm.y_tolerance = 0.01
    
    If solve_equation_bisection("calc_well_pwf_from_pint", 1, p_wf_max, CoeffA, prm) Then
        p_wf_atma = prm.x_solution
    Else
        well_calc_from_pintake = "not found"
        Exit Function
    End If
' 2. Далее оцениваем деградацию ЭЦН в заданном диапазоне от 0.01 до 1.99
'    исходя из найденного забойного давления и давления на устье
    CoeffB(0) = p_wh_atma
    CoeffB(1) = p_wf_atma
    CoeffB(2) = t_wf_C
    CoeffB(3) = feed_json
    CoeffB(4) = construction_json
    CoeffB(5) = esp_json
    CoeffB(6) = t_model_json
    CoeffB(7) = h_perf_m
    CoeffB(8) = h_esp_m
    CoeffB(9) = calibr_grav
    CoeffB(10) = calibr_fric
    CoeffB(11) = ksep
    CoeffB(12) = ipr_json
    CoeffB(13) = t_crit_C
    CoeffB(14) = p_cas_atma
    CoeffB(15) = flow_corr
    
    prm.y_tolerance = 0.01
    
    If solve_equation_bisection("calc_well_calibr_esp", 0.01, 1.99, CoeffB, prm) Then
        ' если решение нашлось, пересчитаем распределение давления ради графиков и добавим в выходной json значение деградации
        esp_json = update(esp_json, prm.x_solution)
        res = well_calc_from_pwf(p_wf_atma, t_wf_C, feed_json, construction_json, esp_json, t_model_json, h_perf_m, h_esp_m, calibr_grav, calibr_fric, ksep, ipr_json, t_crit_C, p_cas_atma, flow_corr)
        Set dres = ParseJson(res)
        dres.Add "calibr_esp_head", prm.x_solution
        res = ConvertToJson(dres)
        well_calc_from_pintake = res
    Else
        well_calc_from_pintake = "not found"
    End If
     
    Exit Function
er1:
    well_calc_from_pintake = "error " & Err.Description
    
End Function

