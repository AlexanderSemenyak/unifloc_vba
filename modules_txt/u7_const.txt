'=======================================================================================
'Unifloc 7.26  coronav2                                          khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2020
'
'=======================================================================================
' constant definition module
Option Explicit
Public Const const_unifloc_version = "7.26"
Public Const esp_db_name = "\ESP_json.db"
' only database as global variable here
' in order to reduce db file read
Public ESP_base_dictionary As Dictionary
Public Const prm_gas_goes_into_solution     As String = "gas_goes_into_solution"
Public Const prm_PVT_correlation            As String = "PVT_correlation"
Public Const prm_show_log                   As String = "show_log"
Public Const prm_show_info                  As String = "show_info"
Public Const prm_num_value                  As String = "num_value"
Public Const prm_calc_along_flow            As String = "calc_along_flow"
Public Const prm_choke_calibr               As String = "choke_calibr"
Public Const const_name_qliq_m3day       As String = "qliq_m3day"
Public Const const_name_fw_perc          As String = "fw_perc"
Public Const const_name_p_cas_atma        As String = "p_cas_atma"
Public Const const_name_h_dyn_m          As String = "h_dyn_m"
Public Const const_name_p_line_atma      As String = "p_line_atma"
Public Const const_name_pbuf_atma        As String = "pbuf_atma"
Public Const const_name_pwf_atma         As String = "pwf_atma"
Public Const const_name_gamma_oil        As String = "gamma_oil"
Public Const const_name_gamma_water      As String = "gamma_water"
Public Const const_name_gamma_gas        As String = "gamma_gas"
Public Const const_name_rp_m3m3          As String = "rp_m3m3"
Public Const const_name_rsb_m3m3         As String = "rsb_m3m3"
Public Const const_name_pb_atma          As String = "pb_atma"
Public Const const_name_hResMes_m        As String = "HResMes_m"
Public Const const_name_hPumpMes_m       As String = "HPumpMes_m"
Public Const const_name_dchoke_mm        As String = "Dchoke_mm, mm"
Public Const const_name_roughness_m      As String = "roughness_m, м"
Public Const const_name_ESP_qliq_m3day   As String = "ESP_qliq_m3day"
Public Const const_name_ESP_num_stages   As String = "ESP_num_stages"
Public Const const_name_ESP_freq_Hz      As String = "ESP_freq_Hz"
Public Const const_name_ESP_p_int_atma   As String = "ESP_p_int_atma"
Public Const const_name_Pres_atma        As String = "Pres_atma"
Public Const const_name_pi_sm3dayatm     As String = "pi_sm3dayatm"
Public Const const_name_ESP_t_int_C      As String = "ESP_t_int_C"
Public Const const_name_t_res_C           As String = "t_res_C"
Public Const const_name_hmesCurve       As String = "HmesCurve"
Public Const const_name_dcasCurve       As String = "DcasCurve"
Public Const const_name_dtubCurve       As String = "DtubCurve"
Public Const const_name_TAmbCurve       As String = "TAmbCurve"
Public Const str_p_curve = "c_P"
Public Const str_t_curve = "c_T"
Public Const str_VLPcurve = "VLPcurve"                      ' кривая оттока -  зависимость забойного давления от дебита жидкости
Public Const str_HvertCurve = "HvertCurve"                  ' кривая траектории (кривизны) скважины
Public Const str_DcasCurve = "DcasCurve"                    ' кривая изменения диаметра эксплуатационной колонны
Public Const str_DtubCurve = "DtubCurve"                    ' кривая изменения диаметра НКТ
Public Const str_RoughnessCasCurve = "RoughnessCasCurve"    ' кривая изменения шероховатости по трубе эксплуатационной колонны
Public Const str_RoughnessTubCurve = "RoughnessTubCurve"    ' кривая изменения шероховатости по трубе НКТ
Public Const str_Hd_Depend_p_wf = "Hd_Depend_p_wf"            ' кривая - зависимость динамического уровня от забойного давления, при заданном давлении в затрубе
Public Const str_Pan_Depend_p_wf = "Pan_Depend_p_wf"          ' кривая - зависимость затрубного давления от забойного давления
' зависимости лин давления и буферного давления от дин уровня логично показывать на одном графике
Public Const str_plin_Depend_p_wf = "plin_Depend_p_wf"        ' кривая - зависимость линейного давления от дин уровня
Public Const str_pbuf_pwf_curve = "pbuf_pwf_curve"          ' зависимость буферного давления от дин уровня
Public Const str_ksep_natQl_curve = "ksep_natQl_curve"         ' зависимость коэффициента сепарации от дебита
Public Const str_ksep_natRp_curve = "ksep_natRp_curve"         ' зависимость коэффициента сепарации от газового фактора
Public Const str_ksep_totalQl_curve = "ksep_totalQl_curve"     ' кривая общего коэффициента сепарации от дебита
Public Const str_ksep_totalRp_curve = "ksep_totalRp_curve"     ' кривая общего коэффициента сепарации от газового фактора
Public Const str_ksep_gassepQl_curve = "ksep_gassepQl_curve"   ' кривая коэффициента сепарации газосепаратора от дебита
Public Const str_ksep_gassepRp_curve = "ksep_gassepQl_curve"   ' кривая коэффициента сепарации газосепаратора от газового фактора
Public Const str_Pdisc_calibr_head_curve = "Pdisc_calibr_head_curve"         ' кривая зависимости давления на устье от деградации напора УЭЦН
Public Const str_TambHmes_curve = "TambHmes_curve"           ' профиль температуры окружающего простраства от измеренный координаты
Public Const str_PtubHmes_curve = "PtubHmes_curve"           ' профиль давления по стволу скважины по ниже НКТ и по НКТ до устья
Public Const str_TtubHmes_curve = "TtubHmes_curve"           ' профиль температуры по стволу скважины по НКТ
Public Const str_PcasHmes_curve = "PcasHmes_curve"           ' профиль давления по стволу скважины по ниже НКТ и по затрубу до устья
Public Const str_TcasHmes_curve = "TcasHmes_curve"           ' профиль температуры по стволу скважины ниже насоса и выше насоса по затрубу
Public Const str_RstubHmes_curve = "RstubHmes_curve"         ' профиль остаточного содержания газа в нефти по потоку в НКТ
Public Const str_RscasHmes_curve = "RscasHmes_curve"         ' профиль остаточного содержания газа в нефти по потоку по затрубу
Public Const str_GasFracTubHmes_curve = "GasFracTubHmes_curve" ' расходное содержание газа в потоке в НКТ
Public Const str_GasFracCasHmes_curve = "GasFracCasHmes_curve" ' расходное содержание газа в потоке по затрубу
Public Const str_HlHmes_curve = "HlHmes_curve"         ' Liquid holdup (содержание жидкости) в потоке через НКТ
Public Const str_HLtubHmes_curve = "HLtubHmes_curve"         ' Liquid holdup (содержание жидкости) в потоке через НКТ
Public Const str_HLcasHmes_curve = "HLcasHmes_curve"         ' Liquid holdup (содержание жидкости) в потоке по затрубу
Public Const str_muoTubCurve = "muoTubCurve" '
Public Const str_muwTubCurve = "muwTubCurve" '
Public Const str_mugTubCurve = "mugTubCurve" '
Public Const str_mumixTubCurve = "mumixTubCurve" '
Public Const str_rhooTubCurve = "rhooTubCurve" '
Public Const str_rhowTubCurve = "rhowTubCurve" '
Public Const str_rholTubCurve = "rholTubCurve" '
Public Const str_rhogTubCurve = "rhogTubCurve" '
Public Const str_rhomixTubCurve = "rhomixTubCurve" '
Public Const str_qoTubCurve = "qoTubCurve" '
Public Const str_qwTubCurve = "qwTubCurve" '
Public Const str_qgTubCurve = "qgTubCurve" '
Public Const str_moTubCurve = "moTubCurve" '
Public Const str_mwTubCurve = "mwTubCurve" '
Public Const str_mgTubCurve = "mgTubCurve" '
Public Const str_vlTubCurve = "vlTubCurve" '
Public Const str_vgTubCurve = "vgTubCurve" '
Public Const str_muoCasCurve = "muoCasCurve" '
Public Const str_muwCasCurve = "muwCasCurve" '
Public Const str_mugCasCurve = "mugCasCurve" '
Public Const str_mumixCasCurve = "mumixCasCurve" '
Public Const str_rhooCasCurve = "rhooCasCurve" '
Public Const str_rhowCasCurve = "rhowCasCurve" '
Public Const str_rholCasCurve = "rholCasCurve" '
Public Const str_rhogCasCurve = "rhogCasCurve" '
Public Const str_rhomixCasCurve = "rhomixCasCurve" '
Public Const str_qoCasCurve = "qoCasCurve" '
Public Const str_qwCasCurve = "qwCasCurve" 'a's
Public Const str_qgCasCurve = "qgCasCurve" '
Public Const str_moCasCurve = "moCasCurve" '
Public Const str_mwCasCurve = "mwCasCurve" '
Public Const str_mgCasCurve = "mgCasCurve" '
Public Const str_vlCasCurve = "vlCasCurve" '
Public Const str_vgCasCurve = "vgCasCurve" '
'Public Const PVT_DEFAULT = "gamma_gas:0,900;gamma_oil:0,750;gamma_wat:1,000;rsb_m3m3:100,000;rp_m3m3:-1,000;pb_atma:-1,000;t_res_C:90,000;bob_m3m3:-1,000;muob_cP:-1,000;PVTcorr:0;ksep_fr:0,000;p_ksep_atma:-1,000;t_ksep_C:-1,000;"
Public Const PVT_DEFAULT = "{""gamma_gas"":0.6,""gamma_oil"":0.86,""gamma_wat"":1,""rsb_m3m3"":100}"
'Public Const ESP_DEFAULT = "ESP_ID:1006.00000;HeadNom_m:2000.00000;ESP_freq_Hz:50.00000;ESP_U_V:1000.00000;MotorPowerNom_kW:30.00000;t_int_C:85.00000;t_dis_C:25.00000;Ksep_GS_fr:0.00000;ESP_energy_fact_Whday:0.00000;ESP_cable_type:0;ESP_h_mes_m:0.00000;ESP_gas_correct:0;c_calibr_head:0.00000;PKV_work_min:-1,00000;PKV_stop_min:-1,00000;"
Public Const WELL_DEFAULT = "{""h_perf_m"":1600,""h_tub_m"":1000,""rough_m"":0.0001,""d_choke_mm"":15,""t_val_C"":[[25]],""h_list_m"":[[2000]],""d_tub_list_mm"":[[62]],""d_cas_list_mm"":[[125]]}"
'Public Const WELL_GL_DEFAULT = "h_perf_m:2500,00000;htub_m:2000,00000;udl_m:0,00000;d_cas_mm:125,00000;dtub_mm:62,00000;dchoke_mm:15,00000;roughness_m:0,00010;t_bh_C:100,00000;t_wh_C:50,00000;GLV:1;H_glv_m:1500,000;d_glv_mm:5,000;p_glv_atma:50,000;"
Public Const const_t_K_min = 273         ' ниже нуля ничего не считаем?
Public Const const_tMcCain_K_min = 289         ' ниже нуля ничего не считаем?
Public Const const_t_K_max = 573         ' выше тоже ничего не считаем?
Public Const const_t_K_zero_C = 273
Public Const const_t_C_min = const_t_K_min - const_t_K_zero_C
Public Const const_t_C_max = const_t_K_max - const_t_K_min
Public Const const_Pi As Double = 3.14159265358979
Public Const const_tsc_C = 20
Public Const const_tsc_K As Double = const_tsc_C + const_t_K_zero_C ' температура стандартных условиях, К
Public Const const_psc_atma As Double = 1
Public Const const_r As Double = 8.31 'Universal gas constant
Public Const const_g = 9.81
Public Const const_rho_air = 1.2217
Public Const const_gamma_w = 1
Public Const const_rho_ref = 1000
Public Const const_ZNLF_rate = 0.1
Public Const const_m_a_kgmol As Double = 0.029 'Air molar mass
Public Const const_sigma_wat_gas_Nm = 0.01 ' поверхностное натяжение на границе с воздухом (газом) - типовые значения для дефолтных параметров  Н/м
Public Const const_sigma_oil_Nm = 0.025
Public Const const_mu_w = 0.36
Public Const const_mu_g = 0.0122
Public Const const_mu_o = 0.7
Public Const const_gg_ = 0.6
Public Const const_gw_ = 1
Public Const const_go_ = 0.86
Public Const const_rsb_default = 100
Public Const const_Bob_default = 1.2
Public Const const_tres_default = 90
Public Const const_Roughness_default = 0.0001
' набор констант для общих ограничений значений переменных
Public Const const_gamma_gas_min = 0.5   ' плотность метана 0.59 - предпологаем легче газов не будет
Public Const const_gamma_gas_max = 2     ' плотность углеводородных газов (гексан) может доходить до 4, но мы считаем что в смеси таких не много должно быть
Public Const const_gamma_water_min = 0.9 ' плотность воды от 0.9 до 1.5
Public Const const_gamma_water_max = 1.5
Public Const const_gamma_oil_min = 0.5   ' плотность нефти
Public Const const_gamma_oil_max = 1.5
Public Const const_P_MPa_min = 0
Public Const const_P_MPa_max = 50
Public Const const_Salinity_ppm_min = 0
Public Const const_Salinity_ppm_max = 265000  ' equal to weigh percent salinity 26.5%.  Ограничение по границам применимости корреляций МакКейна
Public Const const_rsb_m3m3_min = 0
Public Const const_rsb_m3m3_max = 100000 ' rsb more that 100 000 not allowed
Public Const const_Ppr_min = 0.002
Public Const const_Ppr_max = 30
Public Const const_Tpr_min = 0.7
Public Const const_Tpr_max = 3
Public Const const_Z_min = 0.05
Public Const const_Z_max = 5
Public Const const_TGeoGrad_C100m = 3   ' геотермальный градиент в градусах на 100 м
Public Const const_Heps_m = 0.001       ' дельта для корретировки кривой трубы, - примерно соответствует длине сочленения труб
Public Const const_ESP_length = 1      ' длина УЭЦН по умолчанию
Public Const const_pipe_diam_default_mm = 62
' набор констант для перевода единиц измерений в различных размерностях
Public Const const_convert_atma_Pa = 101325
Public Const const_convert_Pa_atma = 1 / const_convert_atma_Pa
Public Const const_convert_kgfcm2_Pa = 98066.5
Public Const const_convert_m3day_bbl = 6.289810569
Public Const const_convert_gpm_m3day = 5.450992992     ' (US) gallon per minute
Public Const const_convert_m3day_gpm = 1 / const_convert_gpm_m3day
Public Const const_convert_m3m3_scfbbl = 5.614583544
Public Const const_convert_scfbbl_m3m3 = 1 / const_convert_m3m3_scfbbl
Public Const const_convert_bbl_m3day = 1 / const_convert_m3day_bbl
Public Const const_conver_day_sec = 86400   ' updated for test  rnt21
Public Const const_convert_hr_sec = 3600
Public Const const_convert_m3day_m3sec = 1 / const_conver_day_sec
Public Const const_conver_sec_day = 1 / const_conver_day_sec
Public Const const_convert_atma_psi = 14.7
Public Const const_convert_psi_atma = 1 / const_convert_atma_psi
Public Const const_convert_ft_m = 0.3048
Public Const const_convert_m_ft = 1 / const_convert_ft_m
Public Const const_convert_m_mm = 1000
Public Const const_convert_mm_m = 1 / const_convert_m_mm
Public Const const_convert_cP_Pasec = 1 / 1000
Public Const const_convert_HP_W = 745.69987  ' 735.49875  ' метрическая лошадиная сила. следует учесть, что иногда может применяться механическя лошадиная сила (1.013 метрической)
Public Const const_convert_W_HP = 1 / const_convert_HP_W
Public Const const_convert_Nm_dynescm = 1000
Public Const const_convert_lbmft3_kgm3 = 16.01846
Public Const const_convert_kgm3_lbmft3 = 1 / const_convert_lbmft3_kgm3
Public Const const_convert_psift_atmm = 1 / const_convert_atma_psi / const_convert_ft_m ' pressure gradient conversion factor
Public Const const_convert_MPa_atma = 1000000 / const_convert_atma_Pa  ' 9.8692
Public Const const_convert_MPa_psia = const_convert_MPa_atma * const_convert_atma_psi
Public Const const_convert_atma_MPa = 1 / const_convert_MPa_atma ' 0.101325' константа для конверсии единиц давления из Мпа в atma
Public Const const_p_atma_min = const_P_MPa_min * const_convert_MPa_atma
Public Const const_p_atma_max = const_P_MPa_max * const_convert_MPa_atma
Public Const MAXIT = 100
' константы для расчета многофазного потока
Public Const const_MaxSegmLen = 100
Public Const const_n_n = 20
Public Const const_MaxdP = 10
Public Const const_minPpipe_atma = 0.9
Public Const const_pressure_tolerance = 0.001
Public Const const_well_P_tolerance = 0.05     ' допустимая погрешность при расчете забойного давления в скважине
Public Const const_P_difference = 0.0001       ' допустимая погрешность при сравнении (в основном) давлений
Public Const ang_max = 5
Public Const const_OutputCurveNumPoints = 50
Public Const DEFAULT_PAN_STEP = 15
Public Const kErrWellConstruction = 513 + vbObjectError
Public Const kErrPVTinput = 514 + vbObjectError
Public Const kErrNodalCalc = 515 + vbObjectError
Public Const kErrInitCalc = 516 + vbObjectError
Public Const kErrESPbase = 517 + vbObjectError
Public Const kErrPVTcalc = 518 + vbObjectError
Public Const kErrESPcalc = 519 + vbObjectError
Public Const kErrGradcalc = 520 + vbObjectError
Public Const kErrArraySize = 701 + vbObjectError
Public Const kErrBuildCurve = 702 + vbObjectError
Public Const kErrcurvestablePointIndex = 703 + vbObjectError
Public Const kErrCurvePointIndex = 704 + vbObjectError
Public Const kErrReadDataFromWorksheet = 705 + vbObjectError
Public Const kErrWriteDataFromWorksheet = 706 + vbObjectError
Public Const kStrConversion = 707 + vbObjectError
Public Const kErrDegradationNotFound = 708 + vbObjectError
Public Const kErrDegradationError = 709 + vbObjectError
Public Const kreadRangeError = 710 + vbObjectError
Public Const kErrCInterpolation = 711 + vbObjectError
Public Const kErrTester = 712 + vbObjectError
Public Const kErrBisection = 713 + vbObjectError
Public Const sDELIM As String = vbNewLine
Public Const MinCountPoints_calc_pwf_pcas_hdyn_atma = 5
Public Const root3 = 3 ^ 0.5
' hydraulic correlations types
Public Enum H_CORRELATION
    BeggsBrill = 0
    Ansari = 1
    Unified = 2
    Gray = 3
    HagedornBrown = 4
    SakharovMokhov = 5
    gas = 10
    Water = 11
End Enum
' PVT correlations set to be used
Public Enum PVT_correlation
    Standing_based = 0 '
    McCain_based = 1 '
    straigth_line = 2
End Enum
' z factor (gas compressibility) options
Public Enum Z_CORRELATION
    z_BB = 0
    z_Dranchuk = 1
    z_Kareem = 2
End Enum
' type determines the method of temperature calculation in well
Public Enum TEMP_CALC_METHOD
    StartEndTemp = 0
    GeoGradTemp = 1
    AmbientTemp = 2
End Enum
' gas separation in well at pump intake. calculation method
Public Enum SEPAR_CALC_METHOD
    fullyManual = 3
    valueManual = 2
    pressureManual = 1
    byCorrealation = 0
End Enum
' standard port sizes for whetherford r1 glv
Public Enum GLV_R1_PORT_SIZE
    R1_port_1_8 = 3.18
    R1_port_5_32 = 3.97
    R1_port_3_16 = 4.76
    R1_port_1_4 = 6.35
    R1_port_5_16 = 7.94
End Enum
' multiphase flow in pipe and well calculation method
Public Type PARAMCALC
     correlation As H_CORRELATION         ' multiphase hydraulic correlation
     CalcAlongCoord As Boolean            ' calculation direction flag
                                          ' if True - pressure at lowest coordinate is given
                                          '           pressure at higher coordinate calculated
                                          '           for well (0 coord at top, hmes at bottom)
                                          '           equal to calc from top to bottom
                                          '    False - otherwise
     FlowAlongCoord As Boolean            ' flow direction flag
     temp_method As TEMP_CALC_METHOD      ' temperature caclulation method
     length_gas_m As Double               ' length in pipe where correlation changes.
                                          ' for points with cooed less then  length_gas_m
                                          ' gas correlation applied,
                                          ' other points - multiphase correlation applied
                                          ' allows to model easily static level in well
    start_length_gas_m As Double
End Type
' type to describe thermobaric conditions (for calculations)
Public Type PTtype
    p_atma As Double
    t_C As Double
End Type
' type for storing data about dynamic level
Public Type PCAS_HDYN_type
    p_cas_atma As Double
    hdyn_m As Double
    self_flow_condition As Boolean
    pump_off_condition As Boolean
    correct As Boolean
End Type
' Type for describing the operation of an electric motor
Public Type MOTOR_DATA
    U_lin_V As Double       ' voltage linear (between phases)
    I_lin_A As Double       ' Linear current (in line)
    U_phase_V As Double     ' phase voltage (between phase and zero)
    I_phase_A As Double     ' phase current (in winding)
    f_Hz As Double          ' frequency synchronous (field rotation)
    eff_d As Double         ' Efficiency
    cosphi As Double        ' power factor
    s_d As Double           ' slippage
    Pshaft_kW As Double     ' mechanical power on the shaft
    Pelectr_kW As Double    ' power supply electric
    Mshaft_Nm As Double     ' torque on the shaft - mechanical
    load_d As Double        ' motor load
End Type
' ESP description to be loaded from DB
' combined in type to decrease a mess in CESPpump
Public Type ESP_PARAMS
     ID As String                    ' ID from database
     source As String
     manufacturer As String
     name As String
     stages_max As Integer           ' максимальной количество ступеней в насосе (из базы)
     rate_max_sm3day As Double       ' максимальный дебит насос (из базы) - хорошо бы для надежности определять параметр из характеристики
     rate_nom_sm3day As Double
     rate_opt_min_sm3day As Double   ' границы оптимального диапазона для насоса - минимум
     rate_opt_max_sm3day As Double   ' границы оптимального диапазона  - максимум
     freq_Hz As Double               ' частота насоса для номинальной характеристики в базе
     
     ' характеристика заданные по точкам
     head_points() As Double
     rate_points() As Double
     power_points() As Double
     eff_points() As Double
     
     height_stage_m As Double        ' примерная высота ступени
     d_od_m As Double                ' внешний диаметр ЭЦН
     d_motor_od_m As Double         ' внешний диаметр ПЭД
     d_cas_min_m As Double           ' минимальный диаметр обсадной колонны, заданный производителем оборудования
     d_shaft_m As Double             ' диаметр вала для насоса
     area_shaft_m2 As Double         ' площадь поперечного сечения вала   (дублирует диаметр, но задается производителем)
     
     power_limit_shaft_kW As Double ' максимальная мощность передаваемая валом на номинальной частоте
     power_limit_shaft_high_kW As Double
     power_limit_shaft_max_kW As Double ' максимальная мощность передаваемая валом на номинальной частоте для высокопрочного вала
     pressure_limit_housing_atma As Double ' максимальное давление на корпус
     slip_nom_rpm As Double
     eff_max As Double
End Type
' type of extended description of multiphase flow parameters at a point
Public Type PIPE_FLOW_PARAMS
  md_m As Double         ' pipe measured depth (from start - top)
  vd_m As Double         ' pipe vertical depth from start - top
  diam_mm As Double      ' pipe diam
  p_atma As Double       ' pipe pressure at measured depth
  t_C As Double          ' pipe temp at measured depth
  
  dp_dl As Double
  dt_dl As Double
  
  dpdl_g_atmm As Double  ' gravity gradient at measured depth
  dpdl_f_atmm As Double  ' friction gradient at measured depth
  dpdl_a_atmm As Double  ' acceleration gradient at measured depth
  v_sl_msec As Double    ' superficial liquid velosity
  v_sg_msec As Double    ' superficial gas velosity
  h_l_d As Double        ' liquid hold up
  fpat As Double         ' flow pattern code
  thete_deg As Double
  roughness_m As Double
  
  rs_m3m3 As Double     ' dissolved gas in oil in the stream
  gasfrac As Double     ' gas flow rate
  
  mu_oil_cP As Double   ' oil viscosity in flow
  mu_wat_cP As Double   ' water viscosity in the flow
  mu_gas_cP As Double   ' gas viscosity in flow
  mu_mix_cP As Double   ' viscosity of the mixture in the flow
  
  Rhoo_kgm3 As Double   ' oil Density
  Rhow_kgm3 As Double   ' water Density
  rhol_kgm3 As Double   ' liquid density
  Rhog_kgm3 As Double   ' gas Density
  rhomix_kgm3 As Double ' density of the mixture in the thread
  
  q_oil_m3day As Double ' oil consumption in working conditions
  qw_m3day As Double    ' water consumption in working conditions
  Qg_m3day As Double    ' gas flow rate under operating conditions
  
  mo_kgsec As Double    ' mass flow rate of oil in working conditions
  mw_kgsec As Double    ' mass flow rate in working conditions
  mg_kgsec As Double    ' mass flow rate of gas under operating conditions
  
  vl_msec As Double     ' fluid velocity is real
  vg_msec As Double     ' real gas velocity
End Type
' type of description of free gas behavior when increasing the pressure
' relevant for ESPs where pressure rises
' The free gas can either dissolve into the stream or simply compress
'Public Enum GAS_INTO_SOLUTION
'    gas_goes_into_solution = 1
'    GasnotGoesIntoSolution = 0
'End Enum
' type showing the way of saving the extended calculation results
' determines which set of calculated distribution curves will be saved
Public Enum CALC_RESULTS
    nocurves = 0
    maincurves = 1
    allCurves = 2
End Enum
'=========================================================================================
'types support functions
'=========================================================================================
' flow parameter setting function in the pipe or well
Public Function set_calc_flow_param( _
                Optional ByVal calc_along_coord As Boolean = False, _
                Optional ByVal flow_along_coord As Boolean = False, _
                Optional ByVal hcor As H_CORRELATION = Ansari, _
                Optional ByVal temp_method As TEMP_CALC_METHOD = StartEndTemp, _
                Optional ByVal length_gas_m As Double = 0, _
                Optional ByVal start_length_gas_m As Double = 0) As PARAMCALC
' calc_along_coord - calculation direction flag
' flow_along_coord - flow direction relative to coordinate
' hcor             - hydraulic correlation selector
' temp_method      - temperature method selector
' length_gas_m     - boundary of gas correlation application in flow
    Dim prm As PARAMCALC
    prm.CalcAlongCoord = calc_along_coord
    prm.FlowAlongCoord = flow_along_coord
    prm.correlation = hcor
    prm.temp_method = temp_method
    prm.length_gas_m = length_gas_m
    prm.start_length_gas_m = start_length_gas_m
    set_calc_flow_param = prm
End Function
Public Function sum_PT(PT1 As PTtype, PT2 As PTtype) As PTtype
    sum_PT.p_atma = PT1.p_atma + PT2.p_atma
    sum_PT.t_C = PT1.t_C + PT2.t_C
End Function
Public Function subtract_PT(PT1 As PTtype, PT2 As PTtype) As PTtype
    subtract_PT.p_atma = PT1.p_atma - PT2.p_atma
    subtract_PT.t_C = PT1.t_C - PT2.t_C
End Function
Public Function set_PT(ByVal p As Double, ByVal T As Double) As PTtype
    set_PT.p_atma = p
    set_PT.t_C = T
End Function
Public Function PT_to_array(PT As PTtype)
    PT_to_array = Array(PT.p_atma, PT.t_C)
End Function
'=======================================================================================
'simple math function (additional to alglib)
Public Function cosd(ang) As Double
 cosd = Cos(ang / 180 * const_Pi)
End Function
Public Function sind(ang) As Double
 sind = Sin(ang / 180 * const_Pi)
End Function
Public Function isEqual(A As Double, B As Double) As Double
    Const Eps = const_P_difference
    isEqual = False
    If Abs(A - B) < Eps Then isEqual = True
End Function
Public Function isGreater(A As Double, B As Double) As Double
    Const Eps = const_P_difference
    isGreater = False
    If (A - B) > Eps Then isGreater = True
End Function
Public Function isBetween(A As Double, a0 As Double, a1 As Double)
    isBetween = False
    If ((A <= a0) And (A >= a1)) Or ((A >= a0) And (A <= a1)) Then isBetween = True
End Function
' функция решения ОДУ методом Кэш Карпа (Cash-Karp adaptive ODE solver)
' Решается ОДУ вида  Y'=f(Y,x)  с начальными устьвиями Y(xs)=Ys
' Y или одна переменная или вектор размерности N.
Public Function solve_ode(ByVal func_name As String, _
                          y0() As Double, _
                          XA() As Double, _
                          CoeffA As Variant, _
                 Optional Eps As Double = 0.000001, _
                 Optional Step As Double = 10, _
                 Optional MaxIts As Long = 1000)
' func_name         - имя функции  f(x)
' Y0                - начальное значение для расчета
' XA                - значения аргумента для которых ищем решение
' CoeffA            - дополнительные параметры функции градиента
' Eps
' Step
' MaxIts
    Dim M As Long, N As Long, State As ODESolverState, _
    YA() As Double, i As Long, _
    Rtn As Boolean, Rep As ODESolverReport
    Dim R() As Double
  
    N = UBound(y0) + 1
    M = UBound(XA) + 1
    'Set up any required output arrays
    ReDim YA(0 To M - 1, 0 To N - 1)
    
    'Call the appropriate AlgLib routine to initialise the State object
    Call ODESolverRKCK(y0(), N, XA, M, Eps, Step, State)
    
    ' Loop through the AlgLib solver routine and the external ODE
    ' evaluation routine until the solver routine returns "False",
    ' which indicates that it has finished.
    ' The VBA function named in "func_name" is called using
    ' the Application.Run method.
    Rtn = True
    i = 0
    Do While Rtn = True And i < MaxIts
        Rtn = ODESolverIteration(State)
        R = Application.Run(func_name, State.X, State.y, CoeffA(0))
        State.DY(0) = R(0)
        i = i + 1
    Loop
    
     ' Extract the desired results from the State
     ' object using the appropriate AlgLib routine
     Call ODESolverResults(State, M, XA, YA, Rep)
    
    ' If necessary convert the AlgLib output array(s) to
    ' a form suitable for Excel.  In this case YA2 is
    ' a 2D base 0 array, which may be assigned to the
    ' function return value without further processing.
    
    ' Assign the output array to the function return value
     solve_ode = YA
End Function
' функция ищет корни уравнения вида
' f(x) = 0 на отрезке [x1..x2]
Public Function solve_equation_bisection(func_name As String, _
                                         ByVal X1 As Double, _
                                         ByVal X2 As Double, _
                                         CoeffA, _
                                         prm As CSolveParam) As Boolean
' func_name             - название функции для которой ищем решение
' x1                    - левая граница аргумента для поиска решения
' x2                    - правая граница аргумента для поиска решения
' coeffA                - параметры функции для которой ищем решение
' prm                   - объект с настройками поиска решения
'                         через этот же объект возвращаются решение и его параметры
    Dim Y1 As Double
    Dim Y2 As Double
    Dim y_temp As Double
    Dim x_temp As Double
    Dim i As Long
    Dim err_msg As String
    i = 0
On Error GoTo err1:
    ' определим значения параметров на границе
    Y1 = Application.Run(func_name, X1, CoeffA)
    Y2 = Application.Run(func_name, X2, CoeffA)
    With prm
        If Y1 * Y2 > 0 Then
            ' если значения на границе одного знака - то метод поиска решения не работает
            ' возможно решения нет и найти его не получится
            .iterations = 0
            .found_solution = False
            .msg = "solve_equation_bisection: values at segment's ends must have a different sign"
            solve_equation_bisection = False
            Exit Function
        End If
        ' начинаем цикл поиска решений (итерации)
        Do
            i = i + 1
            ' делим отрезок пополам
            x_temp = (X1 + X2) / 2
            y_temp = Application.Run(func_name, x_temp, CoeffA)
            If Abs(y_temp) < .y_tolerance Then
                solve_equation_bisection = True
                .x_solution = x_temp
                .y_solution = y_temp
                .iterations = i
                .found_solution = True
                .msg = "solve_equation_bisection: done by  " + CStr(i) + " iterations, tolerance " + CStr(.y_tolerance)
                Exit Function
            Else
                If y_temp * Y1 > 0 Then
                    X1 = x_temp
                    Y1 = y_temp
                Else
                    X2 = x_temp
                    Y2 = y_temp
                End If
            End If
        Loop Until i >= 100
        
        solve_equation_bisection = False
        .x_solution = x_temp
        .y_solution = y_temp
        .iterations = i
        .found_solution = False
        .msg = "solve_equation_bisection: too many iterations " + CStr(i)
    End With
    Exit Function
err1:
    On Error GoTo 0
    With prm
        .iterations = i
        .found_solution = False
        .msg = "solve_equation_bisection error " & Err.Description
    End With
    solve_equation_bisection = False
End Function
' Non-linear least squares fit for function evaluated by VBA routine
' нелинейная регрессия МНК для VBA функции
Function AL_NLFit(Func As String, _
                  Y_Range As Variant, _
                  X_Range As Variant, _
                  CoeffA As Variant, _
         Optional TolA As Variant, _
         Optional WeightA As Variant, _
         Optional CheapFG As Boolean = False, _
         Optional UseHess As Boolean = False) As Variant
' func      - имя функции VBA для которой делается мачинг
' Y_Range   - значение функции под который надо делать подстройку
' X_Range   - значения аргументов от которых зависит функция
' CoeffA    - параметры VBA функции
' TolA
                  
    Dim C() As Double, N As Long, M As Long, K As Long, State As LSFitState, WeightAD() As Double, UseWeights As Boolean
    Dim Slopea As Variant, RtnState As Boolean, ResA() As Double, NumWeights As Long, NumWCols As Long
    Dim XAD() As Double, YAD() As Double, CAD() As Double, Rtn As Long, NLoops As Long
    Dim i As Long, Info As Long, Rep As LSFitReport
    Dim EpsF As Double, EpsX As Double, MaxIts As Long
    If IsMissing(TolA) = False Then
        GetArray TolA
        EpsF = TolA(1, 1)
        EpsX = TolA(2, 1)
        MaxIts = TolA(3, 1)
    Else
        EpsF = 0
        EpsX = 0.000000001
        MaxIts = 1000
    End If
    Rtn = GetNLFitData(X_Range, Y_Range, CoeffA, XAD, YAD, CAD, N, M, K)
    ReDim ResA(1 To K + 4)
    If IsMissing(WeightA) = False Then
        GetArray WeightA
        NumWeights = UBound(WeightA)
        NumWCols = UBound(WeightA, 2)
        ReDim WeightAD(0 To NumWeights - 1)
        Call Array120D(WeightA, WeightAD, NumWeights, NumWCols)
        UseWeights = True
    End If
    If UseWeights = True Then
        If UseHess = True Then
            Call LSFitNonlinearWFGH(XAD, YAD, WeightAD, CAD, N, M, K, State)
        Else
            Call LSFitNonlinearWFG(XAD, YAD, WeightAD, CAD, N, M, K, CheapFG, State)
        End If
    Else
        If UseHess = True Then
            Call LSFitNonlinearFGH(XAD, YAD, CAD, N, M, K, State)
        Else
            Call LSFitNonlinearFG(XAD, YAD, CAD, N, M, K, CheapFG, State)
        End If
    End If
    Call LSFitNonlinearSetCond(State, EpsF, EpsX, MaxIts)
    Do While LSFitNonlinearIteration(State) = True
        NLoops = NLoops + 1
        State.F = Application.Run(Func, State.X, State.C, 1)
        If State.NeedFG = True Then
            State.G = Application.Run(Func, State.X, State.C, 2)
        End If
        If State.NeedFGH = True Then
            State.H = Application.Run(Func, State.X, State.C, 3)
        End If
    Loop
    Call LSFitNonlinearResults(State, Info, C, Rep)
    For i = 1 To K
        ResA(i) = C(i - 1)
    Next i
    ResA(K + 1) = Rep.RMSError
    ResA(K + 2) = Rep.MaxError
    ResA(K + 3) = NLoops
    ResA(K + 4) = Info
    AL_NLFit = ResA
End Function
' подготовка данных для нелинейное регрессии
Private Function GetNLFitData(XA As Variant, _
                              YA As Variant, _
                              CA As Variant, _
                              XAD() As Double, _
                              YAD() As Double, _
                              CAD() As Double, _
                              N As Long, _
                              M As Long, _
                              K As Long, _
                              Optional CAT As Variant) As Variant
' XA input vector for arguments (N x M)
'    N is a number of points,
'    M is a dimension of a space points belong to,
'    K is a dimension of a space of parameters being fitted,
    Dim NumYRows As Long, i As Long, j As Long, CATD As Variant
    ' если на входе range - переводим их в массивы
    If TypeName(XA) = "Range" Then XA = XA.Value2
    If TypeName(YA) = "Range" Then YA = YA.Value2
    If TypeName(CA) = "Range" Then CA = CA.Value2
    N = UBound(XA)
    M = UBound(XA, 2)
    K = UBound(CA)
    If UBound(CA, 2) = 2 Then
        K = K - M
        ReDim CAT(0 To K + M - 1)
    End If
    ReDim XAD(0 To N - 1, 0 To M - 1)
    ReDim YAD(0 To N - 1)
    ReDim CAD(0 To K - 1)
    For i = 1 To N
        YAD(i - 1) = YA(i, 1)
    Next i
    For i = 1 To N
        For j = 1 To M
            XAD(i - 1, j - 1) = XA(i, j)
        Next j
    Next i
    If UBound(CA, 2) = 1 Then
        For i = 1 To K
            CAD(i - 1) = CA(i, 1)
        Next i
    Else
        For i = 1 To K
            CAT(i - 1) = CA(i, 1)
            CAD(i - 1) = CA(i, 2)
        Next i
        For i = K + 1 To K + M
            CAT(i - 1) = CA(i, 1)
        Next i
    End If
End Function
Function GradientA(Func As Variant, Pvaluea0() As Double, _
                   XvalueA0() As Double, NumP As Long, NumX As Long, Optional DP As Double = 0.000001) As Variant
    Dim Eform As String, Eform2 As String, i As Long, j As Long, K As Long, ResA() As Double
    Dim res1 As Double, res2 As Double
    ' Evaluate the gradient vector (vector of partial first differentials, wrt each parameter)
    ' for the function specified in Func, using finite difference method.
    ReDim ResA(0 To NumP - 1)
    For i = 0 To NumP - 1
        Pvaluea0(i) = Pvaluea0(i) + DP
        res1 = Application.Run(Func, XvalueA0, Pvaluea0, 1)
        Pvaluea0(i) = Pvaluea0(i) - DP * 2
        res2 = Application.Run(Func, XvalueA0, Pvaluea0, 1)
        ResA(i) = (res1 - res2) / (DP * 2)
        Pvaluea0(i) = Pvaluea0(i) + DP
    Next i
    GradientA = ResA
End Function
Public Sub GetArray(arrayname)
    Dim temp As Variant
    If TypeName(arrayname) = "Range" Then
        If arrayname.Rows.Count = 1 Then
            If arrayname.Columns.Count = 1 Then
                arrayname = Array(arrayname.Value2)
                temp = arrayname(0)
                ReDim arrayname(1 To 1, 1 To 1)
                arrayname(1, 1) = temp
            Else
                arrayname = Array(arrayname.Value2)
                arrayname = WorksheetFunction.transpose(arrayname)
            End If
        Else
            arrayname = arrayname.Value2
        End If
    ElseIf Not IsArray(arrayname) Then
        arrayname = Array(arrayname)
        arrayname = WorksheetFunction.transpose(arrayname)
    Else
        On Error Resume Next
        arrayname = WorksheetFunction.transpose(arrayname)
    End If
End Sub
Public Sub Array120D(arrayname As Variant, DA() As Double, NumRows As Long, NumCols As Long)
    Dim i As Long, j As Long, Off As Long
    ' Convert base 1 variant array  to base 0 array double array
    ' Convert 2B arrays with 1 row or 1 colum to 1D
    Off = LBound(arrayname)
    If NumCols = 1 Then
        For i = 1 To NumRows
            DA(i - Off) = arrayname(i, 1)
        Next i
    ElseIf NumRows = 1 Then
        For i = 1 To NumCols
            DA(i - Off) = arrayname(1, i)
        Next i
    Else
        For i = 1 To NumRows
            For j = 1 To NumCols
                DA(i - Off, j - Off) = arrayname(i, j)
            Next j
        Next i
    End If
End Sub
Public Function SplitTrim(ByVal S As String, ByVal SEP As String) As String()
    Dim SPrev As String
    S = Trim(S)
    Do
        SPrev = S
        S = Replace(S, "  ", " ")
    Loop Until S = SPrev
    SplitTrim = Split(S, SEP)
End Function
Function VertArrayFromRange(rng As range)
     Dim arr_out() As Double
     Dim i As Integer
     Dim NumVal As Integer
     NumVal = rng.Rows.Count
     ReDim arr_out(NumVal - 1)
     For i = 1 To NumVal
        arr_out(i - 1) = rng.Value2(i, 1)
     Next i
     VertArrayFromRange = arr_out
End Function
Public Function S(val As Double) As String
    S = Format(val, "0##.########")
End Function
Public Function Cdbl_(str_ As Variant) As Double
On Error GoTo er11:
    Dim dec_sep As String
    Dim s_ As String
    dec_sep = Application.International(xlDecimalSeparator)
    If dec_sep = "." Then
        s_ = Replace(str_, ",", ".")
    ElseIf dec_sep = "," Then
        s_ = Replace(str_, ".", ",")
    End If
    Cdbl_ = CDbl(s_)
    Exit Function
On Error GoTo erl2:
er11: ' Исключение возникает при ошибки типа Cdbl_
        If dec_sep = "." Then
            s_ = Replace(str_, ".", ",")
        ElseIf dec_sep = "," Then
            s_ = Replace(str_, ",", ".")
        End If
        Cdbl_ = CDbl(s_)
        Exit Function
erl2: ' Добавлено исключение
    Dim errmsg As String
    errmsg = "Cdbl_ string number conversion: str =" & str_ & ":" & Err.Description
    addLogMsg errmsg
    Err.Raise kStrConversion, Err.source, errmsg
End Function
Public Function CDbl_safe(str_ As Variant)
On Error GoTo err1:
    CDbl_safe = Cdbl_(str_)
Exit Function
err1:
    CDbl_safe = str_
End Function
Public Function array_from_range(var_input)
' return array from range or from array or from number
    Dim ar() As Variant
    Dim rng As range
    Dim col As Collection
    Dim d As Long
    Dim i As Integer, j As Integer
    Dim done As Boolean
On Error GoTo err1:
    done = False
    If (TypeOf var_input Is range) Then
        Set rng = var_input
        If rng.Cells.Count = 1 Then
            Dim ST As String
            ST = CStr(rng.Value2)
            If Mid(ST, 1, 1) = "[" Then
                Dim cl As Collection
                Set cl = ParseJson(ST)
                Set var_input = cl.Item(1)
            Else
                ReDim ar(1 To 1, 1 To 1)
                ar(1, 1) = rng.Value
                done = True
            End If
        Else
            ar = rng.Value2
            done = True
        End If
    End If
    
    If Not done Then
        If (TypeOf var_input Is Collection) Then
            Set col = var_input
            ar = CollectionToArray2D(col)
        ElseIf IsArray(var_input) Then
            d = getDimension(var_input)
            If d = 2 Then
                ReDim ar(1 To UBound(var_input, 1) - LBound(var_input, 1) + 1, 1 To UBound(var_input, 2) - LBound(var_input, 2) + 1)
                For i = 1 To UBound(var_input, 1) - LBound(var_input, 1) + 1
                    For j = 1 To UBound(var_input, 2) - LBound(var_input, 2) + 1
                        ar(i, j) = var_input(i + LBound(var_input, 1) - 1, j + LBound(var_input, 2) - 1)
                    Next
                Next
            ElseIf d = 1 Then
                
                ReDim ar(1 To UBound(var_input, 1) - LBound(var_input, 1) + 1, 1 To 1)
                For i = 1 To UBound(var_input, 1) - LBound(var_input, 1) + 1
                    ar(i, 1) = var_input(i + LBound(var_input, 1) - 1)
                Next
            Else
                GoTo err1:
            End If
        Else
            ReDim ar(1 To 1, 1 To 1)
            ar(1, 1) = var_input
        End If
    End If
    array_from_range = ar
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "Error:array_from_range:" & Err.Description
    addLogMsg (errmsg)
    Err.Raise kreadRangeError, "array_from_range", errmsg
End Function
Function getDimension(var As Variant) As Long
    On Error GoTo Err
    Dim i As Long
    Dim Tmp As Long
    i = 0
    Do While True
        i = i + 1
        Tmp = UBound(var, i)
    Loop
Err:
    getDimension = i - 1
End Function
Public Function array_num_from_range(var_input, _
                            Optional remove_zeros As Boolean = False, _
                            Optional remove_only_rows As Boolean = False)
    Dim ar() As Variant
    Dim ard() As Double
    Dim ard2() As Double
    Dim val As Double
    Dim i As Integer, j As Integer
    
    ar = array_from_range(var_input)
    
On Error GoTo err1:
    ReDim ard(1 To (UBound(ar, 1) - LBound(ar, 1) + 1), 1 To (UBound(ar, 2) - LBound(ar, 2) + 1))
    For i = LBound(ar, 1) To UBound(ar, 1)
        For j = LBound(ar, 2) To UBound(ar, 2)
            val = Cdbl_(CStr(ar(i, j)))
            ard(i, j) = val
        Next
    Next
    Dim M As Double
    If remove_zeros Then
On Error GoTo err2:
        ' transpose to delete zeros rows
        ReDim ard2(1 To UBound(ard, 2), 1 To UBound(ard, 1))
        For i = UBound(ard, 1) To LBound(ard, 1) Step -1
            For j = UBound(ard, 2) To LBound(ard, 2) Step -1
                ard2(j, i) = ard(i, j)
            Next
        Next
        ' delete zero rows
        For i = UBound(ard2, 2) To LBound(ard2, 2) Step -1
            M = 0
            For j = UBound(ard2, 1) To LBound(ard2, 1) Step -1
                M = M + Abs(ard2(j, i))
            Next
            If M = 0 Then
                ReDim Preserve ard2(1 To UBound(ard2, 1), 1 To i - 1)
            Else
                Exit For
            End If
        Next
        ' transpose back
        
        ReDim ard(1 To UBound(ard2, 2), 1 To UBound(ard2, 1))
        For i = UBound(ard2, 1) To LBound(ard2, 1) Step -1
            For j = UBound(ard2, 2) To LBound(ard2, 2) Step -1
                ard(j, i) = ard2(i, j)
            Next
        Next
        If remove_only_rows Then
        ' when array used for pipe trajectory
        ' zeros in columns can have meaning
        ' delete zero cols
            For i = UBound(ard, 2) To LBound(ard, 2) Step -1
                M = 0
                For j = UBound(ard, 1) To LBound(ard, 1) Step -1
                    M = M + Abs(ard(j, i))
                Next
                If M = 0 Then
                    ReDim Preserve ard(1 To UBound(ard, 1), 1 To i - 1)
                Else
                    Exit For
                End If
            Next
        End If
        
    End If
    
    
    array_num_from_range = ard
        
    Exit Function
err1:
    val = 0
    Resume Next
err2:
    
End Function
Public Function array1d_from_range(var_input, _
                        Optional ByVal num_only As Boolean = False, _
                        Optional ByVal no_zero As Boolean = False)
' return 1 d array from range or from array or from number
    Dim ar
    Dim arout() As Variant
    Dim rng As range
    Dim i As Integer
    Dim j As Integer
    Dim K As Integer
    Dim num As Integer
On Error GoTo err1:
    If num_only And no_zero Then
        ar = array_num_from_range(var_input, remove_zeros:=True)
    ElseIf num_only Then
        ar = array_num_from_range(var_input, remove_zeros:=False)
    Else
        ar = array_from_range(var_input)
    End If
    num = (UBound(ar, 1) - LBound(ar, 1) + 1) * (UBound(ar, 2) - LBound(ar, 2) + 1)
    ReDim arout(1 To num)
    K = 1
    For i = LBound(ar, 1) To UBound(ar, 1)
        For j = LBound(ar, 2) To UBound(ar, 2)
            arout(K) = ar(i, j)
            K = K + 1
        Next
    Next
    array1d_from_range = arout
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "Error:array1d_from_range:" & Err.Description
    addLogMsg (errmsg)
    Err.Raise kreadRangeError, "array1d_from_range", errmsg
End Function
Public Function readRange(rr)
    Dim ar() As Variant
    Dim arout() As Variant
        Dim i As Integer
        Dim j As Integer
On Error GoTo err1:
    If (TypeOf rr Is range) Or IsArray(rr) Then
        j = 0
        If (TypeOf rr Is range) Then
            If rr.Cells.Count = 1 Then
                ReDim ar(1 To 1, 1 To 1)
                ar(1, 1) = rr.Value
            Else
                ar = rr.Value
            End If
            For i = LBound(ar) To UBound(ar)
                If Not IsEmpty(ar(i, 1)) Then
                    j = j + 1
                    ReDim Preserve arout(1 To j)
                    arout(j) = ar(i, 1)
                End If
            Next i
        Else
            ReDim arout(LBound(rr) To UBound(rr))
            For i = LBound(rr) To UBound(rr)
                arout(i) = rr(i)
                j = j + 1
            Next i
        End If
        If j = 0 Then
        ' не газлифтная скважина
            ReDim arout(1 To 1)
            arout(1) = 0
        End If
    Else
        ReDim arout(1 To 1)
        arout(1) = rr
    End If
    readRange = arout
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "Error:readRange:" & Err.Description
    addLogMsg (errmsg)
    Err.Raise kreadRangeError, "readRange", errmsg
End Function
Public Function array_join(arr_in As Variant)
' get one two dimensional array from array of arrays
' needed to support array output to range from VBA
    Dim arr_out As Variant
    Dim num_rows As Integer
    Dim num_cols As Integer
    Dim L As Integer, U As Integer
    Dim i As Integer, j As Integer
    L = LBound(arr_in)
    U = UBound(arr_in)
    num_cols = UBound(arr_in(L)) - LBound(arr_in(L)) + 1
    num_rows = UBound(arr_in) - LBound(arr_in) + 1
    ReDim arr_out(1 To num_rows, 1 To num_cols)
    For i = 1 To num_rows
        For j = 1 To num_cols
            arr_out(i, j) = arr_in(i - 1 + L)(j - 1 + L)
        Next j
    Next i
    array_join = arr_out
End Function
Public Function CollectionToArray2D(myCol As Collection) As Variant
' на входе должно быть двумерная коллекция - коллекция коллекций
    Dim Result  As Variant
    Dim cnt     As Long
    Dim ncol As Integer
    Dim nrow As Integer
    Dim j As Long
    
    ncol = myCol.Count
    If ncol >= 1 Then
        nrow = myCol(1).Count
    Else
        Err.Raise kErrArraySize, , "CollectionToArray2D error - wrong dimension"
    End If
    
    If ncol = 2 And nrow > 0 Then
        ReDim Result(1 To nrow, 1 To ncol)
        
        For cnt = 1 To myCol.Count
            For j = 1 To nrow
                Result(j, cnt) = myCol(cnt)(j)
                
            Next j
        Next cnt
    ElseIf ncol > 0 And nrow = 2 Then
        
        ReDim Result(1 To ncol, 1 To nrow)
        
        For cnt = 1 To myCol.Count
            For j = 1 To nrow
                Result(cnt, j) = myCol(cnt)(j)
                
            Next j
        Next cnt
    End If
    CollectionToArray2D = Result
End Function

